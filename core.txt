Loaded package environment from /home/ray/.ghc/x86_64-linux-8.10.1/environments/default
[ 1 of 14] Compiling TypeDefs         ( TypeDefs.hs, TypeDefs.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,437, types: 873, coercions: 189, joins: 2/2}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType31 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType31 = "Pawn"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType30 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType30
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType31

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType27 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadPieceType27 = "Knight"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType26 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType26
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType27

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType23 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadPieceType23 = "Bishop"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType22 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType22
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType23

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType19 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType19 = "Rook"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType18 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType18
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType19

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType15 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadPieceType15 = "Queen"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType14 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType14
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType15

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType11 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType11 = "King"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType10 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType10
  = GHC.CString.unpackCString# TypeDefs.$fReadPieceType11

-- RHS size: {terms: 28, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> String -> String
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [220 0] 240 0}]
TypeDefs.$w$cshowsPrec1
  = \ (w_s2kN :: PieceType) (w1_s2kO :: String) ->
      case w_s2kN of {
        Pawn -> ++ @ Char TypeDefs.$fReadPieceType30 w1_s2kO;
        Knight -> ++ @ Char TypeDefs.$fReadPieceType26 w1_s2kO;
        Bishop -> ++ @ Char TypeDefs.$fReadPieceType22 w1_s2kO;
        Rook -> ++ @ Char TypeDefs.$fReadPieceType18 w1_s2kO;
        Queen -> ++ @ Char TypeDefs.$fReadPieceType14 w1_s2kO;
        King -> ++ @ Char TypeDefs.$fReadPieceType10 w1_s2kO
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
TypeDefs.$fShowPieceType_$cshowsPrec [InlPrag=NOUSERINLINE[2]]
  :: Int -> PieceType -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s2kN [Occ=Once] :: PieceType)
                 (w2_s2kO [Occ=Once] :: String) ->
                 TypeDefs.$w$cshowsPrec1 w1_s2kN w2_s2kO}]
TypeDefs.$fShowPieceType_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s2kN :: PieceType) (w2_s2kO :: String) ->
      TypeDefs.$w$cshowsPrec1 w1_s2kN w2_s2kO

-- RHS size: {terms: 15, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fShowPieceType_$cshow :: PieceType -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1W3 [Occ=Once!] :: PieceType) ->
                 case x_a1W3 of {
                   Pawn -> TypeDefs.$fReadPieceType30;
                   Knight -> TypeDefs.$fReadPieceType26;
                   Bishop -> TypeDefs.$fReadPieceType22;
                   Rook -> TypeDefs.$fReadPieceType18;
                   Queen -> TypeDefs.$fReadPieceType14;
                   King -> TypeDefs.$fReadPieceType10
                 }}]
TypeDefs.$fShowPieceType_$cshow
  = \ (x_a1W3 :: PieceType) ->
      case x_a1W3 of {
        Pawn -> TypeDefs.$fReadPieceType30;
        Knight -> TypeDefs.$fReadPieceType26;
        Bishop -> TypeDefs.$fReadPieceType22;
        Rook -> TypeDefs.$fReadPieceType18;
        Queen -> TypeDefs.$fReadPieceType14;
        King -> TypeDefs.$fReadPieceType10
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fShowPieceType_$cshowList :: [PieceType] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_a1W6 [Occ=Once] :: [PieceType])
                 (s_a1W7 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ PieceType TypeDefs.$w$cshowsPrec1 ls_a1W6 s_a1W7}]
TypeDefs.$fShowPieceType_$cshowList
  = \ (ls_a1W6 :: [PieceType]) (s_a1W7 :: String) ->
      GHC.Show.showList__
        @ PieceType TypeDefs.$w$cshowsPrec1 ls_a1W6 s_a1W7

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fShowPieceType [InlPrag=NOUSERINLINE CONLIKE]
  :: Show PieceType
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: PieceType
                       TypeDefs.$fShowPieceType_$cshowsPrec
                       TypeDefs.$fShowPieceType_$cshow
                       TypeDefs.$fShowPieceType_$cshowList]
TypeDefs.$fShowPieceType
  = GHC.Show.C:Show
      @ PieceType
      TypeDefs.$fShowPieceType_$cshowsPrec
      TypeDefs.$fShowPieceType_$cshow
      TypeDefs.$fShowPieceType_$cshowList

-- RHS size: {terms: 46, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fEqPieceType_$c== :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [170 180] 180 120}]
TypeDefs.$fEqPieceType_$c==
  = \ (ds_d1WG :: PieceType) (ds1_d1WH :: PieceType) ->
      case ds_d1WG of {
        Pawn ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            Pawn -> GHC.Types.True
          };
        Knight ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            Knight -> GHC.Types.True
          };
        Bishop ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            Bishop -> GHC.Types.True
          };
        Rook ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            Rook -> GHC.Types.True
          };
        Queen ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            Queen -> GHC.Types.True
          };
        King ->
          case ds1_d1WH of {
            __DEFAULT -> GHC.Types.False;
            King -> GHC.Types.True
          }
      }

-- RHS size: {terms: 46, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fEqPieceType_$c/= [InlPrag=INLINE (sat-args=2)]
  :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1VA [Occ=Once!] :: PieceType)
                 (y_a1VB [Occ=Once*!] :: PieceType) ->
                 case x_a1VA of {
                   Pawn ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Pawn -> GHC.Types.False
                     };
                   Knight ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Knight -> GHC.Types.False
                     };
                   Bishop ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Bishop -> GHC.Types.False
                     };
                   Rook ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Rook -> GHC.Types.False
                     };
                   Queen ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Queen -> GHC.Types.False
                     };
                   King ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       King -> GHC.Types.False
                     }
                 }}]
TypeDefs.$fEqPieceType_$c/=
  = \ (eta_B2 :: PieceType) (eta1_B1 :: PieceType) ->
      case eta_B2 of {
        Pawn ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Pawn -> GHC.Types.False
          };
        Knight ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Knight -> GHC.Types.False
          };
        Bishop ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Bishop -> GHC.Types.False
          };
        Rook ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Rook -> GHC.Types.False
          };
        Queen ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Queen -> GHC.Types.False
          };
        King ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            King -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fEqPieceType [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq PieceType
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: PieceType
                        TypeDefs.$fEqPieceType_$c==
                        TypeDefs.$fEqPieceType_$c/=]
TypeDefs.$fEqPieceType
  = GHC.Classes.C:Eq
      @ PieceType TypeDefs.$fEqPieceType_$c== TypeDefs.$fEqPieceType_$c/=

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType29
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Pawn}]
TypeDefs.$fReadPieceType29
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Pawn

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType28
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType28
  = (TypeDefs.$fReadPieceType30,
     TypeDefs.$fReadPieceType29
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType25
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Knight}]
TypeDefs.$fReadPieceType25
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Knight

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType24
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType24
  = (TypeDefs.$fReadPieceType26,
     TypeDefs.$fReadPieceType25
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType21
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Bishop}]
TypeDefs.$fReadPieceType21
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Bishop

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType20
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType20
  = (TypeDefs.$fReadPieceType22,
     TypeDefs.$fReadPieceType21
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType17
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Rook}]
TypeDefs.$fReadPieceType17
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Rook

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType16
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType16
  = (TypeDefs.$fReadPieceType18,
     TypeDefs.$fReadPieceType17
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType13
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Queen}]
TypeDefs.$fReadPieceType13
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Queen

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType12
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType12
  = (TypeDefs.$fReadPieceType14,
     TypeDefs.$fReadPieceType13
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType9
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.King}]
TypeDefs.$fReadPieceType9
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: PieceType -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.King

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType8
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType8
  = (TypeDefs.$fReadPieceType10,
     TypeDefs.$fReadPieceType9
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <PieceType>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (PieceType -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType7
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType7
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType8
      (GHC.Types.[]
         @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType6
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType6
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType12
      TypeDefs.$fReadPieceType7

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType5
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType5
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType16
      TypeDefs.$fReadPieceType6

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType4
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType4
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType20
      TypeDefs.$fReadPieceType5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType3
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType3
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType24
      TypeDefs.$fReadPieceType4

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType_sps
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadPieceType_sps
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
      TypeDefs.$fReadPieceType28
      TypeDefs.$fReadPieceType3

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType2
  :: Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP PieceType
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_a1Yi [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec) ->
                 GHC.Read.choose2
                   @ PieceType TypeDefs.$fReadPieceType_sps eta_a1Yi}]
TypeDefs.$fReadPieceType2
  = \ (eta_a1Yi :: Text.ParserCombinators.ReadPrec.Prec) ->
      GHC.Read.choose2 @ PieceType TypeDefs.$fReadPieceType_sps eta_a1Yi

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
TypeDefs.$fReadPieceType1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (PieceType -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= GHC.Read.$fRead()7
                 @ PieceType
                 (TypeDefs.$fReadPieceType2
                  `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <PieceType>_R)
                          :: (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP PieceType)
                             ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))}]
TypeDefs.$fReadPieceType1
  = GHC.Read.$fRead()7
      @ PieceType
      (TypeDefs.$fReadPieceType2
       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <PieceType>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> Text.ParserCombinators.ReadP.ReadP PieceType)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 6, types: 5, coercions: 3, joins: 0/0}
TypeDefs.$fReadPieceType_$creadsPrec :: Int -> ReadS PieceType
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_a1Wc [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ PieceType
                   (GHC.Read.$fRead()7
                      @ PieceType
                      (TypeDefs.$fReadPieceType2
                       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                        <PieceType>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> Text.ParserCombinators.ReadP.ReadP PieceType)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))
                      n_a1Wc
                      @ PieceType
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ PieceType))}]
TypeDefs.$fReadPieceType_$creadsPrec
  = \ (n_a1Wc :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ PieceType
        (GHC.Read.$fRead()7
           @ PieceType
           (TypeDefs.$fReadPieceType2
            `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <PieceType>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> Text.ParserCombinators.ReadP.ReadP PieceType)
                       ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))
           n_a1Wc
           @ PieceType
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ PieceType))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [PieceType]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadPieceType_$creadListPrec
  = GHC.Read.list
      @ PieceType
      (TypeDefs.$fReadPieceType1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <PieceType>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (PieceType -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
TypeDefs.$fReadPieceType32
  :: Text.ParserCombinators.ReadP.P [PieceType]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadPieceType32
  = (((TypeDefs.$fReadPieceType_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                   <[PieceType]>_R
               :: Text.ParserCombinators.ReadPrec.ReadPrec [PieceType]
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [PieceType])))
        GHC.Read.$fRead()9)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[PieceType]>_R
             :: Text.ParserCombinators.ReadP.ReadP [PieceType]
                ~R# (forall b.
                     ([PieceType] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b)))
      @ [PieceType]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [PieceType])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadPieceType_$creadList :: ReadS [PieceType]
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= Text.ParserCombinators.ReadP.run
                 @ [PieceType] TypeDefs.$fReadPieceType32}]
TypeDefs.$fReadPieceType_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [PieceType] TypeDefs.$fReadPieceType32

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadPieceType [InlPrag=NOUSERINLINE CONLIKE]
  :: Read PieceType
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: PieceType
                       TypeDefs.$fReadPieceType_$creadsPrec
                       TypeDefs.$fReadPieceType_$creadList
                       TypeDefs.$fReadPieceType1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <PieceType>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (PieceType -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType)
                       TypeDefs.$fReadPieceType_$creadListPrec]
TypeDefs.$fReadPieceType
  = GHC.Read.C:Read
      @ PieceType
      TypeDefs.$fReadPieceType_$creadsPrec
      TypeDefs.$fReadPieceType_$creadList
      (TypeDefs.$fReadPieceType1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <PieceType>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <PieceType>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (PieceType -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec PieceType))
      TypeDefs.$fReadPieceType_$creadListPrec

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour11 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadColour11 = "Black"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour10 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadColour10
  = GHC.CString.unpackCString# TypeDefs.$fReadColour11

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadColour7 = "White"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadColour6
  = GHC.CString.unpackCString# TypeDefs.$fReadColour7

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fShowColour_$cshowsPrec :: Int -> Colour -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_d1WC [Occ=Once!] :: Colour)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds1_d1WC of {
                   Black ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_a1X1)
                          (c_a1X2 [Occ=Once, OS=OneShot] :: Char -> b_a1X1 -> b_a1X1)
                          (n_a1X3 [Occ=Once, OS=OneShot] :: b_a1X1) ->
                          GHC.Base.foldr
                            @ Char @ b_a1X1 c_a1X2 n_a1X3 TypeDefs.$fReadColour10)
                       eta_B1;
                   White ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_a1X1)
                          (c_a1X2 [Occ=Once, OS=OneShot] :: Char -> b_a1X1 -> b_a1X1)
                          (n_a1X3 [Occ=Once, OS=OneShot] :: b_a1X1) ->
                          GHC.Base.foldr
                            @ Char @ b_a1X1 c_a1X2 n_a1X3 TypeDefs.$fReadColour6)
                       eta_B1
                 }}]
TypeDefs.$fShowColour_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_d1WC :: Colour) (eta_B1 :: String) ->
      case ds1_d1WC of {
        Black -> ++ @ Char TypeDefs.$fReadColour10 eta_B1;
        White -> ++ @ Char TypeDefs.$fReadColour6 eta_B1
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fShowColour_$cshow :: Colour -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a1W3 [Occ=Once!] :: Colour) ->
                 case x_a1W3 of {
                   Black -> TypeDefs.$fReadColour10;
                   White -> TypeDefs.$fReadColour6
                 }}]
TypeDefs.$fShowColour_$cshow
  = \ (x_a1W3 :: Colour) ->
      case x_a1W3 of {
        Black -> TypeDefs.$fReadColour10;
        White -> TypeDefs.$fReadColour6
      }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
TypeDefs.$fShowColour1 :: Colour -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1WC [Occ=Once!] :: Colour)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds_d1WC of {
                   Black ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_a1X1)
                          (c_a1X2 [Occ=Once, OS=OneShot] :: Char -> b_a1X1 -> b_a1X1)
                          (n_a1X3 [Occ=Once, OS=OneShot] :: b_a1X1) ->
                          GHC.Base.foldr
                            @ Char @ b_a1X1 c_a1X2 n_a1X3 TypeDefs.$fReadColour10)
                       eta_B1;
                   White ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_a1X1)
                          (c_a1X2 [Occ=Once, OS=OneShot] :: Char -> b_a1X1 -> b_a1X1)
                          (n_a1X3 [Occ=Once, OS=OneShot] :: b_a1X1) ->
                          GHC.Base.foldr
                            @ Char @ b_a1X1 c_a1X2 n_a1X3 TypeDefs.$fReadColour6)
                       eta_B1
                 }}]
TypeDefs.$fShowColour1
  = \ (ds_d1WC :: Colour) (eta_B1 :: String) ->
      case ds_d1WC of {
        Black -> ++ @ Char TypeDefs.$fReadColour10 eta_B1;
        White -> ++ @ Char TypeDefs.$fReadColour6 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fShowColour_$cshowList :: [Colour] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_a1W6 [Occ=Once] :: [Colour])
                 (s_a1W7 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ Colour TypeDefs.$fShowColour1 ls_a1W6 s_a1W7}]
TypeDefs.$fShowColour_$cshowList
  = \ (ls_a1W6 :: [Colour]) (s_a1W7 :: String) ->
      GHC.Show.showList__ @ Colour TypeDefs.$fShowColour1 ls_a1W6 s_a1W7

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fShowColour [InlPrag=NOUSERINLINE CONLIKE] :: Show Colour
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Colour
                       TypeDefs.$fShowColour_$cshowsPrec
                       TypeDefs.$fShowColour_$cshow
                       TypeDefs.$fShowColour_$cshowList]
TypeDefs.$fShowColour
  = GHC.Show.C:Show
      @ Colour
      TypeDefs.$fShowColour_$cshowsPrec
      TypeDefs.$fShowColour_$cshow
      TypeDefs.$fShowColour_$cshowList

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
TypeDefs.$fEqColour_$c== :: Colour -> Colour -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1Wx [Occ=Once!] :: Colour)
                 (ds1_d1Wy [Occ=Once*!] :: Colour) ->
                 case ds_d1Wx of {
                   Black ->
                     case ds1_d1Wy of {
                       Black -> GHC.Types.True;
                       White -> GHC.Types.False
                     };
                   White ->
                     case ds1_d1Wy of {
                       Black -> GHC.Types.False;
                       White -> GHC.Types.True
                     }
                 }}]
TypeDefs.$fEqColour_$c==
  = \ (ds_d1Wx :: Colour) (ds1_d1Wy :: Colour) ->
      case ds_d1Wx of {
        Black ->
          case ds1_d1Wy of {
            Black -> GHC.Types.True;
            White -> GHC.Types.False
          };
        White ->
          case ds1_d1Wy of {
            Black -> GHC.Types.False;
            White -> GHC.Types.True
          }
      }

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
TypeDefs.$fEqColour_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Colour -> Colour -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1VA [Occ=Once!] :: Colour)
                 (y_a1VB [Occ=Once*!] :: Colour) ->
                 case x_a1VA of {
                   Black ->
                     case y_a1VB of {
                       Black -> GHC.Types.False;
                       White -> GHC.Types.True
                     };
                   White ->
                     case y_a1VB of {
                       Black -> GHC.Types.True;
                       White -> GHC.Types.False
                     }
                 }}]
TypeDefs.$fEqColour_$c/=
  = \ (eta_B2 :: Colour) (eta1_B1 :: Colour) ->
      case eta_B2 of {
        Black ->
          case eta1_B1 of {
            Black -> GHC.Types.False;
            White -> GHC.Types.True
          };
        White ->
          case eta1_B1 of {
            Black -> GHC.Types.True;
            White -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fEqColour [InlPrag=NOUSERINLINE CONLIKE] :: Eq Colour
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Colour
                        TypeDefs.$fEqColour_$c==
                        TypeDefs.$fEqColour_$c/=]
TypeDefs.$fEqColour
  = GHC.Classes.C:Eq
      @ Colour TypeDefs.$fEqColour_$c== TypeDefs.$fEqColour_$c/=

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour9
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Colour -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: Colour -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Black}]
TypeDefs.$fReadColour9
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: Colour -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Black

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadColour8
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec Colour)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadColour8
  = (TypeDefs.$fReadColour10,
     TypeDefs.$fReadColour9
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <Colour>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Colour>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (Colour -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour5
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Colour -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: Colour -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.White}]
TypeDefs.$fReadColour5
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: Colour -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.White

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadColour4
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec Colour)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadColour4
  = (TypeDefs.$fReadColour6,
     TypeDefs.$fReadColour5
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <Colour>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Colour>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (Colour -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour3
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec Colour)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadColour3
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec Colour)
      TypeDefs.$fReadColour4
      (GHC.Types.[]
         @ (String, Text.ParserCombinators.ReadPrec.ReadPrec Colour))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour_sps
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec Colour)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadColour_sps
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec Colour)
      TypeDefs.$fReadColour8
      TypeDefs.$fReadColour3

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour2
  :: Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP Colour
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_X20w [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec) ->
                 GHC.Read.choose2 @ Colour TypeDefs.$fReadColour_sps eta_X20w}]
TypeDefs.$fReadColour2
  = \ (eta_X20w :: Text.ParserCombinators.ReadPrec.Prec) ->
      GHC.Read.choose2 @ Colour TypeDefs.$fReadColour_sps eta_X20w

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
TypeDefs.$fReadColour1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Colour -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= GHC.Read.$fRead()7
                 @ Colour
                 (TypeDefs.$fReadColour2
                  `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <Colour>_R)
                          :: (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP Colour)
                             ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))}]
TypeDefs.$fReadColour1
  = GHC.Read.$fRead()7
      @ Colour
      (TypeDefs.$fReadColour2
       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <Colour>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> Text.ParserCombinators.ReadP.ReadP Colour)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))

-- RHS size: {terms: 6, types: 5, coercions: 3, joins: 0/0}
TypeDefs.$fReadColour_$creadsPrec :: Int -> ReadS Colour
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_a1Wc [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Colour
                   (GHC.Read.$fRead()7
                      @ Colour
                      (TypeDefs.$fReadColour2
                       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                        <Colour>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> Text.ParserCombinators.ReadP.ReadP Colour)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))
                      n_a1Wc
                      @ Colour
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Colour))}]
TypeDefs.$fReadColour_$creadsPrec
  = \ (n_a1Wc :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ Colour
        (GHC.Read.$fRead()7
           @ Colour
           (TypeDefs.$fReadColour2
            `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Colour>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> Text.ParserCombinators.ReadP.ReadP Colour)
                       ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))
           n_a1Wc
           @ Colour
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Colour))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadColour_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Colour]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadColour_$creadListPrec
  = GHC.Read.list
      @ Colour
      (TypeDefs.$fReadColour1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Colour>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      <Colour>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Colour -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
TypeDefs.$fReadColour12 :: Text.ParserCombinators.ReadP.P [Colour]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadColour12
  = (((TypeDefs.$fReadColour_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Colour]>_R
               :: Text.ParserCombinators.ReadPrec.ReadPrec [Colour]
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Colour])))
        GHC.Read.$fRead()9)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Colour]>_R
             :: Text.ParserCombinators.ReadP.ReadP [Colour]
                ~R# (forall b.
                     ([Colour] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b)))
      @ [Colour]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Colour])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadColour_$creadList :: ReadS [Colour]
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= Text.ParserCombinators.ReadP.run
                 @ [Colour] TypeDefs.$fReadColour12}]
TypeDefs.$fReadColour_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [Colour] TypeDefs.$fReadColour12

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadColour [InlPrag=NOUSERINLINE CONLIKE] :: Read Colour
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Colour
                       TypeDefs.$fReadColour_$creadsPrec
                       TypeDefs.$fReadColour_$creadList
                       TypeDefs.$fReadColour1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Colour>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Colour>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Colour -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour)
                       TypeDefs.$fReadColour_$creadListPrec]
TypeDefs.$fReadColour
  = GHC.Read.C:Read
      @ Colour
      TypeDefs.$fReadColour_$creadsPrec
      TypeDefs.$fReadColour_$creadList
      (TypeDefs.$fReadColour1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Colour>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      <Colour>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Colour -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec Colour))
      TypeDefs.$fReadColour_$creadListPrec

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint16 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadGamePoint16 = "Opening"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint15 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadGamePoint15
  = GHC.CString.unpackCString# TypeDefs.$fReadGamePoint16

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint14
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GamePoint -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Opening}]
TypeDefs.$fReadGamePoint14
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Opening

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadGamePoint13
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint13
  = (TypeDefs.$fReadGamePoint15,
     TypeDefs.$fReadGamePoint14
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <GamePoint>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (GamePoint -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint12 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadGamePoint12 = "Middle"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint11 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadGamePoint11
  = GHC.CString.unpackCString# TypeDefs.$fReadGamePoint12

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint10
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GamePoint -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.Middle}]
TypeDefs.$fReadGamePoint10
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.Middle

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadGamePoint9
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint9
  = (TypeDefs.$fReadGamePoint11,
     TypeDefs.$fReadGamePoint10
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <GamePoint>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (GamePoint -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint8 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadGamePoint8 = "End"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadGamePoint7
  = GHC.CString.unpackCString# TypeDefs.$fReadGamePoint8

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint6
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GamePoint -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_a1Yw)
                 (k_a1Yx [Occ=Once!]
                    :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
                 k_a1Yx TypeDefs.End}]
TypeDefs.$fReadGamePoint6
  = \ _ [Occ=Dead]
      (@ b_a1Yw)
      (k_a1Yx :: GamePoint -> Text.ParserCombinators.ReadP.P b_a1Yw) ->
      k_a1Yx TypeDefs.End

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
TypeDefs.$fReadGamePoint5
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint5
  = (TypeDefs.$fReadGamePoint7,
     TypeDefs.$fReadGamePoint6
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <GamePoint>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (GamePoint -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b)
                ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint4
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint4
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
      TypeDefs.$fReadGamePoint5
      (GHC.Types.[]
         @ (String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint3
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint3
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
      TypeDefs.$fReadGamePoint9
      TypeDefs.$fReadGamePoint4

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint_sps
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$fReadGamePoint_sps
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
      TypeDefs.$fReadGamePoint13
      TypeDefs.$fReadGamePoint3

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint2
  :: Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP GamePoint
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_X20H [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec) ->
                 GHC.Read.choose2
                   @ GamePoint TypeDefs.$fReadGamePoint_sps eta_X20H}]
TypeDefs.$fReadGamePoint2
  = \ (eta_X20H :: Text.ParserCombinators.ReadPrec.Prec) ->
      GHC.Read.choose2 @ GamePoint TypeDefs.$fReadGamePoint_sps eta_X20H

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
TypeDefs.$fReadGamePoint1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GamePoint -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= GHC.Read.$fRead()7
                 @ GamePoint
                 (TypeDefs.$fReadGamePoint2
                  `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <GamePoint>_R)
                          :: (Text.ParserCombinators.ReadPrec.Prec
                              -> Text.ParserCombinators.ReadP.ReadP GamePoint)
                             ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))}]
TypeDefs.$fReadGamePoint1
  = GHC.Read.$fRead()7
      @ GamePoint
      (TypeDefs.$fReadGamePoint2
       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <GamePoint>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> Text.ParserCombinators.ReadP.ReadP GamePoint)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 6, types: 5, coercions: 3, joins: 0/0}
TypeDefs.$fReadGamePoint_$creadsPrec :: Int -> ReadS GamePoint
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_a1Wc [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ GamePoint
                   (GHC.Read.$fRead()7
                      @ GamePoint
                      (TypeDefs.$fReadGamePoint2
                       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                        <GamePoint>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> Text.ParserCombinators.ReadP.ReadP GamePoint)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))
                      n_a1Wc
                      @ GamePoint
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ GamePoint))}]
TypeDefs.$fReadGamePoint_$creadsPrec
  = \ (n_a1Wc :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ GamePoint
        (GHC.Read.$fRead()7
           @ GamePoint
           (TypeDefs.$fReadGamePoint2
            `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <GamePoint>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> Text.ParserCombinators.ReadP.ReadP GamePoint)
                       ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))
           n_a1Wc
           @ GamePoint
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ GamePoint))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadGamePoint_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [GamePoint]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$fReadGamePoint_$creadListPrec
  = GHC.Read.list
      @ GamePoint
      (TypeDefs.$fReadGamePoint1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <GamePoint>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (GamePoint -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
TypeDefs.$fReadGamePoint17
  :: Text.ParserCombinators.ReadP.P [GamePoint]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$fReadGamePoint17
  = (((TypeDefs.$fReadGamePoint_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                   <[GamePoint]>_R
               :: Text.ParserCombinators.ReadPrec.ReadPrec [GamePoint]
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [GamePoint])))
        GHC.Read.$fRead()9)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[GamePoint]>_R
             :: Text.ParserCombinators.ReadP.ReadP [GamePoint]
                ~R# (forall b.
                     ([GamePoint] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b)))
      @ [GamePoint]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [GamePoint])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fReadGamePoint_$creadList :: ReadS [GamePoint]
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= Text.ParserCombinators.ReadP.run
                 @ [GamePoint] TypeDefs.$fReadGamePoint17}]
TypeDefs.$fReadGamePoint_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [GamePoint] TypeDefs.$fReadGamePoint17

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
TypeDefs.$fReadGamePoint [InlPrag=NOUSERINLINE CONLIKE]
  :: Read GamePoint
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: GamePoint
                       TypeDefs.$fReadGamePoint_$creadsPrec
                       TypeDefs.$fReadGamePoint_$creadList
                       TypeDefs.$fReadGamePoint1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <GamePoint>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (GamePoint -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b)
                                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint)
                       TypeDefs.$fReadGamePoint_$creadListPrec]
TypeDefs.$fReadGamePoint
  = GHC.Read.C:Read
      @ GamePoint
      TypeDefs.$fReadGamePoint_$creadsPrec
      TypeDefs.$fReadGamePoint_$creadList
      (TypeDefs.$fReadGamePoint1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <GamePoint>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <GamePoint>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (GamePoint -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b)
                  ~R# Text.ParserCombinators.ReadPrec.ReadPrec GamePoint))
      TypeDefs.$fReadGamePoint_$creadListPrec

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$w$cshowsPrec [InlPrag=NOUSERINLINE[2]]
  :: GamePoint -> String -> String
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [100 0] 120 0}]
TypeDefs.$w$cshowsPrec
  = \ (w_s2kT :: GamePoint) (w1_s2kU :: String) ->
      case w_s2kT of {
        Opening -> ++ @ Char TypeDefs.$fReadGamePoint15 w1_s2kU;
        Middle -> ++ @ Char TypeDefs.$fReadGamePoint11 w1_s2kU;
        End -> ++ @ Char TypeDefs.$fReadGamePoint7 w1_s2kU
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
TypeDefs.$fShowGamePoint_$cshowsPrec [InlPrag=NOUSERINLINE[2]]
  :: Int -> GamePoint -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s2kT [Occ=Once] :: GamePoint)
                 (w2_s2kU [Occ=Once] :: String) ->
                 TypeDefs.$w$cshowsPrec w1_s2kT w2_s2kU}]
TypeDefs.$fShowGamePoint_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s2kT :: GamePoint) (w2_s2kU :: String) ->
      TypeDefs.$w$cshowsPrec w1_s2kT w2_s2kU

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fShowGamePoint_$cshow :: GamePoint -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1W3 [Occ=Once!] :: GamePoint) ->
                 case x_a1W3 of {
                   Opening -> TypeDefs.$fReadGamePoint15;
                   Middle -> TypeDefs.$fReadGamePoint11;
                   End -> TypeDefs.$fReadGamePoint7
                 }}]
TypeDefs.$fShowGamePoint_$cshow
  = \ (x_a1W3 :: GamePoint) ->
      case x_a1W3 of {
        Opening -> TypeDefs.$fReadGamePoint15;
        Middle -> TypeDefs.$fReadGamePoint11;
        End -> TypeDefs.$fReadGamePoint7
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
TypeDefs.$fShowGamePoint_$cshowList :: [GamePoint] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_a1W6 [Occ=Once] :: [GamePoint])
                 (s_a1W7 [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ GamePoint TypeDefs.$w$cshowsPrec ls_a1W6 s_a1W7}]
TypeDefs.$fShowGamePoint_$cshowList
  = \ (ls_a1W6 :: [GamePoint]) (s_a1W7 :: String) ->
      GHC.Show.showList__
        @ GamePoint TypeDefs.$w$cshowsPrec ls_a1W6 s_a1W7

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fShowGamePoint [InlPrag=NOUSERINLINE CONLIKE]
  :: Show GamePoint
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: GamePoint
                       TypeDefs.$fShowGamePoint_$cshowsPrec
                       TypeDefs.$fShowGamePoint_$cshow
                       TypeDefs.$fShowGamePoint_$cshowList]
TypeDefs.$fShowGamePoint
  = GHC.Show.C:Show
      @ GamePoint
      TypeDefs.$fShowGamePoint_$cshowsPrec
      TypeDefs.$fShowGamePoint_$cshow
      TypeDefs.$fShowGamePoint_$cshowList

-- RHS size: {terms: 25, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fEqGamePoint_$c== :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1Vu [Occ=Once!] :: GamePoint)
                 (ds1_d1Vv [Occ=Once*!] :: GamePoint) ->
                 case ds_d1Vu of {
                   Opening ->
                     case ds1_d1Vv of {
                       __DEFAULT -> GHC.Types.False;
                       Opening -> GHC.Types.True
                     };
                   Middle ->
                     case ds1_d1Vv of {
                       __DEFAULT -> GHC.Types.False;
                       Middle -> GHC.Types.True
                     };
                   End ->
                     case ds1_d1Vv of {
                       __DEFAULT -> GHC.Types.False;
                       End -> GHC.Types.True
                     }
                 }}]
TypeDefs.$fEqGamePoint_$c==
  = \ (ds_d1Vu :: GamePoint) (ds1_d1Vv :: GamePoint) ->
      case ds_d1Vu of {
        Opening ->
          case ds1_d1Vv of {
            __DEFAULT -> GHC.Types.False;
            Opening -> GHC.Types.True
          };
        Middle ->
          case ds1_d1Vv of {
            __DEFAULT -> GHC.Types.False;
            Middle -> GHC.Types.True
          };
        End ->
          case ds1_d1Vv of {
            __DEFAULT -> GHC.Types.False;
            End -> GHC.Types.True
          }
      }

-- RHS size: {terms: 25, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fEqGamePoint_$c/= [InlPrag=INLINE (sat-args=2)]
  :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1VA [Occ=Once!] :: GamePoint)
                 (y_a1VB [Occ=Once*!] :: GamePoint) ->
                 case x_a1VA of {
                   Opening ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Opening -> GHC.Types.False
                     };
                   Middle ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       Middle -> GHC.Types.False
                     };
                   End ->
                     case y_a1VB of {
                       __DEFAULT -> GHC.Types.True;
                       End -> GHC.Types.False
                     }
                 }}]
TypeDefs.$fEqGamePoint_$c/=
  = \ (eta_B2 :: GamePoint) (eta1_B1 :: GamePoint) ->
      case eta_B2 of {
        Opening ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Opening -> GHC.Types.False
          };
        Middle ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Middle -> GHC.Types.False
          };
        End ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            End -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fEqGamePoint [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq GamePoint
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: GamePoint
                        TypeDefs.$fEqGamePoint_$c==
                        TypeDefs.$fEqGamePoint_$c/=]
TypeDefs.$fEqGamePoint
  = GHC.Classes.C:Eq
      @ GamePoint TypeDefs.$fEqGamePoint_$c== TypeDefs.$fEqGamePoint_$c/=

-- RHS size: {terms: 29, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint_$ccompare
  :: GamePoint -> GamePoint -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 110] 110 80}]
TypeDefs.$fOrdGamePoint_$ccompare
  = \ (a_a1GD :: GamePoint) (b_a1GE :: GamePoint) ->
      case a_a1GD of {
        Opening ->
          case b_a1GE of {
            Opening -> GHC.Types.EQ;
            Middle -> GHC.Types.LT;
            End -> GHC.Types.LT
          };
        Middle ->
          case b_a1GE of {
            Opening -> GHC.Types.GT;
            Middle -> GHC.Types.EQ;
            End -> GHC.Types.LT
          };
        End ->
          case b_a1GE of {
            __DEFAULT -> GHC.Types.GT;
            End -> GHC.Types.EQ
          }
      }

-- RHS size: {terms: 25, types: 6, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint_$c< :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a1GH [Occ=Once!] :: GamePoint)
                 (b_a1GI [Occ=Once*] :: GamePoint) ->
                 case a_a1GH of {
                   Opening ->
                     case b_a1GI of {
                       Opening -> GHC.Types.False;
                       Middle -> GHC.Types.True;
                       End -> GHC.Types.True
                     };
                   Middle ->
                     case b_a1GI of {
                       __DEFAULT -> GHC.Types.False;
                       End -> GHC.Types.True
                     };
                   End -> case b_a1GI of { __DEFAULT -> GHC.Types.False }
                 }}]
TypeDefs.$fOrdGamePoint_$c<
  = \ (a_a1GH :: GamePoint) (b_a1GI :: GamePoint) ->
      case a_a1GH of {
        Opening ->
          case b_a1GI of {
            Opening -> GHC.Types.False;
            Middle -> GHC.Types.True;
            End -> GHC.Types.True
          };
        Middle ->
          case b_a1GI of {
            __DEFAULT -> GHC.Types.False;
            End -> GHC.Types.True
          };
        End -> case b_a1GI of { __DEFAULT -> GHC.Types.False }
      }

-- RHS size: {terms: 44, types: 10, coercions: 0, joins: 1/1}
TypeDefs.$fOrdGamePoint_$c<= :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [82 48] 135 0}]
TypeDefs.$fOrdGamePoint_$c<=
  = \ (a_a1GL :: GamePoint) (b_a1GM :: GamePoint) ->
      join {
        $j_s269 [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        $j_s269 (a#_a1GJ [OS=OneShot]
                   :: GHC.Prim.Int#
                   Unf=OtherCon [])
          = case a_a1GL of {
              Opening ->
                case GHC.Prim.<# a#_a1GJ 0# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                };
              Middle ->
                case GHC.Prim.<# a#_a1GJ 1# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                };
              End ->
                case GHC.Prim.<# a#_a1GJ 2# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                }
            } } in
      case b_a1GM of {
        Opening -> jump $j_s269 0#;
        Middle -> jump $j_s269 1#;
        End -> jump $j_s269 2#
      }

-- RHS size: {terms: 44, types: 10, coercions: 0, joins: 1/1}
TypeDefs.$fOrdGamePoint_$c>= :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [48 82] 135 0}]
TypeDefs.$fOrdGamePoint_$c>=
  = \ (a_a1GP :: GamePoint) (b_a1GQ :: GamePoint) ->
      join {
        $j_s269 [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        $j_s269 (a#_a1GJ [OS=OneShot]
                   :: GHC.Prim.Int#
                   Unf=OtherCon [])
          = case b_a1GQ of {
              Opening ->
                case GHC.Prim.<# a#_a1GJ 0# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                };
              Middle ->
                case GHC.Prim.<# a#_a1GJ 1# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                };
              End ->
                case GHC.Prim.<# a#_a1GJ 2# of {
                  __DEFAULT -> GHC.Types.True;
                  1# -> GHC.Types.False
                }
            } } in
      case a_a1GP of {
        Opening -> jump $j_s269 0#;
        Middle -> jump $j_s269 1#;
        End -> jump $j_s269 2#
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint_$cmax
  :: GamePoint -> GamePoint -> GamePoint
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1VH :: GamePoint) (y_a1VI :: GamePoint) ->
                 case TypeDefs.$fOrdGamePoint_$c<= x_a1VH y_a1VI of {
                   False -> x_a1VH;
                   True -> y_a1VI
                 }}]
TypeDefs.$fOrdGamePoint_$cmax
  = \ (x_a1VH :: GamePoint) (y_a1VI :: GamePoint) ->
      case TypeDefs.$fOrdGamePoint_$c<= x_a1VH y_a1VI of {
        False -> x_a1VH;
        True -> y_a1VI
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint_$c> :: GamePoint -> GamePoint -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_a1GN [Occ=Once] :: GamePoint)
                 (b_a1GO [Occ=Once] :: GamePoint) ->
                 TypeDefs.$fOrdGamePoint_$c< b_a1GO a_a1GN}]
TypeDefs.$fOrdGamePoint_$c>
  = \ (a_a1GN :: GamePoint) (b_a1GO :: GamePoint) ->
      TypeDefs.$fOrdGamePoint_$c< b_a1GO a_a1GN

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint_$cmin
  :: GamePoint -> GamePoint -> GamePoint
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1VO :: GamePoint) (y_a1VP :: GamePoint) ->
                 case TypeDefs.$fOrdGamePoint_$c<= x_a1VO y_a1VP of {
                   False -> y_a1VP;
                   True -> x_a1VO
                 }}]
TypeDefs.$fOrdGamePoint_$cmin
  = \ (x_a1VO :: GamePoint) (y_a1VP :: GamePoint) ->
      case TypeDefs.$fOrdGamePoint_$c<= x_a1VO y_a1VP of {
        False -> y_a1VP;
        True -> x_a1VO
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fOrdGamePoint [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord GamePoint
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: GamePoint
                         TypeDefs.$fEqGamePoint
                         TypeDefs.$fOrdGamePoint_$ccompare
                         TypeDefs.$fOrdGamePoint_$c<
                         TypeDefs.$fOrdGamePoint_$c<=
                         TypeDefs.$fOrdGamePoint_$c>
                         TypeDefs.$fOrdGamePoint_$c>=
                         TypeDefs.$fOrdGamePoint_$cmax
                         TypeDefs.$fOrdGamePoint_$cmin]
TypeDefs.$fOrdGamePoint
  = GHC.Classes.C:Ord
      @ GamePoint
      TypeDefs.$fEqGamePoint
      TypeDefs.$fOrdGamePoint_$ccompare
      TypeDefs.$fOrdGamePoint_$c<
      TypeDefs.$fOrdGamePoint_$c<=
      TypeDefs.$fOrdGamePoint_$c>
      TypeDefs.$fOrdGamePoint_$c>=
      TypeDefs.$fOrdGamePoint_$cmax
      TypeDefs.$fOrdGamePoint_$cmin

-- RHS size: {terms: 74, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$ccompare
  :: PieceType -> PieceType -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [270 320] 320 260}]
TypeDefs.$fOrdPieceType_$ccompare
  = \ (a_a1GR :: PieceType) (b_a1GS :: PieceType) ->
      case a_a1GR of {
        Pawn ->
          case b_a1GS of {
            Pawn -> GHC.Types.EQ;
            Knight -> GHC.Types.LT;
            Bishop -> GHC.Types.LT;
            Rook -> GHC.Types.LT;
            Queen -> GHC.Types.LT;
            King -> GHC.Types.LT
          };
        Knight ->
          case b_a1GS of {
            Pawn -> GHC.Types.GT;
            Knight -> GHC.Types.EQ;
            Bishop -> GHC.Types.LT;
            Rook -> GHC.Types.LT;
            Queen -> GHC.Types.LT;
            King -> GHC.Types.LT
          };
        Bishop ->
          case b_a1GS of {
            __DEFAULT -> GHC.Types.GT;
            Bishop -> GHC.Types.EQ;
            Rook -> GHC.Types.LT;
            Queen -> GHC.Types.LT;
            King -> GHC.Types.LT
          };
        Rook ->
          case b_a1GS of {
            __DEFAULT -> GHC.Types.GT;
            Rook -> GHC.Types.EQ;
            Queen -> GHC.Types.LT;
            King -> GHC.Types.LT
          };
        Queen ->
          case b_a1GS of {
            __DEFAULT -> GHC.Types.GT;
            Queen -> GHC.Types.EQ;
            King -> GHC.Types.LT
          };
        King ->
          case b_a1GS of {
            __DEFAULT -> GHC.Types.GT;
            King -> GHC.Types.EQ
          }
      }

-- RHS size: {terms: 64, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$c< :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [220 270] 270 210}]
TypeDefs.$fOrdPieceType_$c<
  = \ (a_a1GV :: PieceType) (b_a1GW :: PieceType) ->
      case a_a1GV of {
        Pawn ->
          case b_a1GW of {
            Pawn -> GHC.Types.False;
            Knight -> GHC.Types.True;
            Bishop -> GHC.Types.True;
            Rook -> GHC.Types.True;
            Queen -> GHC.Types.True;
            King -> GHC.Types.True
          };
        Knight ->
          case b_a1GW of {
            __DEFAULT -> GHC.Types.False;
            Bishop -> GHC.Types.True;
            Rook -> GHC.Types.True;
            Queen -> GHC.Types.True;
            King -> GHC.Types.True
          };
        Bishop ->
          case b_a1GW of {
            __DEFAULT -> GHC.Types.False;
            Rook -> GHC.Types.True;
            Queen -> GHC.Types.True;
            King -> GHC.Types.True
          };
        Rook ->
          case b_a1GW of {
            __DEFAULT -> GHC.Types.False;
            Queen -> GHC.Types.True;
            King -> GHC.Types.True
          };
        Queen ->
          case b_a1GW of {
            __DEFAULT -> GHC.Types.False;
            King -> GHC.Types.True
          };
        King -> case b_a1GW of { __DEFAULT -> GHC.Types.False }
      }

-- RHS size: {terms: 64, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$c<= :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [270 220] 270 210}]
TypeDefs.$fOrdPieceType_$c<=
  = \ (a_a1GZ :: PieceType) (b_a1H0 :: PieceType) ->
      case b_a1H0 of {
        Pawn ->
          case a_a1GZ of {
            Pawn -> GHC.Types.True;
            Knight -> GHC.Types.False;
            Bishop -> GHC.Types.False;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Knight ->
          case a_a1GZ of {
            __DEFAULT -> GHC.Types.True;
            Bishop -> GHC.Types.False;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Bishop ->
          case a_a1GZ of {
            __DEFAULT -> GHC.Types.True;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Rook ->
          case a_a1GZ of {
            __DEFAULT -> GHC.Types.True;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Queen ->
          case a_a1GZ of {
            __DEFAULT -> GHC.Types.True;
            King -> GHC.Types.False
          };
        King -> case a_a1GZ of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 64, types: 9, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$c>= :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [220 270] 270 210}]
TypeDefs.$fOrdPieceType_$c>=
  = \ (a_a1H3 :: PieceType) (b_a1H4 :: PieceType) ->
      case a_a1H3 of {
        Pawn ->
          case b_a1H4 of {
            Pawn -> GHC.Types.True;
            Knight -> GHC.Types.False;
            Bishop -> GHC.Types.False;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Knight ->
          case b_a1H4 of {
            __DEFAULT -> GHC.Types.True;
            Bishop -> GHC.Types.False;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Bishop ->
          case b_a1H4 of {
            __DEFAULT -> GHC.Types.True;
            Rook -> GHC.Types.False;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Rook ->
          case b_a1H4 of {
            __DEFAULT -> GHC.Types.True;
            Queen -> GHC.Types.False;
            King -> GHC.Types.False
          };
        Queen ->
          case b_a1H4 of {
            __DEFAULT -> GHC.Types.True;
            King -> GHC.Types.False
          };
        King -> case b_a1H4 of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 51, types: 8, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$cmax
  :: PieceType -> PieceType -> PieceType
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [200 170] 210 150}]
TypeDefs.$fOrdPieceType_$cmax
  = \ (x_a1VH :: PieceType) (y_a1VI :: PieceType) ->
      case y_a1VI of {
        Pawn -> x_a1VH;
        Knight ->
          case x_a1VH of {
            __DEFAULT -> TypeDefs.Knight;
            Bishop -> TypeDefs.Bishop;
            Rook -> TypeDefs.Rook;
            Queen -> TypeDefs.Queen;
            King -> TypeDefs.King
          };
        Bishop ->
          case x_a1VH of {
            __DEFAULT -> TypeDefs.Bishop;
            Rook -> TypeDefs.Rook;
            Queen -> TypeDefs.Queen;
            King -> TypeDefs.King
          };
        Rook ->
          case x_a1VH of {
            __DEFAULT -> TypeDefs.Rook;
            Queen -> TypeDefs.Queen;
            King -> TypeDefs.King
          };
        Queen ->
          case x_a1VH of {
            __DEFAULT -> TypeDefs.Queen;
            King -> TypeDefs.King
          };
        King -> case x_a1VH of { __DEFAULT -> TypeDefs.King }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$c> :: PieceType -> PieceType -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_a1H1 [Occ=Once] :: PieceType)
                 (b_a1H2 [Occ=Once] :: PieceType) ->
                 TypeDefs.$fOrdPieceType_$c< b_a1H2 a_a1H1}]
TypeDefs.$fOrdPieceType_$c>
  = \ (a_a1H1 :: PieceType) (b_a1H2 :: PieceType) ->
      TypeDefs.$fOrdPieceType_$c< b_a1H2 a_a1H1

-- RHS size: {terms: 51, types: 8, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType_$cmin
  :: PieceType -> PieceType -> PieceType
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [200 170] 210 110}]
TypeDefs.$fOrdPieceType_$cmin
  = \ (x_a1VO :: PieceType) (y_a1VP :: PieceType) ->
      case y_a1VP of {
        Pawn -> case x_a1VO of { __DEFAULT -> TypeDefs.Pawn };
        Knight ->
          case x_a1VO of wild1_X67 {
            __DEFAULT -> wild1_X67;
            Bishop -> TypeDefs.Knight;
            Rook -> TypeDefs.Knight;
            Queen -> TypeDefs.Knight;
            King -> TypeDefs.Knight
          };
        Bishop ->
          case x_a1VO of wild1_X67 {
            __DEFAULT -> wild1_X67;
            Rook -> TypeDefs.Bishop;
            Queen -> TypeDefs.Bishop;
            King -> TypeDefs.Bishop
          };
        Rook ->
          case x_a1VO of wild1_X67 {
            __DEFAULT -> wild1_X67;
            Queen -> TypeDefs.Rook;
            King -> TypeDefs.Rook
          };
        Queen ->
          case x_a1VO of wild1_X67 {
            __DEFAULT -> wild1_X67;
            King -> TypeDefs.Queen
          };
        King -> x_a1VO
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$fOrdPieceType [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord PieceType
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: PieceType
                         TypeDefs.$fEqPieceType
                         TypeDefs.$fOrdPieceType_$ccompare
                         TypeDefs.$fOrdPieceType_$c<
                         TypeDefs.$fOrdPieceType_$c<=
                         TypeDefs.$fOrdPieceType_$c>
                         TypeDefs.$fOrdPieceType_$c>=
                         TypeDefs.$fOrdPieceType_$cmax
                         TypeDefs.$fOrdPieceType_$cmin]
TypeDefs.$fOrdPieceType
  = GHC.Classes.C:Ord
      @ PieceType
      TypeDefs.$fEqPieceType
      TypeDefs.$fOrdPieceType_$ccompare
      TypeDefs.$fOrdPieceType_$c<
      TypeDefs.$fOrdPieceType_$c<=
      TypeDefs.$fOrdPieceType_$c>
      TypeDefs.$fOrdPieceType_$c>=
      TypeDefs.$fOrdPieceType_$cmax
      TypeDefs.$fOrdPieceType_$cmin

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$trModule3 = GHC.Types.TrNameS TypeDefs.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$trModule2 = "TypeDefs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$trModule1 = GHC.Types.TrNameS TypeDefs.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
TypeDefs.$trModule
  = GHC.Types.Module TypeDefs.$trModule3 TypeDefs.$trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcPieceType2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
TypeDefs.$tcPieceType2 = "PieceType"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcPieceType1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tcPieceType1 = GHC.Types.TrNameS TypeDefs.$tcPieceType2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcPieceType :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tcPieceType
  = GHC.Types.TyCon
      12052403370450297352##
      17614113851961823842##
      TypeDefs.$trModule
      TypeDefs.$tcPieceType1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$tc'Bishop1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
TypeDefs.$tc'Bishop1
  = GHC.Types.KindRepTyConApp
      TypeDefs.$tcPieceType (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Pawn2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Pawn2 = "'Pawn"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Pawn1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Pawn1 = GHC.Types.TrNameS TypeDefs.$tc'Pawn2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Pawn :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Pawn
  = GHC.Types.TyCon
      16222795137731008594##
      5580323583231616462##
      TypeDefs.$trModule
      TypeDefs.$tc'Pawn1
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Knight2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Knight2 = "'Knight"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Knight1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Knight1 = GHC.Types.TrNameS TypeDefs.$tc'Knight2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Knight :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Knight
  = GHC.Types.TyCon
      6777437183035708425##
      4130605722131802415##
      TypeDefs.$trModule
      TypeDefs.$tc'Knight1
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Bishop3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Bishop3 = "'Bishop"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Bishop2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Bishop2 = GHC.Types.TrNameS TypeDefs.$tc'Bishop3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Bishop :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Bishop
  = GHC.Types.TyCon
      883452391535644757##
      9291785945015143006##
      TypeDefs.$trModule
      TypeDefs.$tc'Bishop2
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Rook2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Rook2 = "'Rook"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Rook1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Rook1 = GHC.Types.TrNameS TypeDefs.$tc'Rook2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Rook :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Rook
  = GHC.Types.TyCon
      13272072996421848635##
      13299812262762856##
      TypeDefs.$trModule
      TypeDefs.$tc'Rook1
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Queen2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Queen2 = "'Queen"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Queen1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Queen1 = GHC.Types.TrNameS TypeDefs.$tc'Queen2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Queen :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Queen
  = GHC.Types.TyCon
      11104211418563846396##
      15252216611864730105##
      TypeDefs.$trModule
      TypeDefs.$tc'Queen1
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'King2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'King2 = "'King"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'King1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'King1 = GHC.Types.TrNameS TypeDefs.$tc'King2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'King :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'King
  = GHC.Types.TyCon
      2717763686432421910##
      10523544170016566433##
      TypeDefs.$trModule
      TypeDefs.$tc'King1
      0#
      TypeDefs.$tc'Bishop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcColour2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tcColour2 = "Colour"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcColour1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tcColour1 = GHC.Types.TrNameS TypeDefs.$tcColour2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcColour :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tcColour
  = GHC.Types.TyCon
      13661179406839682643##
      13880260112953057785##
      TypeDefs.$trModule
      TypeDefs.$tcColour1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$tc'Black1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
TypeDefs.$tc'Black1
  = GHC.Types.KindRepTyConApp
      TypeDefs.$tcColour (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Black3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Black3 = "'Black"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Black2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Black2 = GHC.Types.TrNameS TypeDefs.$tc'Black3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Black :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Black
  = GHC.Types.TyCon
      8722406773448566178##
      17550809369653512428##
      TypeDefs.$trModule
      TypeDefs.$tc'Black2
      0#
      TypeDefs.$tc'Black1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'White2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'White2 = "'White"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'White1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'White1 = GHC.Types.TrNameS TypeDefs.$tc'White2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'White :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'White
  = GHC.Types.TyCon
      17605152820464830986##
      13931168853934447381##
      TypeDefs.$trModule
      TypeDefs.$tc'White1
      0#
      TypeDefs.$tc'Black1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcGamePoint2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
TypeDefs.$tcGamePoint2 = "GamePoint"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcGamePoint1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tcGamePoint1 = GHC.Types.TrNameS TypeDefs.$tcGamePoint2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tcGamePoint :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tcGamePoint
  = GHC.Types.TyCon
      13579398812822448156##
      18355393437233585475##
      TypeDefs.$trModule
      TypeDefs.$tcGamePoint1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
TypeDefs.$tc'End1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
TypeDefs.$tc'End1
  = GHC.Types.KindRepTyConApp
      TypeDefs.$tcGamePoint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Opening2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Opening2 = "'Opening"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Opening1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Opening1 = GHC.Types.TrNameS TypeDefs.$tc'Opening2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Opening :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Opening
  = GHC.Types.TyCon
      14350834356579339464##
      12858452260500574625##
      TypeDefs.$trModule
      TypeDefs.$tc'Opening1
      0#
      TypeDefs.$tc'End1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Middle2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
TypeDefs.$tc'Middle2 = "'Middle"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Middle1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'Middle1 = GHC.Types.TrNameS TypeDefs.$tc'Middle2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'Middle :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'Middle
  = GHC.Types.TyCon
      17977669575586268375##
      6261926588927164149##
      TypeDefs.$trModule
      TypeDefs.$tc'Middle1
      0#
      TypeDefs.$tc'End1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'End3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
TypeDefs.$tc'End3 = "'End"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'End2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
TypeDefs.$tc'End2 = GHC.Types.TrNameS TypeDefs.$tc'End3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
TypeDefs.$tc'End :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
TypeDefs.$tc'End
  = GHC.Types.TyCon
      17641025022776165602##
      11512221111148995764##
      TypeDefs.$trModule
      TypeDefs.$tc'End2
      0#
      TypeDefs.$tc'End1



[ 2 of 14] Compiling Init             ( Init.hs, Init.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 329, types: 453, coercions: 0, joins: 0/1}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces8 = GHC.Types.I# 7#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces6 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces6 = GHC.Types.I# 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces14 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces14 = (Init.addAllPieces8, Init.addAllPieces6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces13 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces13
  = (TypeDefs.Rook, TypeDefs.White, Init.addAllPieces14,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces12 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces12 = (Init.addAllPieces6, Init.addAllPieces6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces11 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces11
  = (TypeDefs.Rook, TypeDefs.Black, Init.addAllPieces12,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces10 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces10 = (Init.addAllPieces8, Init.addAllPieces8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces9 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces9
  = (TypeDefs.Rook, TypeDefs.White, Init.addAllPieces10,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces7 = (Init.addAllPieces6, Init.addAllPieces8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces5
  = (TypeDefs.Rook, TypeDefs.Black, Init.addAllPieces7,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces4 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces4
  = GHC.Types.: @ Piece Init.addAllPieces5 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces3
  = GHC.Types.: @ Piece Init.addAllPieces9 Init.addAllPieces4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces2 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces2
  = GHC.Types.: @ Piece Init.addAllPieces11 Init.addAllPieces3

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addRooks :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addRooks
  = GHC.Types.: @ Piece Init.addAllPieces13 Init.addAllPieces2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces26 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces26 = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces28 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces28 = (Init.addAllPieces8, Init.addAllPieces26)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces27 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces27
  = (TypeDefs.Knight, TypeDefs.White, Init.addAllPieces28,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces25 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces25 = (Init.addAllPieces6, Init.addAllPieces26)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces24 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces24
  = (TypeDefs.Knight, TypeDefs.Black, Init.addAllPieces25,
     Init.addAllPieces6)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces21 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces21 = GHC.Types.I# 6#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces23 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces23 = (Init.addAllPieces8, Init.addAllPieces21)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces22 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces22
  = (TypeDefs.Knight, TypeDefs.White, Init.addAllPieces23,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces20 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces20 = (Init.addAllPieces6, Init.addAllPieces21)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces19 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces19
  = (TypeDefs.Knight, TypeDefs.Black, Init.addAllPieces20,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces18 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces18
  = GHC.Types.: @ Piece Init.addAllPieces19 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces17 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces17
  = GHC.Types.: @ Piece Init.addAllPieces22 Init.addAllPieces18

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces16 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces16
  = GHC.Types.: @ Piece Init.addAllPieces24 Init.addAllPieces17

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addKnights :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addKnights
  = GHC.Types.: @ Piece Init.addAllPieces27 Init.addAllPieces16

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces40 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces40 = GHC.Types.I# 2#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces42 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces42 = (Init.addAllPieces8, Init.addAllPieces40)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces41 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces41
  = (TypeDefs.Bishop, TypeDefs.White, Init.addAllPieces42,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces39 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces39 = (Init.addAllPieces6, Init.addAllPieces40)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces38 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces38
  = (TypeDefs.Bishop, TypeDefs.Black, Init.addAllPieces39,
     Init.addAllPieces6)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces35 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces35 = GHC.Types.I# 5#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces37 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces37 = (Init.addAllPieces8, Init.addAllPieces35)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces36 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces36
  = (TypeDefs.Bishop, TypeDefs.White, Init.addAllPieces37,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces34 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces34 = (Init.addAllPieces6, Init.addAllPieces35)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces33 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces33
  = (TypeDefs.Bishop, TypeDefs.Black, Init.addAllPieces34,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces32 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces32
  = GHC.Types.: @ Piece Init.addAllPieces33 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces31 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces31
  = GHC.Types.: @ Piece Init.addAllPieces36 Init.addAllPieces32

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Init.addAllPieces30 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces30
  = GHC.Types.: @ Piece Init.addAllPieces38 Init.addAllPieces31

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addBishops :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addBishops
  = GHC.Types.: @ Piece Init.addAllPieces41 Init.addAllPieces30

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addAllPieces47 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addAllPieces47 = GHC.Types.I# 3#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces49 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces49 = (Init.addAllPieces8, Init.addAllPieces47)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces48 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces48
  = (TypeDefs.Queen, TypeDefs.White, Init.addAllPieces49,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces46 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces46 = (Init.addAllPieces6, Init.addAllPieces47)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addAllPieces45 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addAllPieces45
  = (TypeDefs.Queen, TypeDefs.Black, Init.addAllPieces46,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addAllPieces44 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addAllPieces44
  = GHC.Types.: @ Piece Init.addAllPieces45 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addQueens :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addQueens
  = GHC.Types.: @ Piece Init.addAllPieces48 Init.addAllPieces44

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.addKings4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.addKings4 = GHC.Types.I# 4#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addKings6 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addKings6 = (Init.addAllPieces8, Init.addKings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addKings5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addKings5
  = (TypeDefs.King, TypeDefs.White, Init.addKings6,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addKings3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addKings3 = (Init.addAllPieces6, Init.addKings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Init.addKings2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Init.addKings2
  = (TypeDefs.King, TypeDefs.Black, Init.addKings3,
     Init.addAllPieces6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Init.addKings1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.addKings1
  = GHC.Types.: @ Piece Init.addKings2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addKings :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addKings = GHC.Types.: @ Piece Init.addKings5 Init.addKings1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Init.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Init.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.$trModule3 = GHC.Types.TrNameS Init.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Init.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Init.$trModule2 = "Init"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Init.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Init.$trModule1 = GHC.Types.TrNameS Init.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Init.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Init.$trModule = GHC.Types.Module Init.$trModule3 Init.$trModule1

Rec {
-- RHS size: {terms: 34, types: 36, coercions: 0, joins: 0/1}
Init.$wgo [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
  :: GHC.Prim.Int# -> (# Piece, [Piece] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []]
Init.$wgo
  = \ (w_s3zF :: GHC.Prim.Int#) ->
      let {
        ds_d3wP :: Int
        [LclId, Unf=OtherCon []]
        ds_d3wP = GHC.Types.I# w_s3zF } in
      (# (TypeDefs.Pawn, TypeDefs.White, (Init.addAllPieces21, ds_d3wP),
          Init.addAllPieces6),
         GHC.Types.:
           @ Piece
           (TypeDefs.Pawn, TypeDefs.Black, (Init.addAllPieces26, ds_d3wP),
            Init.addAllPieces6)
           (case w_s3zF of wild_X2Y {
              __DEFAULT ->
                case Init.$wgo (GHC.Prim.+# wild_X2Y 1#) of
                { (# ww1_s3zK, ww2_s3zL #) ->
                GHC.Types.: @ Piece ww1_s3zK ww2_s3zL
                };
              7# -> GHC.Types.[] @ Piece
            }) #)
end Rec }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
addPawns :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 30}]
addPawns
  = case Init.$wgo 0# of { (# ww1_s3zK, ww2_s3zL #) ->
    GHC.Types.: @ Piece ww1_s3zK ww2_s3zL
    }

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Init.addAllPieces43 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Init.addAllPieces43
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addKings
      Init.addAllPieces48
      Init.addAllPieces44

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Init.addAllPieces29 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Init.addAllPieces29
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Init.addAllPieces43
      Init.addAllPieces41
      Init.addAllPieces30

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Init.addAllPieces15 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Init.addAllPieces15
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Init.addAllPieces29
      Init.addAllPieces27
      Init.addAllPieces16

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Init.addAllPieces1 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Init.addAllPieces1
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Init.addAllPieces15
      Init.addAllPieces13
      Init.addAllPieces2

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
addAllPieces :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
addAllPieces
  = ++
      @ (PieceType, Colour, Pos, Movecount) addPawns Init.addAllPieces1



[ 3 of 14] Compiling Util             ( Util.hs, Util.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 10,325, types: 6,809, coercions: 0, joins: 40/203}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.allPiecesMoved1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.allPiecesMoved1 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.findKing2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.findKing2 = GHC.Types.I# -1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.legalRookMoves1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.legalRookMoves1 = GHC.Types.I# 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
z_rcj3 :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
z_rcj3 = GHC.Types.I# -2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath13 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.clearCastlePath13 = GHC.Types.I# 2#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
z1_rcj4 :: [Int]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
z1_rcj4
  = GHC.Types.: @ Int Util.clearCastlePath13 (GHC.Types.[] @ Int)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
z2_rcj5 :: [Int]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
z2_rcj5 = GHC.Types.: @ Int Util.legalRookMoves1 z1_rcj4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
z3_rcj6 :: [Int]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
z3_rcj6 = GHC.Types.: @ Int Util.findKing2 z2_rcj5

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.executeCastle4 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.executeCastle4 = (Util.allPiecesMoved1, Util.allPiecesMoved1)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath10 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.clearCastlePath10 = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.executeCastle3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.executeCastle3
  = (Util.clearCastlePath10, Util.allPiecesMoved1)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath12 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.clearCastlePath12 = GHC.Types.I# 3#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.executeCastle2 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.executeCastle2
  = (Util.allPiecesMoved1, Util.clearCastlePath10)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.executeCastle1 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.executeCastle1
  = (Util.clearCastlePath10, Util.clearCastlePath10)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.clearCastlePath11 :: [Int]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.clearCastlePath11
  = GHC.Types.: @ Int Util.clearCastlePath12 (GHC.Types.[] @ Int)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.clearCastlePath7 = GHC.Types.I# 5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath6 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.clearCastlePath6 = GHC.Types.I# 6#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.clearCastlePath5 :: [Int]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.clearCastlePath5
  = GHC.Types.: @ Int Util.clearCastlePath6 (GHC.Types.[] @ Int)

-- RHS size: {terms: 43, types: 14, coercions: 0, joins: 0/2}
Util.$wisOnBoard [InlPrag=NOUSERINLINE[2]]
  :: GHC.Prim.Int# -> Int -> GHC.Prim.Int# -> Int -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(U)><L,U><L,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 20 0 20] 87 30}]
Util.$wisOnBoard
  = \ (ww_s8mp :: GHC.Prim.Int#)
      (ww1_s8mr :: Int)
      (ww2_s8mA :: GHC.Prim.Int#)
      (ww3_s8mC :: Int) ->
      let {
        x_a5nX :: GHC.Prim.Int#
        [LclId]
        x_a5nX = GHC.Prim.+# ww_s8mp ww2_s8mA } in
      case GHC.Prim.>=# x_a5nX 0# of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case GHC.Prim.<=# x_a5nX 7# of {
            __DEFAULT -> GHC.Types.False;
            1# ->
              case ww1_s8mr of { GHC.Types.I# x1_X5qe ->
              case ww3_s8mC of { GHC.Types.I# y_X5qm ->
              let {
                x2_X5uf :: GHC.Prim.Int#
                [LclId]
                x2_X5uf = GHC.Prim.+# x1_X5qe y_X5qm } in
              case GHC.Prim.>=# x2_X5uf 0# of {
                __DEFAULT -> GHC.Types.False;
                1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.<=# x2_X5uf 7#)
              }
              }
              }
          }
      }

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/0}
isOnBoard [InlPrag=NOUSERINLINE[2]] :: Piece -> Move -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLS(SL)L),1*U(A,A,1*U(1*U(U),1*U(U)),A)><S(SL),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8md [Occ=Once!] :: Piece)
                 (w1_s8me [Occ=Once!] :: Move) ->
                 case w_s8md of
                 { (_ [Occ=Dead], _ [Occ=Dead], ww3_s8mj [Occ=Once!],
                    _ [Occ=Dead]) ->
                 case ww3_s8mj of { (ww6_s8mm [Occ=Once!], ww7_s8mr [Occ=Once]) ->
                 case ww6_s8mm of { GHC.Types.I# ww9_s8mp [Occ=Once] ->
                 case w1_s8me of { (ww11_s8mx [Occ=Once!], ww12_s8mC [Occ=Once]) ->
                 case ww11_s8mx of { GHC.Types.I# ww14_s8mA [Occ=Once] ->
                 Util.$wisOnBoard ww9_s8mp ww7_s8mr ww14_s8mA ww12_s8mC
                 }
                 }
                 }
                 }
                 }}]
isOnBoard
  = \ (w_s8md :: Piece) (w1_s8me :: Move) ->
      case w_s8md of { (ww1_s8mh, ww2_s8mi, ww3_s8mj, ww4_s8mt) ->
      case ww3_s8mj of { (ww6_s8mm, ww7_s8mr) ->
      case ww6_s8mm of { GHC.Types.I# ww9_s8mp ->
      case w1_s8me of { (ww11_s8mx, ww12_s8mC) ->
      case ww11_s8mx of { GHC.Types.I# ww14_s8mA ->
      Util.$wisOnBoard ww9_s8mp ww7_s8mr ww14_s8mA ww12_s8mC
      }
      }
      }
      }
      }

Rec {
-- RHS size: {terms: 77, types: 39, coercions: 0, joins: 1/2}
Util.getGamePoint_go [Occ=LoopBreaker] :: [Piece] -> Int -> Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Util.getGamePoint_go
  = \ (ds_a24u :: [Piece]) ->
      case ds_a24u of {
        [] -> id @ Int;
        : y_a24x ys_a24y ->
          case y_a24x of { (ww1_s8mJ, ww2_s8mK, ww3_s8mL, ww4_s8mV) ->
          case ww3_s8mL of { (ww6_s8mO, ww7_s8mT) ->
          case ww6_s8mO of { GHC.Types.I# ww9_s8mR ->
          let {
            w_s8mG :: Int -> Int
            [LclId]
            w_s8mG = Util.getGamePoint_go ys_a24y } in
          join {
            $j_s5Tg [Dmd=<L,1*U>] :: Int -> Int
            [LclId[JoinId(0)]]
            $j_s5Tg
              = case ww1_s8mJ of {
                  __DEFAULT -> w_s8mG;
                  Knight ->
                    \ (a_a5og :: Int) ->
                      case a_a5og of { GHC.Types.I# ipv_a5oi ->
                      w_s8mG (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                      };
                  Bishop ->
                    \ (a_a5og :: Int) ->
                      case a_a5og of { GHC.Types.I# ipv_a5oi ->
                      w_s8mG (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                      };
                  Rook ->
                    \ (a_a5og :: Int) ->
                      case a_a5og of { GHC.Types.I# ipv_a5oi ->
                      w_s8mG (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                      };
                  Queen ->
                    \ (a_a5og :: Int) ->
                      case a_a5og of { GHC.Types.I# ipv_a5oi ->
                      w_s8mG (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                      }
                } } in
          case ww9_s8mR of {
            __DEFAULT -> jump $j_s5Tg;
            -1# ->
              case ww7_s8mT of { GHC.Types.I# x_X5nC ->
              case x_X5nC of {
                __DEFAULT -> jump $j_s5Tg;
                -1# -> w_s8mG
              }
              }
          }
          }
          }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
lowMaterial :: AllPieces -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 42 0}]
lowMaterial
  = \ (ps_a4bi :: AllPieces) ->
      case Util.getGamePoint_go ps_a4bi Util.allPiecesMoved1 of
      { GHC.Types.I# x_a5ox ->
      GHC.Prim.tagToEnum# @ Bool (GHC.Prim.<=# x_a5ox 6#)
      }

Rec {
-- RHS size: {terms: 76, types: 34, coercions: 0, joins: 0/1}
Util.allPiecesMoved_go [Occ=LoopBreaker] :: [Piece] -> Int -> Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Util.allPiecesMoved_go
  = \ (ds_a24u :: [Piece]) ->
      case ds_a24u of {
        [] -> id @ Int;
        : y_a24x ys_a24y ->
          case y_a24x of { (ww1_s8n4, ww2_s8n5, ww3_s8n6, ww4_s8n7) ->
          case ww4_s8n7 of { GHC.Types.I# ww6_s8na ->
          let {
            w_s8n1 :: Int -> Int
            [LclId]
            w_s8n1 = Util.allPiecesMoved_go ys_a24y } in
          case GHC.Prim.># ww6_s8na 0# of {
            __DEFAULT -> w_s8n1;
            1# ->
              case ww1_s8n4 of {
                Pawn -> w_s8n1;
                Knight ->
                  \ (a_a5og :: Int) ->
                    case a_a5og of { GHC.Types.I# ipv_a5oi ->
                    w_s8n1 (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                    };
                Bishop ->
                  \ (a_a5og :: Int) ->
                    case a_a5og of { GHC.Types.I# ipv_a5oi ->
                    w_s8n1 (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                    };
                Rook ->
                  \ (a_a5og :: Int) ->
                    case a_a5og of { GHC.Types.I# ipv_a5oi ->
                    w_s8n1 (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                    };
                Queen ->
                  \ (a_a5og :: Int) ->
                    case a_a5og of { GHC.Types.I# ipv_a5oi ->
                    w_s8n1 (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                    };
                King ->
                  \ (a_a5og :: Int) ->
                    case a_a5og of { GHC.Types.I# ipv_a5oi ->
                    w_s8n1 (GHC.Types.I# (GHC.Prim.+# ipv_a5oi 1#))
                    }
              }
          }
          }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
allPiecesMoved :: AllPieces -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 42 0}]
allPiecesMoved
  = \ (ps_a40q :: AllPieces) ->
      case Util.allPiecesMoved_go ps_a40q Util.allPiecesMoved1 of
      { GHC.Types.I# x_a5nX ->
      GHC.Prim.tagToEnum# @ Bool (GHC.Prim.>=# x_a5nX 16#)
      }

-- RHS size: {terms: 26, types: 7, coercions: 0, joins: 0/0}
getGamePoint :: AllPieces -> GamePoint
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 122 30}]
getGamePoint
  = \ (ps_a3ZU :: AllPieces) ->
      case Util.getGamePoint_go ps_a3ZU Util.allPiecesMoved1 of
      { GHC.Types.I# x_a5ox ->
      case GHC.Prim.<=# x_a5ox 6# of {
        __DEFAULT ->
          case Util.allPiecesMoved_go ps_a3ZU Util.allPiecesMoved1 of
          { GHC.Types.I# x1_a5nX ->
          case GHC.Prim.>=# x1_a5nX 16# of {
            __DEFAULT -> TypeDefs.Opening;
            1# -> TypeDefs.Middle
          }
          };
        1# -> TypeDefs.End
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rcj7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rcj7
  = "Util.hs:(166,1)-(172,62)|function isStraightMovePathEmpty"#

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl1_rcj8 :: Bool
[GblId, Str=b]
lvl1_rcj8
  = Control.Exception.Base.patError
      @ 'GHC.Types.LiftedRep @ Bool lvl_rcj7

-- RHS size: {terms: 25, types: 5, coercions: 0, joins: 0/0}
closerToZero :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a4cS [Occ=Once!] :: Int) ->
                 case a_a4cS of wild_a5k8 [Occ=Once] { GHC.Types.I# x_a5k9 ->
                 case GHC.Prim.<# x_a5k9 0# of {
                   __DEFAULT ->
                     case GHC.Prim.># x_a5k9 0# of {
                       __DEFAULT -> wild_a5k8;
                       1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                     };
                   1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                 }
                 }}]
closerToZero
  = \ (a_a4cS :: Int) ->
      case a_a4cS of wild_a5k8 { GHC.Types.I# x_a5k9 ->
      case GHC.Prim.<# x_a5k9 0# of {
        __DEFAULT ->
          case GHC.Prim.># x_a5k9 0# of {
            __DEFAULT -> wild_a5k8;
            1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
          };
        1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
      }
      }

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
decreaseDiagonalMove :: Move -> Move
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4UY [Occ=Once!] :: (Int, Int)) ->
                 case ds_d4UY of { (row_a4cU [Occ=Once], col_a4cV [Occ=Once]) ->
                 (closerToZero row_a4cU, closerToZero col_a4cV)
                 }}]
decreaseDiagonalMove
  = \ (ds_d4UY :: (Int, Int)) ->
      case ds_d4UY of { (row_a4cU, col_a4cV) ->
      (closerToZero row_a4cU, closerToZero col_a4cV)
      }

-- RHS size: {terms: 25, types: 5, coercions: 0, joins: 0/0}
furtherFromZero :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a4cT [Occ=Once!] :: Int) ->
                 case a_a4cT of wild_a5k8 [Occ=Once] { GHC.Types.I# x_a5k9 ->
                 case GHC.Prim.<# x_a5k9 0# of {
                   __DEFAULT ->
                     case GHC.Prim.># x_a5k9 0# of {
                       __DEFAULT -> wild_a5k8;
                       1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                     };
                   1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                 }
                 }}]
furtherFromZero
  = \ (a_a4cT :: Int) ->
      case a_a4cT of wild_a5k8 { GHC.Types.I# x_a5k9 ->
      case GHC.Prim.<# x_a5k9 0# of {
        __DEFAULT ->
          case GHC.Prim.># x_a5k9 0# of {
            __DEFAULT -> wild_a5k8;
            1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
          };
        1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
      }
      }

-- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
isIntOnBoard :: Int -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a4hr [Occ=Once!] :: Int) ->
                 case a_a4hr of { GHC.Types.I# x_a5k9 ->
                 case GHC.Prim.<# x_a5k9 0# of {
                   __DEFAULT ->
                     case GHC.Prim.># x_a5k9 7# of {
                       __DEFAULT -> GHC.Types.True;
                       1# -> GHC.Types.False
                     };
                   1# -> GHC.Types.False
                 }
                 }}]
isIntOnBoard
  = \ (a_a4hr :: Int) ->
      case a_a4hr of { GHC.Types.I# x_a5k9 ->
      case GHC.Prim.<# x_a5k9 0# of {
        __DEFAULT ->
          case GHC.Prim.># x_a5k9 7# of {
            __DEFAULT -> GHC.Types.True;
            1# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }

-- RHS size: {terms: 574, types: 129, coercions: 0, joins: 2/15}
Util.$wgetSurroundingPos [InlPrag=NOUSERINLINE[2]]
  :: GHC.Prim.Int# -> Int -> [Pos]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><L,U(U)>, Unf=OtherCon []]
Util.$wgetSurroundingPos
  = \ (ww_s8nr :: GHC.Prim.Int#) (ww1_s8nt :: Int) ->
      let {
        x0_a3xv :: GHC.Prim.Int#
        [LclId]
        x0_a3xv = GHC.Prim.-# ww_s8nr 1# } in
      let {
        y_a3xw :: GHC.Prim.Int#
        [LclId]
        y_a3xw = GHC.Prim.+# ww_s8nr 1# } in
      case GHC.Prim.># x0_a3xv y_a3xw of {
        __DEFAULT ->
          letrec {
            go_a3xy [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Pos]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_a3xy
              = \ (x_a3xz :: GHC.Prim.Int#) ->
                  case ww1_s8nt of { GHC.Types.I# x1_X5s6 ->
                  let {
                    x2_X3D1 :: GHC.Prim.Int#
                    [LclId]
                    x2_X3D1 = GHC.Prim.-# x1_X5s6 1# } in
                  let {
                    y1_X3D4 :: GHC.Prim.Int#
                    [LclId]
                    y1_X3D4 = GHC.Prim.+# x1_X5s6 1# } in
                  let {
                    n_X3CY :: [Pos]
                    [LclId]
                    n_X3CY
                      = case GHC.Prim.==# x_a3xz y_a3xw of {
                          __DEFAULT -> go_a3xy (GHC.Prim.+# x_a3xz 1#);
                          1# -> GHC.Types.[] @ Pos
                        } } in
                  case GHC.Prim.># x2_X3D1 y1_X3D4 of {
                    __DEFAULT ->
                      case GHC.Prim.<# x_a3xz 0# of {
                        __DEFAULT ->
                          case GHC.Prim.># x_a3xz 7# of {
                            __DEFAULT ->
                              let {
                                ds_d4Sc :: Int
                                [LclId, Unf=OtherCon []]
                                ds_d4Sc = GHC.Types.I# x_a3xz } in
                              let {
                                lvl4_s5KT :: Bool
                                [LclId]
                                lvl4_s5KT
                                  = GHC.Prim.tagToEnum# @ Bool (GHC.Prim.==# x_a3xz ww_s8nr) } in
                              case GHC.Prim.<# x2_X3D1 0# of {
                                __DEFAULT ->
                                  case GHC.Prim.># x2_X3D1 7# of {
                                    __DEFAULT ->
                                      case lvl4_s5KT of {
                                        False ->
                                          GHC.Types.:
                                            @ Pos
                                            (ds_d4Sc, GHC.Types.I# x2_X3D1)
                                            (case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                               __DEFAULT ->
                                                 letrec {
                                                   go1_X3Db [Occ=LoopBreaker]
                                                     :: GHC.Prim.Int# -> [Pos]
                                                   [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                                   go1_X3Db
                                                     = \ (x3_X3He :: GHC.Prim.Int#) ->
                                                         case GHC.Prim.<# x3_X3He 0# of {
                                                           __DEFAULT ->
                                                             case GHC.Prim.># x3_X3He 7# of {
                                                               __DEFAULT ->
                                                                 GHC.Types.:
                                                                   @ Pos
                                                                   (ds_d4Sc, GHC.Types.I# x3_X3He)
                                                                   (case GHC.Prim.==#
                                                                           x3_X3He y1_X3D4
                                                                    of {
                                                                      __DEFAULT ->
                                                                        go1_X3Db
                                                                          (GHC.Prim.+# x3_X3He 1#);
                                                                      1# -> n_X3CY
                                                                    });
                                                               1# ->
                                                                 case GHC.Prim.==# x3_X3He y1_X3D4
                                                                 of {
                                                                   __DEFAULT ->
                                                                     go1_X3Db
                                                                       (GHC.Prim.+# x3_X3He 1#);
                                                                   1# -> n_X3CY
                                                                 }
                                                             };
                                                           1# ->
                                                             case GHC.Prim.==# x3_X3He y1_X3D4 of {
                                                               __DEFAULT ->
                                                                 go1_X3Db (GHC.Prim.+# x3_X3He 1#);
                                                               1# -> n_X3CY
                                                             }
                                                         }; } in
                                                 go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                               1# -> n_X3CY
                                             });
                                        True ->
                                          case GHC.Prim.==# x2_X3D1 x1_X5s6 of {
                                            __DEFAULT ->
                                              GHC.Types.:
                                                @ Pos
                                                (ds_d4Sc, GHC.Types.I# x2_X3D1)
                                                (case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                                   __DEFAULT ->
                                                     letrec {
                                                       go1_X3Db [Occ=LoopBreaker]
                                                         :: GHC.Prim.Int# -> [Pos]
                                                       [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                                       go1_X3Db
                                                         = \ (x3_X3Hh :: GHC.Prim.Int#) ->
                                                             case GHC.Prim.<# x3_X3Hh 0# of {
                                                               __DEFAULT ->
                                                                 case GHC.Prim.># x3_X3Hh 7# of {
                                                                   __DEFAULT ->
                                                                     case GHC.Prim.==#
                                                                            x3_X3Hh x1_X5s6
                                                                     of {
                                                                       __DEFAULT ->
                                                                         GHC.Types.:
                                                                           @ Pos
                                                                           (ds_d4Sc,
                                                                            GHC.Types.I# x3_X3Hh)
                                                                           (case GHC.Prim.==#
                                                                                   x3_X3Hh y1_X3D4
                                                                            of {
                                                                              __DEFAULT ->
                                                                                go1_X3Db
                                                                                  (GHC.Prim.+#
                                                                                     x3_X3Hh 1#);
                                                                              1# -> n_X3CY
                                                                            });
                                                                       1# ->
                                                                         case GHC.Prim.==#
                                                                                x3_X3Hh y1_X3D4
                                                                         of {
                                                                           __DEFAULT ->
                                                                             go1_X3Db
                                                                               (GHC.Prim.+#
                                                                                  x3_X3Hh 1#);
                                                                           1# -> n_X3CY
                                                                         }
                                                                     };
                                                                   1# ->
                                                                     case GHC.Prim.==#
                                                                            x3_X3Hh y1_X3D4
                                                                     of {
                                                                       __DEFAULT ->
                                                                         go1_X3Db
                                                                           (GHC.Prim.+# x3_X3Hh 1#);
                                                                       1# -> n_X3CY
                                                                     }
                                                                 };
                                                               1# ->
                                                                 case GHC.Prim.==# x3_X3Hh y1_X3D4
                                                                 of {
                                                                   __DEFAULT ->
                                                                     go1_X3Db
                                                                       (GHC.Prim.+# x3_X3Hh 1#);
                                                                   1# -> n_X3CY
                                                                 }
                                                             }; } in
                                                     go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                                   1# -> n_X3CY
                                                 });
                                            1# ->
                                              case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                                __DEFAULT ->
                                                  letrec {
                                                    go1_X3Db [Occ=LoopBreaker]
                                                      :: GHC.Prim.Int# -> [Pos]
                                                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                                    go1_X3Db
                                                      = \ (x3_X3Hh :: GHC.Prim.Int#) ->
                                                          case GHC.Prim.<# x3_X3Hh 0# of {
                                                            __DEFAULT ->
                                                              case GHC.Prim.># x3_X3Hh 7# of {
                                                                __DEFAULT ->
                                                                  case GHC.Prim.==# x3_X3Hh x1_X5s6
                                                                  of {
                                                                    __DEFAULT ->
                                                                      GHC.Types.:
                                                                        @ Pos
                                                                        (ds_d4Sc,
                                                                         GHC.Types.I# x3_X3Hh)
                                                                        (case GHC.Prim.==#
                                                                                x3_X3Hh y1_X3D4
                                                                         of {
                                                                           __DEFAULT ->
                                                                             go1_X3Db
                                                                               (GHC.Prim.+#
                                                                                  x3_X3Hh 1#);
                                                                           1# -> n_X3CY
                                                                         });
                                                                    1# ->
                                                                      case GHC.Prim.==#
                                                                             x3_X3Hh y1_X3D4
                                                                      of {
                                                                        __DEFAULT ->
                                                                          go1_X3Db
                                                                            (GHC.Prim.+#
                                                                               x3_X3Hh 1#);
                                                                        1# -> n_X3CY
                                                                      }
                                                                  };
                                                                1# ->
                                                                  case GHC.Prim.==# x3_X3Hh y1_X3D4
                                                                  of {
                                                                    __DEFAULT ->
                                                                      go1_X3Db
                                                                        (GHC.Prim.+# x3_X3Hh 1#);
                                                                    1# -> n_X3CY
                                                                  }
                                                              };
                                                            1# ->
                                                              case GHC.Prim.==# x3_X3Hh y1_X3D4 of {
                                                                __DEFAULT ->
                                                                  go1_X3Db (GHC.Prim.+# x3_X3Hh 1#);
                                                                1# -> n_X3CY
                                                              }
                                                          }; } in
                                                  go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                                1# -> n_X3CY
                                              }
                                          }
                                      };
                                    1# ->
                                      case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                        __DEFAULT ->
                                          letrec {
                                            go1_X3Db [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Pos]
                                            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                            go1_X3Db
                                              = \ (x3_X3H9 :: GHC.Prim.Int#) ->
                                                  case GHC.Prim.<# x3_X3H9 0# of {
                                                    __DEFAULT ->
                                                      case GHC.Prim.># x3_X3H9 7# of {
                                                        __DEFAULT ->
                                                          case lvl4_s5KT of {
                                                            False ->
                                                              GHC.Types.:
                                                                @ Pos
                                                                (ds_d4Sc, GHC.Types.I# x3_X3H9)
                                                                (case GHC.Prim.==# x3_X3H9 y1_X3D4
                                                                 of {
                                                                   __DEFAULT ->
                                                                     go1_X3Db
                                                                       (GHC.Prim.+# x3_X3H9 1#);
                                                                   1# -> n_X3CY
                                                                 });
                                                            True ->
                                                              case GHC.Prim.==# x3_X3H9 x1_X5s6 of {
                                                                __DEFAULT ->
                                                                  GHC.Types.:
                                                                    @ Pos
                                                                    (ds_d4Sc, GHC.Types.I# x3_X3H9)
                                                                    (case GHC.Prim.==#
                                                                            x3_X3H9 y1_X3D4
                                                                     of {
                                                                       __DEFAULT ->
                                                                         go1_X3Db
                                                                           (GHC.Prim.+# x3_X3H9 1#);
                                                                       1# -> n_X3CY
                                                                     });
                                                                1# ->
                                                                  case GHC.Prim.==# x3_X3H9 y1_X3D4
                                                                  of {
                                                                    __DEFAULT ->
                                                                      go1_X3Db
                                                                        (GHC.Prim.+# x3_X3H9 1#);
                                                                    1# -> n_X3CY
                                                                  }
                                                              }
                                                          };
                                                        1# ->
                                                          case GHC.Prim.==# x3_X3H9 y1_X3D4 of {
                                                            __DEFAULT ->
                                                              go1_X3Db (GHC.Prim.+# x3_X3H9 1#);
                                                            1# -> n_X3CY
                                                          }
                                                      };
                                                    1# ->
                                                      case GHC.Prim.==# x3_X3H9 y1_X3D4 of {
                                                        __DEFAULT ->
                                                          go1_X3Db (GHC.Prim.+# x3_X3H9 1#);
                                                        1# -> n_X3CY
                                                      }
                                                  }; } in
                                          go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                        1# -> n_X3CY
                                      }
                                  };
                                1# ->
                                  case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                    __DEFAULT ->
                                      letrec {
                                        go1_X3Db [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Pos]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                        go1_X3Db
                                          = \ (x3_X3H6 :: GHC.Prim.Int#) ->
                                              case GHC.Prim.<# x3_X3H6 0# of {
                                                __DEFAULT ->
                                                  case GHC.Prim.># x3_X3H6 7# of {
                                                    __DEFAULT ->
                                                      case lvl4_s5KT of {
                                                        False ->
                                                          GHC.Types.:
                                                            @ Pos
                                                            (ds_d4Sc, GHC.Types.I# x3_X3H6)
                                                            (case GHC.Prim.==# x3_X3H6 y1_X3D4 of {
                                                               __DEFAULT ->
                                                                 go1_X3Db (GHC.Prim.+# x3_X3H6 1#);
                                                               1# -> n_X3CY
                                                             });
                                                        True ->
                                                          case GHC.Prim.==# x3_X3H6 x1_X5s6 of {
                                                            __DEFAULT ->
                                                              GHC.Types.:
                                                                @ Pos
                                                                (ds_d4Sc, GHC.Types.I# x3_X3H6)
                                                                (case GHC.Prim.==# x3_X3H6 y1_X3D4
                                                                 of {
                                                                   __DEFAULT ->
                                                                     go1_X3Db
                                                                       (GHC.Prim.+# x3_X3H6 1#);
                                                                   1# -> n_X3CY
                                                                 });
                                                            1# ->
                                                              case GHC.Prim.==# x3_X3H6 y1_X3D4 of {
                                                                __DEFAULT ->
                                                                  go1_X3Db (GHC.Prim.+# x3_X3H6 1#);
                                                                1# -> n_X3CY
                                                              }
                                                          }
                                                      };
                                                    1# ->
                                                      case GHC.Prim.==# x3_X3H6 y1_X3D4 of {
                                                        __DEFAULT ->
                                                          go1_X3Db (GHC.Prim.+# x3_X3H6 1#);
                                                        1# -> n_X3CY
                                                      }
                                                  };
                                                1# ->
                                                  case GHC.Prim.==# x3_X3H6 y1_X3D4 of {
                                                    __DEFAULT -> go1_X3Db (GHC.Prim.+# x3_X3H6 1#);
                                                    1# -> n_X3CY
                                                  }
                                              }; } in
                                      go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                    1# -> n_X3CY
                                  }
                              };
                            1# ->
                              case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                                __DEFAULT ->
                                  joinrec {
                                    go1_X3Db [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Pos]
                                    [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                                    go1_X3Db (x3_X3H3 :: GHC.Prim.Int#)
                                      = case GHC.Prim.==# x3_X3H3 y1_X3D4 of {
                                          __DEFAULT -> jump go1_X3Db (GHC.Prim.+# x3_X3H3 1#);
                                          1# -> n_X3CY
                                        }; } in
                                  jump go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                                1# -> n_X3CY
                              }
                          };
                        1# ->
                          case GHC.Prim.==# x2_X3D1 y1_X3D4 of {
                            __DEFAULT ->
                              joinrec {
                                go1_X3Db [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Pos]
                                [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                                go1_X3Db (x3_X3H3 :: GHC.Prim.Int#)
                                  = case GHC.Prim.==# x3_X3H3 y1_X3D4 of {
                                      __DEFAULT -> jump go1_X3Db (GHC.Prim.+# x3_X3H3 1#);
                                      1# -> n_X3CY
                                    }; } in
                              jump go1_X3Db (GHC.Prim.+# x2_X3D1 1#);
                            1# -> n_X3CY
                          }
                      };
                    1# -> n_X3CY
                  }
                  }; } in
          go_a3xy x0_a3xv;
        1# -> GHC.Types.[] @ Pos
      }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
getSurroundingPos [InlPrag=NOUSERINLINE[2]] :: Pos -> [Pos]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U(U),U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8nl [Occ=Once!] :: Pos) ->
                 case w_s8nl of { (ww1_s8no [Occ=Once!], ww2_s8nt [Occ=Once]) ->
                 case ww1_s8no of { GHC.Types.I# ww4_s8nr [Occ=Once] ->
                 Util.$wgetSurroundingPos ww4_s8nr ww2_s8nt
                 }
                 }}]
getSurroundingPos
  = \ (w_s8nl :: Pos) ->
      case w_s8nl of { (ww1_s8no, ww2_s8nt) ->
      case ww1_s8no of { GHC.Types.I# ww4_s8nr ->
      Util.$wgetSurroundingPos ww4_s8nr ww2_s8nt
      }
      }

Rec {
-- RHS size: {terms: 42, types: 31, coercions: 0, joins: 0/0}
Util.noQueens_go [Occ=LoopBreaker] :: [Piece] -> [Piece]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Util.noQueens_go
  = \ (ds_a24u :: [Piece]) ->
      case ds_a24u of {
        [] -> GHC.Types.[] @ Piece;
        : y_a24x ys_a24y ->
          case y_a24x of wild1_X1z
          { (x_a3ZZ, ds1_d4WW, ds2_d4WX, ds3_d4WY) ->
          case x_a3ZZ of {
            __DEFAULT -> Util.noQueens_go ys_a24y;
            Queen ->
              case ds2_d4WX of { (a1_a5lR, a2_a5lS) ->
              case a1_a5lR of { GHC.Types.I# x1_a5hr ->
              case x1_a5hr of {
                __DEFAULT ->
                  GHC.Types.: @ Piece wild1_X1z (Util.noQueens_go ys_a24y);
                -1# ->
                  case a2_a5lS of { GHC.Types.I# x2_X5op ->
                  case x2_X5op of {
                    __DEFAULT ->
                      GHC.Types.: @ Piece wild1_X1z (Util.noQueens_go ys_a24y);
                    -1# -> Util.noQueens_go ys_a24y
                  }
                  }
              }
              }
              }
          }
          }
      }
end Rec }

-- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
noQueens :: AllPieces -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 40 20}]
noQueens
  = \ (ps_a4bg :: AllPieces) ->
      case Util.noQueens_go ps_a4bg of {
        [] -> GHC.Types.True;
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Util.findKing1 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.findKing1 = (Util.findKing2, Util.findKing2)

-- RHS size: {terms: 15, types: 18, coercions: 0, joins: 0/0}
moveMade :: Pos -> Pos -> Move
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4W3 [Occ=Once!] :: (Int, Int))
                 (ds1_d4W4 [Occ=Once!] :: (Int, Int)) ->
                 case ds_d4W3 of { (a_a403 [Occ=Once], b_a404 [Occ=Once]) ->
                 case ds1_d4W4 of { (c_a405 [Occ=Once], d_a406 [Occ=Once]) ->
                 (GHC.Num.$fNumInt_$c- c_a405 a_a403,
                  GHC.Num.$fNumInt_$c- d_a406 b_a404)
                 }
                 }}]
moveMade
  = \ (ds_d4W3 :: (Int, Int)) (ds1_d4W4 :: (Int, Int)) ->
      case ds_d4W3 of { (a_a403, b_a404) ->
      case ds1_d4W4 of { (c_a405, d_a406) ->
      (GHC.Num.$fNumInt_$c- c_a405 a_a403,
       GHC.Num.$fNumInt_$c- d_a406 b_a404)
      }
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
updatePosition [InlPrag=NOUSERINLINE[2]] :: Piece -> Move -> Piece
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U,1*U(1*U(U),1*U(U)),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8ny [Occ=Once!] :: Piece)
                 (w1_s8nz [Occ=Once!] :: Move) ->
                 case w_s8ny of
                 { (ww1_s8nC [Occ=Once], ww2_s8nD [Occ=Once], ww3_s8nE [Occ=Once!],
                    ww4_s8nF [Occ=Once!]) ->
                 case w1_s8nz of { (ww6_s8nJ [Occ=Once], ww7_s8nK [Occ=Once]) ->
                 (ww1_s8nC, ww2_s8nD,
                  case ww3_s8nE of { (a_a40e [Occ=Once], b_a40f [Occ=Once]) ->
                  (GHC.Num.$fNumInt_$c+ a_a40e ww6_s8nJ,
                   GHC.Num.$fNumInt_$c+ b_a40f ww7_s8nK)
                  },
                  case ww4_s8nF of { GHC.Types.I# x_a5kQ [Occ=Once] ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                  })
                 }
                 }}]
updatePosition
  = \ (w_s8ny :: Piece) (w1_s8nz :: Move) ->
      case w_s8ny of { (ww1_s8nC, ww2_s8nD, ww3_s8nE, ww4_s8nF) ->
      case w1_s8nz of { (ww6_s8nJ, ww7_s8nK) ->
      (ww1_s8nC, ww2_s8nD,
       case ww3_s8nE of { (a_a40e, b_a40f) ->
       (GHC.Num.$fNumInt_$c+ a_a40e ww6_s8nJ,
        GHC.Num.$fNumInt_$c+ b_a40f ww7_s8nK)
       },
       case ww4_s8nF of { GHC.Types.I# x_a5kQ ->
       GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
       })
      }
      }

-- RHS size: {terms: 15, types: 18, coercions: 0, joins: 0/0}
getTarget :: Pos -> Move -> Pos
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4VB [Occ=Once!] :: (Int, Int))
                 (ds1_d4VC [Occ=Once!] :: (Int, Int)) ->
                 case ds_d4VB of { (a_a40e [Occ=Once], b_a40f [Occ=Once]) ->
                 case ds1_d4VC of { (c_a40g [Occ=Once], d_a40h [Occ=Once]) ->
                 (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
                  GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
                 }
                 }}]
getTarget
  = \ (ds_d4VB :: (Int, Int)) (ds1_d4VC :: (Int, Int)) ->
      case ds_d4VB of { (a_a40e, b_a40f) ->
      case ds1_d4VC of { (c_a40g, d_a40h) ->
      (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
       GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
      }
      }

-- RHS size: {terms: 59, types: 16, coercions: 0, joins: 0/0}
Util.$wisPawnCapture [InlPrag=NOUSERINLINE[2]]
  :: Colour -> GHC.Prim.Int# -> Int -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U><L,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [121 60 40] 202 100}]
Util.$wisPawnCapture
  = \ (ww_s8nV :: Colour)
      (ww1_s8o4 :: GHC.Prim.Int#)
      (ww2_s8o6 :: Int) ->
      case ww_s8nV of {
        Black ->
          case ww1_s8o4 of {
            __DEFAULT -> GHC.Types.False;
            1# ->
              case ww2_s8o6 of { GHC.Types.I# x_a5ky ->
              case GHC.Prim.>=# x_a5ky 0# of {
                __DEFAULT ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    -1# -> GHC.Types.True
                  };
                1# ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    1# -> GHC.Types.True
                  }
              }
              }
          };
        White ->
          case ww1_s8o4 of {
            __DEFAULT -> GHC.Types.False;
            -1# ->
              case ww2_s8o6 of { GHC.Types.I# x_a5ky ->
              case GHC.Prim.>=# x_a5ky 0# of {
                __DEFAULT ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    -1# -> GHC.Types.True
                  };
                1# ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    1# -> GHC.Types.True
                  }
              }
              }
          }
      }

-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
isPawnCapture [InlPrag=NOUSERINLINE[2]] :: Piece -> Move -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S(S(S)L),1*U(1*U(1*U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8nQ [Occ=Once!] :: Piece)
                 (w1_s8nR [Occ=Once!] :: Move) ->
                 case w_s8nQ of
                 { (_ [Occ=Dead], ww2_s8nV [Occ=Once], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case w1_s8nR of { (ww6_s8o1 [Occ=Once!], ww7_s8o6 [Occ=Once]) ->
                 case ww6_s8o1 of { GHC.Types.I# ww9_s8o4 [Occ=Once] ->
                 Util.$wisPawnCapture ww2_s8nV ww9_s8o4 ww7_s8o6
                 }
                 }
                 }}]
isPawnCapture
  = \ (w_s8nQ :: Piece) (w1_s8nR :: Move) ->
      case w_s8nQ of { (ww1_s8nU, ww2_s8nV, ww3_s8nW, ww4_s8nX) ->
      case w1_s8nR of { (ww6_s8o1, ww7_s8o6) ->
      case ww6_s8o1 of { GHC.Types.I# ww9_s8o4 ->
      Util.$wisPawnCapture ww2_s8nV ww9_s8o4 ww7_s8o6
      }
      }
      }

-- RHS size: {terms: 105, types: 66, coercions: 0, joins: 0/3}
Util.$wpawnControlledSquares [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> [Pos]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(U(U),U(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 80] 398 30}]
Util.$wpawnControlledSquares
  = \ (ww_s8om :: Colour) (ww1_s8on :: Pos) ->
      let {
        sc_saFX :: [(Int, Int)]
        [LclId]
        sc_saFX
          = case ww_s8om of {
              Black ->
                GHC.Types.:
                  @ Pos
                  (case ww1_s8on of { (a_a40e, b_a40f) ->
                   (case a_a40e of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ 1#)
                    },
                    case b_a40f of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ 1#)
                    })
                   })
                  (GHC.Types.[] @ Pos);
              White -> GHC.Types.[] @ Pos
            } } in
      let {
        w_s8oc :: [Pos]
        [LclId]
        w_s8oc
          = case ww_s8om of {
              Black ->
                GHC.Types.:
                  @ Pos
                  (case ww1_s8on of { (a_a40e, b_a40f) ->
                   (case a_a40e of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ 1#)
                    },
                    case b_a40f of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ -1#)
                    })
                   })
                  sc_saFX;
              White -> sc_saFX
            } } in
      let {
        sc1_XaJF :: [(Int, Int)]
        [LclId]
        sc1_XaJF
          = case ww_s8om of {
              Black -> w_s8oc;
              White ->
                GHC.Types.:
                  @ Pos
                  (case ww1_s8on of { (a_a40e, b_a40f) ->
                   (case a_a40e of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ -1#)
                    },
                    case b_a40f of { GHC.Types.I# x_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x_a5kQ 1#)
                    })
                   })
                  w_s8oc
            } } in
      case ww_s8om of {
        Black -> sc1_XaJF;
        White ->
          GHC.Types.:
            @ Pos
            (case ww1_s8on of { (a_a40e, b_a40f) ->
             (case a_a40e of { GHC.Types.I# x_a5kQ ->
              GHC.Types.I# (GHC.Prim.+# x_a5kQ -1#)
              },
              case b_a40f of { GHC.Types.I# x_a5kQ ->
              GHC.Types.I# (GHC.Prim.+# x_a5kQ -1#)
              })
             })
            sc1_XaJF
      }

-- RHS size: {terms: 7, types: 6, coercions: 0, joins: 0/0}
pawnControlledSquares [InlPrag=NOUSERINLINE[2]] :: Piece -> [Pos]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,U,U(U(U),U(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8oi [Occ=Once!] :: Piece) ->
                 case w_s8oi of
                 { (_ [Occ=Dead], ww2_s8om [Occ=Once], ww3_s8on [Occ=Once],
                    _ [Occ=Dead]) ->
                 Util.$wpawnControlledSquares ww2_s8om ww3_s8on
                 }}]
pawnControlledSquares
  = \ (w_s8oi :: Piece) ->
      case w_s8oi of { (ww1_s8ol, ww2_s8om, ww3_s8on, ww4_s8oo) ->
      Util.$wpawnControlledSquares ww2_s8om ww3_s8on
      }

-- RHS size: {terms: 40, types: 9, coercions: 0, joins: 0/0}
Util.$wisDiagonal [InlPrag=NOUSERINLINE[2]]
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 75 0}]
Util.$wisDiagonal
  = \ (ww_s8ox :: GHC.Prim.Int#) (ww1_s8oC :: GHC.Prim.Int#) ->
      case GHC.Prim.>=# ww_s8ox 0# of {
        __DEFAULT ->
          case GHC.Prim.>=# ww1_s8oC 0# of {
            __DEFAULT ->
              GHC.Prim.tagToEnum#
                @ Bool
                (GHC.Prim.==#
                   (GHC.Prim.negateInt# ww_s8ox) (GHC.Prim.negateInt# ww1_s8oC));
            1# ->
              GHC.Prim.tagToEnum#
                @ Bool (GHC.Prim.==# (GHC.Prim.negateInt# ww_s8ox) ww1_s8oC)
          };
        1# ->
          case GHC.Prim.>=# ww1_s8oC 0# of {
            __DEFAULT ->
              GHC.Prim.tagToEnum#
                @ Bool (GHC.Prim.==# ww_s8ox (GHC.Prim.negateInt# ww1_s8oC));
            1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.==# ww_s8ox ww1_s8oC)
          }
      }

-- RHS size: {terms: 13, types: 8, coercions: 0, joins: 0/0}
isDiagonal [InlPrag=NOUSERINLINE[2]] :: Move -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8or [Occ=Once!] :: Move) ->
                 case w_s8or of { (ww1_s8ou [Occ=Once!], ww2_s8oz [Occ=Once!]) ->
                 case ww1_s8ou of { GHC.Types.I# ww4_s8ox [Occ=Once] ->
                 case ww2_s8oz of { GHC.Types.I# ww6_s8oC [Occ=Once] ->
                 Util.$wisDiagonal ww4_s8ox ww6_s8oC
                 }
                 }
                 }}]
isDiagonal
  = \ (w_s8or :: Move) ->
      case w_s8or of { (ww1_s8ou, ww2_s8oz) ->
      case ww1_s8ou of { GHC.Types.I# ww4_s8ox ->
      case ww2_s8oz of { GHC.Types.I# ww6_s8oC ->
      Util.$wisDiagonal ww4_s8ox ww6_s8oC
      }
      }
      }

-- RHS size: {terms: 83, types: 21, coercions: 0, joins: 3/3}
Util.$wisLShaped [InlPrag=NOUSERINLINE[2]]
  :: GHC.Prim.Int# -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [124 40] 280 0}]
Util.$wisLShaped
  = \ (ww_s8oM :: GHC.Prim.Int#) (ww1_s8oO :: Int) ->
      join {
        $j_s5Q0 [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5Q0
          = join {
              $j1_s5PW [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5PW
                = case ww1_s8oO of { GHC.Types.I# x_X5qp ->
                  case GHC.Prim.>=# x_X5qp 0# of {
                    __DEFAULT ->
                      case x_X5qp of {
                        __DEFAULT -> GHC.Types.False;
                        -2# -> GHC.Types.True
                      };
                    1# ->
                      case x_X5qp of {
                        __DEFAULT -> GHC.Types.False;
                        2# -> GHC.Types.True
                      }
                  }
                  } } in
            case GHC.Prim.>=# ww_s8oM 0# of {
              __DEFAULT ->
                case ww_s8oM of {
                  __DEFAULT -> GHC.Types.False;
                  -1# -> jump $j1_s5PW
                };
              1# ->
                case ww_s8oM of {
                  __DEFAULT -> GHC.Types.False;
                  1# -> jump $j1_s5PW
                }
            } } in
      join {
        $j1_s5Q5 [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j1_s5Q5
          = case ww1_s8oO of { GHC.Types.I# x_X5qm ->
            case GHC.Prim.>=# x_X5qm 0# of {
              __DEFAULT ->
                case x_X5qm of {
                  __DEFAULT -> jump $j_s5Q0;
                  -1# -> GHC.Types.True
                };
              1# ->
                case x_X5qm of {
                  __DEFAULT -> jump $j_s5Q0;
                  1# -> GHC.Types.True
                }
            }
            } } in
      case GHC.Prim.>=# ww_s8oM 0# of {
        __DEFAULT ->
          case ww_s8oM of {
            __DEFAULT -> jump $j_s5Q0;
            -2# -> jump $j1_s5Q5
          };
        1# ->
          case ww_s8oM of {
            __DEFAULT -> jump $j_s5Q0;
            2# -> jump $j1_s5Q5
          }
      }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
isLShaped [InlPrag=NOUSERINLINE[2]] :: Move -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8oG [Occ=Once!] :: Move) ->
                 case w_s8oG of { (ww1_s8oJ [Occ=Once!], ww2_s8oO [Occ=Once]) ->
                 case ww1_s8oJ of { GHC.Types.I# ww4_s8oM [Occ=Once] ->
                 Util.$wisLShaped ww4_s8oM ww2_s8oO
                 }
                 }}]
isLShaped
  = \ (w_s8oG :: Move) ->
      case w_s8oG of { (ww1_s8oJ, ww2_s8oO) ->
      case ww1_s8oJ of { GHC.Types.I# ww4_s8oM ->
      Util.$wisLShaped ww4_s8oM ww2_s8oO
      }
      }

-- RHS size: {terms: 84, types: 88, coercions: 0, joins: 1/3}
findKing :: Colour -> AllPieces -> Pos
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 328 0}]
findKing
  = \ (colour_a4en :: Colour) (ps_a4eo :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker]
          :: [(PieceType, Colour, Pos, Movecount)] -> [(Int, Int)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [(PieceType, Colour, Pos, Movecount)]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Int, Int);
                : y_a24x ys_a24y ->
                  case y_a24x of { (t_a4eq, c_a4er, ds1_d4Te, m_a4eu) ->
                  case ds1_d4Te of wild2_XF { (x_a4es, y1_a4et) ->
                  let {
                    ds2_d4T3 :: [(Int, Int)]
                    [LclId]
                    ds2_d4T3 = go_a24t ys_a24y } in
                  case t_a4eq of {
                    __DEFAULT -> ds2_d4T3;
                    King ->
                      join {
                        $j_s5Py [Dmd=<L,1*U>] :: [(Int, Int)]
                        [LclId[JoinId(0)]]
                        $j_s5Py
                          = case x_a4es of { GHC.Types.I# x1_a5jV ->
                            case GHC.Prim.># x1_a5jV -1# of {
                              __DEFAULT -> ds2_d4T3;
                              1# ->
                                case y1_a4et of { GHC.Types.I# x2_X5rr ->
                                case GHC.Prim.># x2_X5rr -1# of {
                                  __DEFAULT -> ds2_d4T3;
                                  1# ->
                                    case GHC.Prim.<# x1_a5jV 8# of {
                                      __DEFAULT -> ds2_d4T3;
                                      1# ->
                                        case GHC.Prim.<# x2_X5rr 8# of {
                                          __DEFAULT -> ds2_d4T3;
                                          1# -> GHC.Types.: @ (Int, Int) wild2_XF ds2_d4T3
                                        }
                                    }
                                }
                                }
                            }
                            } } in
                      case c_a4er of {
                        Black ->
                          case colour_a4en of {
                            Black -> jump $j_s5Py;
                            White -> ds2_d4T3
                          };
                        White ->
                          case colour_a4en of {
                            Black -> ds2_d4T3;
                            White -> jump $j_s5Py
                          }
                      }
                  }
                  }
                  }
              }; } in
      case go_a24t ps_a4eo of {
        [] -> Util.findKing1;
        : ds1_a5jz ds2_a5jA -> ds1_a5jz
      }

-- RHS size: {terms: 168, types: 139, coercions: 0, joins: 0/3}
findPiece :: Pos -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U),U(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 788 40}]
findPiece
  = \ (pos_a40i :: Pos) (ps_a40j :: AllPieces) ->
      case ps_a40j of {
        [] -> GHC.Types.[] @ Piece;
        : y_a24x ys_a24y ->
          case y_a24x of wild1_X1y
          { (ds_d4Xh, ds1_d4Xi, pos1_a3ZY, ds2_d4Xj) ->
          case pos1_a3ZY of { (ww4_a5iu, ww5_a5iv) ->
          case pos_a40i of { (ww7_a5iA, ww8_a5iB) ->
          case ww4_a5iu of { GHC.Types.I# x_a5hr ->
          case ww7_a5iA of { GHC.Types.I# y1_a5hu ->
          case GHC.Prim.==# x_a5hr y1_a5hu of {
            __DEFAULT ->
              letrec {
                go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                go_a24t
                  = \ (ds3_a24u :: [Piece]) ->
                      case ds3_a24u of {
                        [] -> GHC.Types.[] @ Piece;
                        : y2_X28J ys1_X28L ->
                          case y2_X28J of wild5_X5O
                          { (ds4_X51z, ds5_X51B, pos2_X44i, ds6_X51E) ->
                          case pos2_X44i of { (ww2_X5mU, ww9_X5mW) ->
                          case ww2_X5mU of { GHC.Types.I# x1_X5m1 ->
                          case GHC.Prim.==# x1_X5m1 y1_a5hu of {
                            __DEFAULT -> go_a24t ys1_X28L;
                            1# ->
                              case ww9_X5mW of { GHC.Types.I# x2_X5p3 ->
                              case ww8_a5iB of { GHC.Types.I# y3_X5pb ->
                              case GHC.Prim.==# x2_X5p3 y3_X5pb of {
                                __DEFAULT -> go_a24t ys1_X28L;
                                1# -> GHC.Types.: @ Piece wild5_X5O (go_a24t ys1_X28L)
                              }
                              }
                              }
                          }
                          }
                          }
                          }
                      }; } in
              go_a24t ys_a24y;
            1# ->
              case ww5_a5iv of { GHC.Types.I# x1_X5p3 ->
              case ww8_a5iB of { GHC.Types.I# y2_X5pb ->
              case GHC.Prim.==# x1_X5p3 y2_X5pb of {
                __DEFAULT ->
                  letrec {
                    go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go_a24t
                      = \ (ds3_a24u :: [Piece]) ->
                          case ds3_a24u of {
                            [] -> GHC.Types.[] @ Piece;
                            : y3_X28W ys1_X28Y ->
                              case y3_X28W of wild7_X61
                              { (ds4_X51M, ds5_X51O, pos2_X44v, ds6_X51R) ->
                              case pos2_X44v of { (ww2_X5n7, ww9_X5n9) ->
                              case ww2_X5n7 of { GHC.Types.I# x2_X5me ->
                              case GHC.Prim.==# x2_X5me y1_a5hu of {
                                __DEFAULT -> go_a24t ys1_X28Y;
                                1# ->
                                  case ww9_X5n9 of { GHC.Types.I# x3_X5u3 ->
                                  case GHC.Prim.==# x3_X5u3 y2_X5pb of {
                                    __DEFAULT -> go_a24t ys1_X28Y;
                                    1# -> GHC.Types.: @ Piece wild7_X61 (go_a24t ys1_X28Y)
                                  }
                                  }
                              }
                              }
                              }
                              }
                          }; } in
                  go_a24t ys_a24y;
                1# ->
                  GHC.Types.:
                    @ Piece
                    wild1_X1y
                    (letrec {
                       go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
                       [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                       go_a24t
                         = \ (ds3_a24u :: [Piece]) ->
                             case ds3_a24u of {
                               [] -> GHC.Types.[] @ Piece;
                               : y3_X28W ys1_X28Y ->
                                 case y3_X28W of wild7_X61
                                 { (ds4_X51M, ds5_X51O, pos2_X44v, ds6_X51R) ->
                                 case pos2_X44v of { (ww2_X5n7, ww9_X5n9) ->
                                 case ww2_X5n7 of { GHC.Types.I# x2_X5me ->
                                 case GHC.Prim.==# x2_X5me y1_a5hu of {
                                   __DEFAULT -> go_a24t ys1_X28Y;
                                   1# ->
                                     case ww9_X5n9 of { GHC.Types.I# x3_X5u3 ->
                                     case GHC.Prim.==# x3_X5u3 y2_X5pb of {
                                       __DEFAULT -> go_a24t ys1_X28Y;
                                       1# -> GHC.Types.: @ Piece wild7_X61 (go_a24t ys1_X28Y)
                                     }
                                     }
                                 }
                                 }
                                 }
                                 }
                             }; } in
                     go_a24t ys_a24y)
              }
              }
              }
          }
          }
          }
          }
          }
          }
      }

Rec {
-- RHS size: {terms: 31, types: 34, coercions: 0, joins: 0/0}
Util.surroundingPieces_$ssurroundingPieces [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> [(Int, Int)] -> [Piece]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,1*U>, Unf=OtherCon []]
Util.surroundingPieces_$ssurroundingPieces
  = \ (sc_saFo :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saFn :: [(Int, Int)]) ->
      case sc1_saFn of {
        [] -> GHC.Types.[] @ Piece;
        : ipv_s5iR ipv1_s5iS ->
          case findPiece ipv_s5iR sc_saFo of {
            [] -> Util.surroundingPieces_$ssurroundingPieces sc_saFo ipv1_s5iS;
            : ds1_a5jz ds2_a5jA ->
              case ds1_a5jz of wild2_X1x
              { (ds_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
              case colour_a3ZX of {
                Black ->
                  Util.surroundingPieces_$ssurroundingPieces sc_saFo ipv1_s5iS;
                White ->
                  GHC.Types.:
                    @ Piece
                    wild2_X1x
                    (Util.surroundingPieces_$ssurroundingPieces sc_saFo ipv1_s5iS)
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 31, types: 34, coercions: 0, joins: 0/0}
Util.surroundingPieces_$ssurroundingPieces1 [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> [(Int, Int)] -> [Piece]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,1*U>, Unf=OtherCon []]
Util.surroundingPieces_$ssurroundingPieces1
  = \ (sc_saFk :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saFj :: [(Int, Int)]) ->
      case sc1_saFj of {
        [] -> GHC.Types.[] @ Piece;
        : ipv_s5iR ipv1_s5iS ->
          case findPiece ipv_s5iR sc_saFk of {
            [] ->
              Util.surroundingPieces_$ssurroundingPieces1 sc_saFk ipv1_s5iS;
            : ds1_a5jz ds2_a5jA ->
              case ds1_a5jz of wild2_X1x
              { (ds_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
              case colour_a3ZX of {
                Black ->
                  GHC.Types.:
                    @ Piece
                    wild2_X1x
                    (Util.surroundingPieces_$ssurroundingPieces1 sc_saFk ipv1_s5iS);
                White ->
                  Util.surroundingPieces_$ssurroundingPieces1 sc_saFk ipv1_s5iS
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 52, types: 38, coercions: 0, joins: 0/0}
surroundingPieces [Occ=LoopBreaker]
  :: Colour -> [Pos] -> AllPieces -> [Piece]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U><L,U>,
 Unf=OtherCon []]
surroundingPieces
  = \ (colour_a4hl :: Colour)
      (ds_d52h :: [Pos])
      (ps_a4hm :: AllPieces) ->
      case ds_d52h of {
        [] -> GHC.Types.[] @ Piece;
        : ipv_s5iR ipv1_s5iS ->
          case findPiece ipv_s5iR ps_a4hm of {
            [] -> surroundingPieces colour_a4hl ipv1_s5iS ps_a4hm;
            : ds1_a5jz ds2_a5jA ->
              case colour_a4hl of {
                Black ->
                  case ds1_a5jz of wild3_X1x
                  { (ds4_d529, colour1_a3ZX, ds5_d52a, ds6_d52b) ->
                  case colour1_a3ZX of {
                    Black ->
                      GHC.Types.:
                        @ Piece
                        wild3_X1x
                        (Util.surroundingPieces_$ssurroundingPieces1 ps_a4hm ipv1_s5iS);
                    White ->
                      Util.surroundingPieces_$ssurroundingPieces1 ps_a4hm ipv1_s5iS
                  }
                  };
                White ->
                  case ds1_a5jz of wild3_X1x
                  { (ds4_d529, colour1_a3ZX, ds5_d52a, ds6_d52b) ->
                  case colour1_a3ZX of {
                    Black ->
                      Util.surroundingPieces_$ssurroundingPieces ps_a4hm ipv1_s5iS;
                    White ->
                      GHC.Types.:
                        @ Piece
                        wild3_X1x
                        (Util.surroundingPieces_$ssurroundingPieces ps_a4hm ipv1_s5iS)
                  }
                  }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 36, types: 28, coercions: 0, joins: 0/0}
getPiecesFromMoves [Occ=LoopBreaker]
  :: Pos -> [Move] -> AllPieces -> [Piece]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U),U(U))><S,1*U><L,U>,
 Unf=OtherCon []]
getPiecesFromMoves
  = \ (pos_a4fp :: Pos) (ds_d510 :: [Move]) (ps_a4fq :: AllPieces) ->
      case ds_d510 of {
        [] -> GHC.Types.[] @ Piece;
        : ipv_s5kW ipv1_s5kX ->
          case findPiece
                 (case pos_a4fp of { (a_a40e, b_a40f) ->
                  case ipv_s5kW of { (c_a40g, d_a40h) ->
                  (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
                   GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
                  }
                  })
                 ps_a4fq
          of {
            [] -> getPiecesFromMoves pos_a4fp ipv1_s5kX ps_a4fq;
            : ds1_a5jz ds2_a5jA ->
              GHC.Types.:
                @ Piece ds1_a5jz (getPiecesFromMoves pos_a4fp ipv1_s5kX ps_a4fq)
          }
      }
end Rec }

-- RHS size: {terms: 289, types: 164, coercions: 0, joins: 4/7}
removePiece :: Piece -> [Piece] -> [Piece]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(U,U,U(U(U),U(U)),U(U))><S,1*U>,
 Unf=OtherCon []]
removePiece
  = \ (pieceToRemove_a400 :: Piece) (ps_a401 :: [Piece]) ->
      case ps_a401 of {
        [] -> GHC.Types.[] @ Piece;
        : y_a24x ys_a24y ->
          case y_a24x of wild1_a5hU { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
          case pieceToRemove_a400 of
          { (b1_a5i1, b2_a5i2, b3_a5i3, b4_a5i4) ->
          let {
            ds_d4Wk :: [Piece]
            [LclId]
            ds_d4Wk
              = letrec {
                  go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
                  [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                  go_a24t
                    = \ (ds1_a24u :: [Piece]) ->
                        case ds1_a24u of {
                          [] -> GHC.Types.[] @ Piece;
                          : y1_X28x ys1_X28z ->
                            case y1_X28x of wild4_X5lY
                            { (a7_X5m1, a8_X5m3, a9_X5m5, a10_X5m7) ->
                            let {
                              ds2_X50F :: [Piece]
                              [LclId]
                              ds2_X50F = go_a24t ys1_X28z } in
                            join {
                              $j_s5P5 [Dmd=<L,1*U>] :: [Piece]
                              [LclId[JoinId(0)]]
                              $j_s5P5
                                = join {
                                    $j1_s5P1 [Dmd=<L,1*U>] :: [Piece]
                                    [LclId[JoinId(0)]]
                                    $j1_s5P1
                                      = case a9_X5m5 of { (ww4_a5iu, ww5_a5iv) ->
                                        case b3_a5i3 of { (ww7_a5iA, ww8_a5iB) ->
                                        case ww4_a5iu of { GHC.Types.I# x_a5hr ->
                                        case ww7_a5iA of { GHC.Types.I# y2_a5hu ->
                                        case GHC.Prim.==# x_a5hr y2_a5hu of {
                                          __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                          1# ->
                                            case ww5_a5iv of { GHC.Types.I# x1_X5pg ->
                                            case ww8_a5iB of { GHC.Types.I# y3_X5po ->
                                            case GHC.Prim.==# x1_X5pg y3_X5po of {
                                              __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                              1# ->
                                                case a10_X5m7 of { GHC.Types.I# x2_X5pt ->
                                                case b4_a5i4 of { GHC.Types.I# y4_X5pB ->
                                                case GHC.Prim.==# x2_X5pt y4_X5pB of {
                                                  __DEFAULT ->
                                                    GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                                  1# -> ds2_X50F
                                                }
                                                }
                                                }
                                            }
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                        } } in
                                  case a8_X5m3 of {
                                    Black ->
                                      case b2_a5i2 of {
                                        Black -> jump $j1_s5P1;
                                        White -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F
                                      };
                                    White ->
                                      case b2_a5i2 of {
                                        Black -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                        White -> jump $j1_s5P1
                                      }
                                  } } in
                            case a7_X5m1 of {
                              Pawn ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  Pawn -> jump $j_s5P5
                                };
                              Knight ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  Knight -> jump $j_s5P5
                                };
                              Bishop ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  Bishop -> jump $j_s5P5
                                };
                              Rook ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  Rook -> jump $j_s5P5
                                };
                              Queen ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  Queen -> jump $j_s5P5
                                };
                              King ->
                                case b1_a5i1 of {
                                  __DEFAULT -> GHC.Types.: @ Piece wild4_X5lY ds2_X50F;
                                  King -> jump $j_s5P5
                                }
                            }
                            }
                        }; } in
                go_a24t ys_a24y } in
          join {
            $j_s5P5 [Dmd=<L,1*U>] :: [Piece]
            [LclId[JoinId(0)]]
            $j_s5P5
              = join {
                  $j1_s5P1 [Dmd=<L,1*U>] :: [Piece]
                  [LclId[JoinId(0)]]
                  $j1_s5P1
                    = case a3_a5hX of { (ww4_a5iu, ww5_a5iv) ->
                      case b3_a5i3 of { (ww7_a5iA, ww8_a5iB) ->
                      case ww4_a5iu of { GHC.Types.I# x_a5hr ->
                      case ww7_a5iA of { GHC.Types.I# y1_a5hu ->
                      case GHC.Prim.==# x_a5hr y1_a5hu of {
                        __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                        1# ->
                          case ww5_a5iv of { GHC.Types.I# x1_X5pg ->
                          case ww8_a5iB of { GHC.Types.I# y2_X5po ->
                          case GHC.Prim.==# x1_X5pg y2_X5po of {
                            __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                            1# ->
                              case a4_a5hY of { GHC.Types.I# x2_X5pt ->
                              case b4_a5i4 of { GHC.Types.I# y3_X5pB ->
                              case GHC.Prim.==# x2_X5pt y3_X5pB of {
                                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                                1# -> ds_d4Wk
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                      }
                      }
                      }
                      } } in
                case a2_a5hW of {
                  Black ->
                    case b2_a5i2 of {
                      Black -> jump $j1_s5P1;
                      White -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk
                    };
                  White ->
                    case b2_a5i2 of {
                      Black -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                      White -> jump $j1_s5P1
                    }
                } } in
          case a1_a5hV of {
            Pawn ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                Pawn -> jump $j_s5P5
              };
            Knight ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                Knight -> jump $j_s5P5
              };
            Bishop ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                Bishop -> jump $j_s5P5
              };
            Rook ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                Rook -> jump $j_s5P5
              };
            Queen ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                Queen -> jump $j_s5P5
              };
            King ->
              case b1_a5i1 of {
                __DEFAULT -> GHC.Types.: @ Piece wild1_a5hU ds_d4Wk;
                King -> jump $j_s5P5
              }
          }
          }
          }
      }

-- RHS size: {terms: 17, types: 17, coercions: 0, joins: 0/0}
upgradeToQueen [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(U,U,U(U(U),U(U)),U(U))><L,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8p6 [Occ=Once!] :: Piece)
                 (w1_s8p7 [Occ=Once] :: AllPieces) ->
                 case w_s8p6 of
                 { (ww1_s8pa [Occ=Once], ww2_s8pb, ww3_s8pc [Occ=Once!],
                    ww4_s8pi) ->
                 case ww3_s8pc of { (ww6_s8pf, ww7_s8pg) ->
                 GHC.Types.:
                   @ Piece
                   (TypeDefs.Queen, ww2_s8pb, (ww6_s8pf, ww7_s8pg), ww4_s8pi)
                   (removePiece
                      (ww1_s8pa, ww2_s8pb, (ww6_s8pf, ww7_s8pg), ww4_s8pi) w1_s8p7)
                 }
                 }}]
upgradeToQueen
  = \ (w_s8p6 :: Piece) (w1_s8p7 :: AllPieces) ->
      case w_s8p6 of ww_s8p9
      { (ww1_s8pa, ww2_s8pb, ww3_s8pc, ww4_s8pi) ->
      case ww3_s8pc of ww5_s8pe { (ww6_s8pf, ww7_s8pg) ->
      GHC.Types.:
        @ Piece
        (TypeDefs.Queen, ww2_s8pb, ww5_s8pe, ww4_s8pi)
        (removePiece ww_s8p9 w1_s8p7)
      }
      }

-- RHS size: {terms: 90, types: 100, coercions: 0, joins: 0/3}
Util.$wpromotePawn [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> (# Piece, [Piece] #)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 40 0] 413 30}]
Util.$wpromotePawn
  = \ (w_s8po :: Piece) (w1_s8pp :: Move) (w2_s8pq :: AllPieces) ->
      let {
        board_s5Jd :: Piece
        [LclId]
        board_s5Jd
          = case w_s8po of { (p_a407, colour_a408, pos_a409, mc_a40a) ->
            case w1_s8pp of { (m_a40b, n_a40c) ->
            (p_a407, colour_a408,
             case pos_a409 of { (a_a40e, b_a40f) ->
             (GHC.Num.$fNumInt_$c+ a_a40e m_a40b,
              GHC.Num.$fNumInt_$c+ b_a40f n_a40c)
             },
             case mc_a40a of { GHC.Types.I# x_a5kQ ->
             GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
             })
            }
            } } in
      let {
        board1_s5Jc :: [Piece]
        [LclId]
        board1_s5Jc = removePiece w_s8po w2_s8pq } in
      let {
        board2_s5Jb [Dmd=<S,U>] :: [Piece]
        [LclId, Unf=OtherCon []]
        board2_s5Jb = GHC.Types.: @ Piece board_s5Jd board1_s5Jc } in
      case findPiece
             (case w_s8po of { (ds_d4Xh, ds1_d4Xi, pos_a3ZY, ds2_d4Xj) ->
              case pos_a3ZY of { (a_a40e, b_a40f) ->
              case w1_s8pp of { (c_a40g, d_a40h) ->
              (case a_a40e of { GHC.Types.I# x_a5kQ ->
               case c_a40g of { GHC.Types.I# y_a5kT ->
               GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
               }
               },
               case b_a40f of { GHC.Types.I# x_a5kQ ->
               case d_a40h of { GHC.Types.I# y_a5kT ->
               GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
               }
               })
              }
              }
              })
             board2_s5Jb
      of {
        [] -> case GHC.List.badHead of wild1_00 { };
        : x_a4SP ds1_a4SQ ->
          case x_a4SP of wild1_X1T
          { (piece_a4dy, colour_a4dz, ds_d4WB, mc_a4dC) ->
          case ds_d4WB of wild2_Xu { (m_a4dA, n_a4dB) ->
          (# (TypeDefs.Queen, colour_a4dz, wild2_Xu, mc_a4dC),
             removePiece wild1_X1T board2_s5Jb #)
          }
          }
      }

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
promotePawn [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8po [Occ=Once] :: Piece)
                 (w1_s8pp [Occ=Once] :: Move)
                 (w2_s8pq [Occ=Once] :: AllPieces) ->
                 case Util.$wpromotePawn w_s8po w1_s8pp w2_s8pq of
                 { (# ww1_s8wd [Occ=Once], ww2_s8we [Occ=Once] #) ->
                 GHC.Types.: @ Piece ww1_s8wd ww2_s8we
                 }}]
promotePawn
  = \ (w_s8po :: Piece) (w1_s8pp :: Move) (w2_s8pq :: AllPieces) ->
      case Util.$wpromotePawn w_s8po w1_s8pp w2_s8pq of
      { (# ww1_s8wd, ww2_s8we #) ->
      GHC.Types.: @ Piece ww1_s8wd ww2_s8we
      }

-- RHS size: {terms: 14, types: 28, coercions: 0, joins: 0/0}
takePiece :: Piece -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U,U(U(U),U(U)),U(U))><L,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4WC [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount))
                 (ps_a4fG [Occ=Once] :: AllPieces) ->
                 case ds_d4WC of
                 { (p_a4fC, colour_a4fD, pos_a4fE [Occ=Once], mc_a4fF [Occ=Once]) ->
                 GHC.Types.:
                   @ (PieceType, Colour, (Int, Int), Movecount)
                   (p_a4fC, colour_a4fD, Util.findKing1, Util.allPiecesMoved1)
                   (removePiece (p_a4fC, colour_a4fD, pos_a4fE, mc_a4fF) ps_a4fG)
                 }}]
takePiece
  = \ (ds_d4WC :: (PieceType, Colour, Pos, Movecount))
      (ps_a4fG :: AllPieces) ->
      case ds_d4WC of wild_X2b
      { (p_a4fC, colour_a4fD, pos_a4fE, mc_a4fF) ->
      GHC.Types.:
        @ (PieceType, Colour, (Int, Int), Movecount)
        (p_a4fC, colour_a4fD, Util.findKing1, Util.allPiecesMoved1)
        (removePiece wild_X2b ps_a4fG)
      }

-- RHS size: {terms: 21, types: 14, coercions: 0, joins: 0/0}
isStraightMove :: Move -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(1*U),1*U(1*U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4Tx [Occ=Once!] :: (Int, Int)) ->
                 case ds_d4Tx of { (row_a4dJ [Occ=Once!], col_a4dK [Occ=Once!]) ->
                 case row_a4dJ of { GHC.Types.I# x_a5hr [Occ=Once!] ->
                 case x_a5hr of {
                   __DEFAULT ->
                     case col_a4dK of { GHC.Types.I# x1_X5oP [Occ=Once!] ->
                     case x1_X5oP of {
                       __DEFAULT -> GHC.Types.False;
                       0# -> GHC.Types.True
                     }
                     };
                   0# -> GHC.Types.True
                 }
                 }
                 }}]
isStraightMove
  = \ (ds_d4Tx :: (Int, Int)) ->
      case ds_d4Tx of { (row_a4dJ, col_a4dK) ->
      case row_a4dJ of { GHC.Types.I# x_a5hr ->
      case x_a5hr of {
        __DEFAULT ->
          case col_a4dK of { GHC.Types.I# x1_X5oP ->
          case x1_X5oP of {
            __DEFAULT -> GHC.Types.False;
            0# -> GHC.Types.True
          }
          };
        0# -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 27, types: 32, coercions: 0, joins: 0/0}
isFriendly :: Piece -> Piece -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S(LSLL),1*U(A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4bo [Occ=Once!] :: Piece)
                 (z4_a4bp [Occ=Once*!] :: Piece) ->
                 case p_a4bo of
                 { (_ [Occ=Dead], colour_a3ZX [Occ=Once!], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case colour_a3ZX of {
                   Black ->
                     case z4_a4bp of
                     { (_ [Occ=Dead], colour1_X45i [Occ=Once!], _ [Occ=Dead],
                        _ [Occ=Dead]) ->
                     case colour1_X45i of {
                       Black -> GHC.Types.True;
                       White -> GHC.Types.False
                     }
                     };
                   White ->
                     case z4_a4bp of
                     { (_ [Occ=Dead], colour1_X45i [Occ=Once!], _ [Occ=Dead],
                        _ [Occ=Dead]) ->
                     case colour1_X45i of {
                       Black -> GHC.Types.False;
                       White -> GHC.Types.True
                     }
                     }
                 }
                 }}]
isFriendly
  = \ (p_a4bo :: Piece) (z4_a4bp :: Piece) ->
      case p_a4bo of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
      case colour_a3ZX of {
        Black ->
          case z4_a4bp of { (ds3_X57t, colour1_X45i, ds4_X57w, ds5_X57y) ->
          case colour1_X45i of {
            Black -> GHC.Types.True;
            White -> GHC.Types.False
          }
          };
        White ->
          case z4_a4bp of { (ds3_X57t, colour1_X45i, ds4_X57w, ds5_X57y) ->
          case colour1_X45i of {
            Black -> GHC.Types.False;
            White -> GHC.Types.True
          }
          }
      }
      }

-- RHS size: {terms: 27, types: 32, coercions: 0, joins: 0/0}
isEnemy :: Piece -> Piece -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S(LSLL),1*U(A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4bm [Occ=Once!] :: Piece)
                 (z4_a4bn [Occ=Once*!] :: Piece) ->
                 case p_a4bm of
                 { (_ [Occ=Dead], colour_a3ZX [Occ=Once!], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case colour_a3ZX of {
                   Black ->
                     case z4_a4bn of
                     { (_ [Occ=Dead], colour1_X45h [Occ=Once!], _ [Occ=Dead],
                        _ [Occ=Dead]) ->
                     case colour1_X45h of {
                       Black -> GHC.Types.False;
                       White -> GHC.Types.True
                     }
                     };
                   White ->
                     case z4_a4bn of
                     { (_ [Occ=Dead], colour1_X45h [Occ=Once!], _ [Occ=Dead],
                        _ [Occ=Dead]) ->
                     case colour1_X45h of {
                       Black -> GHC.Types.True;
                       White -> GHC.Types.False
                     }
                     }
                 }
                 }}]
isEnemy
  = \ (p_a4bm :: Piece) (z4_a4bn :: Piece) ->
      case p_a4bm of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
      case colour_a3ZX of {
        Black ->
          case z4_a4bn of { (ds3_X57s, colour1_X45h, ds4_X57v, ds5_X57x) ->
          case colour1_X45h of {
            Black -> GHC.Types.False;
            White -> GHC.Types.True
          }
          };
        White ->
          case z4_a4bn of { (ds3_X57s, colour1_X45h, ds4_X57v, ds5_X57x) ->
          case colour1_X45h of {
            Black -> GHC.Types.True;
            White -> GHC.Types.False
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Util.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Util.$trModule2 = "Util"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.$trModule1 = GHC.Types.TrNameS Util.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Util.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Util.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Util.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Util.$trModule3 = GHC.Types.TrNameS Util.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Util.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Util.$trModule = GHC.Types.Module Util.$trModule3 Util.$trModule1

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
getQueensCastle :: Colour -> Pos
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4Sj [Occ=Once!] :: Colour) ->
                 case ds_d4Sj of {
                   Black -> Util.executeCastle4;
                   White -> Util.executeCastle3
                 }}]
getQueensCastle
  = \ (ds_d4Sj :: Colour) ->
      case ds_d4Sj of {
        Black -> Util.executeCastle4;
        White -> Util.executeCastle3
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
getKingsCastle :: Colour -> Pos
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4Ss [Occ=Once!] :: Colour) ->
                 case ds_d4Ss of {
                   Black -> Util.executeCastle2;
                   White -> Util.executeCastle1
                 }}]
getKingsCastle
  = \ (ds_d4Ss :: Colour) ->
      case ds_d4Ss of {
        Black -> Util.executeCastle2;
        White -> Util.executeCastle1
      }

-- RHS size: {terms: 97, types: 80, coercions: 0, joins: 0/0}
possibleToCastle :: Colour -> Bool -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 260 0] 480 80}]
possibleToCastle
  = \ (c_a4g1 :: Colour) (ds_d51q :: Bool) (ps_a4g2 :: AllPieces) ->
      case ds_d51q of {
        False ->
          case findPiece
                 (case c_a4g1 of {
                    Black -> Util.executeCastle4;
                    White -> Util.executeCastle3
                  })
                 ps_a4g2
          of {
            [] -> GHC.Types.False;
            : ds1_a5jz ds2_a5jA ->
              case findPiece (findKing c_a4g1 ps_a4g2) ps_a4g2 of {
                [] -> case GHC.List.badHead of wild3_00 { };
                : x_a4SP ds4_a4SQ ->
                  case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                  case mc_a40p of { GHC.Types.I# x1_a5hr ->
                  case x1_a5hr of {
                    __DEFAULT -> GHC.Types.False;
                    0# ->
                      case ds1_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                      case mc1_X46h of { GHC.Types.I# x2_X5pE ->
                      case x2_X5pE of {
                        __DEFAULT -> GHC.Types.False;
                        0# -> GHC.Types.True
                      }
                      }
                      }
                  }
                  }
                  }
              }
          };
        True ->
          case findPiece
                 (case c_a4g1 of {
                    Black -> Util.executeCastle2;
                    White -> Util.executeCastle1
                  })
                 ps_a4g2
          of {
            [] -> GHC.Types.False;
            : ds1_a5jz ds2_a5jA ->
              case findPiece (findKing c_a4g1 ps_a4g2) ps_a4g2 of {
                [] -> case GHC.List.badHead of wild3_00 { };
                : x_a4SP ds4_a4SQ ->
                  case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                  case mc_a40p of { GHC.Types.I# x1_a5hr ->
                  case x1_a5hr of {
                    __DEFAULT -> GHC.Types.False;
                    0# ->
                      case ds1_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                      case mc1_X46h of { GHC.Types.I# x2_X5pE ->
                      case x2_X5pE of {
                        __DEFAULT -> GHC.Types.False;
                        0# -> GHC.Types.True
                      }
                      }
                      }
                  }
                  }
                  }
              }
          }
      }

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
resetMoveCount :: Piece -> Piece
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U,U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4SB [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d4SB of
                 { (t_a4fV [Occ=Once], c_a4fW [Occ=Once], p_a4fX [Occ=Once],
                    _ [Occ=Dead]) ->
                 (t_a4fV, c_a4fW, p_a4fX, Util.allPiecesMoved1)
                 }}]
resetMoveCount
  = \ (ds_d4SB :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d4SB of { (t_a4fV, c_a4fW, p_a4fX, ds1_d4SK) ->
      (t_a4fV, c_a4fW, p_a4fX, Util.allPiecesMoved1)
      }

-- RHS size: {terms: 54, types: 36, coercions: 0, joins: 0/1}
resetEnemyPawns :: Colour -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 240 0}]
resetEnemyPawns
  = \ (c_a4fY :: Colour) (ps_a4fZ :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Piece;
                : y_a24x ys_a24y ->
                  GHC.Types.:
                    @ Piece
                    (case y_a24x of wild1_X1z
                     { (x_a3ZZ, ds1_d4WW, ds2_d4WX, ds3_d4WY) ->
                     case x_a3ZZ of {
                       Pawn ->
                         case ds1_d4WW of {
                           Black ->
                             case c_a4fY of {
                               Black -> wild1_X1z;
                               White ->
                                 (TypeDefs.Pawn, TypeDefs.Black, ds2_d4WX, Util.allPiecesMoved1)
                             };
                           White ->
                             case c_a4fY of {
                               Black ->
                                 (TypeDefs.Pawn, TypeDefs.White, ds2_d4WX, Util.allPiecesMoved1);
                               White -> wild1_X1z
                             }
                         };
                       Knight -> wild1_X1z;
                       Bishop -> wild1_X1z;
                       Rook -> wild1_X1z;
                       Queen -> wild1_X1z;
                       King -> wild1_X1z
                     }
                     })
                    (go_a24t ys_a24y)
              }; } in
      go_a24t ps_a4fZ

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
getMovecount :: Piece -> Movecount
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),1*U(A,A,A,1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4V5 [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d4V5 of
                 { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], mc_a40p [Occ=Once]) ->
                 mc_a40p
                 }}]
getMovecount
  = \ (ds_d4V5 :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d4V5 of { (ds1_d4Vi, ds2_d4Vj, ds3_d4Vk, mc_a40p) ->
      mc_a40p
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
invertPieceColour :: Piece -> Piece
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4Vu [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d4Vu of
                 { (a_a40l [Occ=Once], colour_a40m [Occ=Once!], pos_a40n [Occ=Once],
                    mc_a40o [Occ=Once]) ->
                 (a_a40l,
                  case colour_a40m of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  },
                  pos_a40n, mc_a40o)
                 }}]
invertPieceColour
  = \ (ds_d4Vu :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d4Vu of { (a_a40l, colour_a40m, pos_a40n, mc_a40o) ->
      (a_a40l,
       case colour_a40m of {
         Black -> TypeDefs.White;
         White -> TypeDefs.Black
       },
       pos_a40n, mc_a40o)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
updateAllPieces :: Piece -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4fd :: Piece) (ps_a4fe [Occ=Once] :: AllPieces) ->
                 GHC.Types.:
                   @ Piece (invertPieceColour p_a4fd) (removePiece p_a4fd ps_a4fe)}]
updateAllPieces
  = \ (p_a4fd :: Piece) (ps_a4fe :: AllPieces) ->
      GHC.Types.:
        @ Piece (invertPieceColour p_a4fd) (removePiece p_a4fd ps_a4fe)

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
invertColour :: Colour -> Colour
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4Vl [Occ=Once!] :: Colour) ->
                 case ds_d4Vl of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 }}]
invertColour
  = \ (ds_d4Vl :: Colour) ->
      case ds_d4Vl of {
        Black -> TypeDefs.White;
        White -> TypeDefs.Black
      }

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
getPieceType :: Piece -> PieceType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4WJ [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d4WJ of
                 { (x_a3ZZ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
                 x_a3ZZ
                 }}]
getPieceType
  = \ (ds_d4WJ :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d4WJ of { (x_a3ZZ, ds1_d4WW, ds2_d4WX, ds3_d4WY) ->
      x_a3ZZ
      }

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
getPos :: Piece -> Pos
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U(U,U),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d4X4 [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d4X4 of
                 { (_ [Occ=Dead], _ [Occ=Dead], pos_a3ZY [Occ=Once],
                    _ [Occ=Dead]) ->
                 pos_a3ZY
                 }}]
getPos
  = \ (ds_d4X4 :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d4X4 of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
      pos_a3ZY
      }

-- RHS size: {terms: 5, types: 14, coercions: 0, joins: 0/0}
getColour :: Piece -> Colour
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d51W [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_d51W of
                 { (_ [Occ=Dead], colour_a3ZX [Occ=Once], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 colour_a3ZX
                 }}]
getColour
  = \ (ds_d51W :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_d51W of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
      colour_a3ZX
      }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
getRow :: Pos -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U(U),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d52A [Occ=Once!] :: (Int, Int)) ->
                 case ds_d52A of { (row_a3ZW [Occ=Once], _ [Occ=Dead]) ->
                 row_a3ZW
                 }}]
getRow
  = \ (ds_d52A :: (Int, Int)) ->
      case ds_d52A of { (row_a3ZW, ds1_d52J) -> row_a3ZW }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
getColumn :: Pos -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d52K [Occ=Once!] :: (Int, Int)) ->
                 case ds_d52K of { (_ [Occ=Dead], col_a3ZV [Occ=Once]) ->
                 col_a3ZV
                 }}]
getColumn
  = \ (ds_d52K :: (Int, Int)) ->
      case ds_d52K of { (ds1_d52T, col_a3ZV) -> col_a3ZV }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
extractPiece :: (Piece, Move, Float) -> Piece
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLL),1*U(1*U(U,U,U,U),A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d5f6 [Occ=Once!] :: (Piece, Move, Float)) ->
                 case ds_d5f6 of
                 { (p_a3ZT [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
                 p_a3ZT
                 }}]
extractPiece
  = \ (ds_d5f6 :: (Piece, Move, Float)) ->
      case ds_d5f6 of { (p_a3ZT, ds1_d5fh, ds2_d5fi) -> p_a3ZT }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
extractMove :: (Piece, Move, Float) -> Move
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSL),1*U(A,1*U(U,U),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d5fj [Occ=Once!] :: (Piece, Move, Float)) ->
                 case ds_d5fj of
                 { (_ [Occ=Dead], m_a3ZS [Occ=Once], _ [Occ=Dead]) ->
                 m_a3ZS
                 }}]
extractMove
  = \ (ds_d5fj :: (Piece, Move, Float)) ->
      case ds_d5fj of { (ds1_d5fu, m_a3ZS, ds2_d5fv) -> m_a3ZS }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
getMoveEval :: (Piece, Move, Float) -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLS),1*U(A,A,1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d5fw [Occ=Once!] :: (Piece, Move, Float)) ->
                 case ds_d5fw of
                 { (_ [Occ=Dead], _ [Occ=Dead], f_a3ZR [Occ=Once]) ->
                 f_a3ZR
                 }}]
getMoveEval
  = \ (ds_d5fw :: (Piece, Move, Float)) ->
      case ds_d5fw of { (ds1_d5fH, ds2_d5fI, f_a3ZR) -> f_a3ZR }

-- RHS size: {terms: 105, types: 44, coercions: 0, joins: 2/2}
$wlvl_rcj9
  :: PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> Bool
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><L,1*U(1*U(U),1*U(U))><L,1*U(U)><S,1*U><L,1*U><L,1*U(1*U(U),1*U(U))><L,1*U(U)>,
 Unf=OtherCon []]
$wlvl_rcj9
  = \ (ww_s8pF :: PieceType)
      (ww1_s8pG :: Colour)
      (ww2_s8pH :: (Int, Int))
      (ww3_s8pI :: Int)
      (ww4_s8pM :: PieceType)
      (ww5_s8pN :: Colour)
      (ww6_s8pO :: (Int, Int))
      (ww7_s8pP :: Int) ->
      join {
        $j_s5NX [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5NX
          = join {
              $j1_s5NT [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5NT
                = case ww2_s8pH of { (ww9_a5iu, ww10_a5iv) ->
                  case ww6_s8pO of { (ww12_a5iA, ww13_a5iB) ->
                  case ww9_a5iu of { GHC.Types.I# x_a5hr ->
                  case ww12_a5iA of { GHC.Types.I# y_a5hu ->
                  case GHC.Prim.==# x_a5hr y_a5hu of {
                    __DEFAULT -> GHC.Types.False;
                    1# ->
                      case ww10_a5iv of { GHC.Types.I# x1_X5pV ->
                      case ww13_a5iB of { GHC.Types.I# y1_X5q3 ->
                      case GHC.Prim.==# x1_X5pV y1_X5q3 of {
                        __DEFAULT -> GHC.Types.False;
                        1# -> GHC.Classes.eqInt ww3_s8pI ww7_s8pP
                      }
                      }
                      }
                  }
                  }
                  }
                  }
                  } } in
            case ww1_s8pG of {
              Black ->
                case ww5_s8pN of {
                  Black -> jump $j1_s5NT;
                  White -> GHC.Types.False
                };
              White ->
                case ww5_s8pN of {
                  Black -> GHC.Types.False;
                  White -> jump $j1_s5NT
                }
            } } in
      case ww_s8pF of {
        Pawn ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            Pawn -> jump $j_s5NX
          };
        Knight ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            Knight -> jump $j_s5NX
          };
        Bishop ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            Bishop -> jump $j_s5NX
          };
        Rook ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            Rook -> jump $j_s5NX
          };
        Queen ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            Queen -> jump $j_s5NX
          };
        King ->
          case ww4_s8pM of {
            __DEFAULT -> GHC.Types.False;
            King -> jump $j_s5NX
          }
      }

-- RHS size: {terms: 17, types: 40, coercions: 0, joins: 0/0}
lvl2_rcja
  :: (PieceType, Colour, (Int, Int), Int)
     -> (PieceType, Colour, (Int, Int), Int) -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,1*U,1*U(1*U(U),1*U(U)),1*U(U))><S(SLLL),1*U(1*U,1*U,1*U(1*U(U),1*U(U)),1*U(U))>,
 Unf=OtherCon []]
lvl2_rcja
  = \ (w_s8pB :: (PieceType, Colour, (Int, Int), Int))
      (w1_s8pC :: (PieceType, Colour, (Int, Int), Int)) ->
      case w_s8pB of { (ww1_s8pF, ww2_s8pG, ww3_s8pH, ww4_s8pI) ->
      case w1_s8pC of { (ww6_s8pM, ww7_s8pN, ww8_s8pO, ww9_s8pP) ->
      $wlvl_rcj9
        ww1_s8pF
        ww2_s8pG
        ww3_s8pH
        ww4_s8pI
        ww6_s8pM
        ww7_s8pN
        ww8_s8pO
        ww9_s8pP
      }
      }

-- RHS size: {terms: 116, types: 77, coercions: 0, joins: 2/2}
Util.$s$fEq(,,,)_$s$fEq(,,,)_$c/= [InlPrag=INLINE (sat-args=2)]
  :: (PieceType, Colour, (Int, Int), Int)
     -> (PieceType, Colour, (Int, Int), Int) -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,1*U,1*U(1*U(U),1*U(U)),1*U(U))><S(SLLL),1*U(1*U,1*U,1*U(1*U(U),1*U(U)),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a5hF [Occ=Once!]
                    :: (PieceType, Colour, (Int, Int), Int))
                 (y_a5hG [Occ=Once!] :: (PieceType, Colour, (Int, Int), Int)) ->
                 case x_a5hF of
                 { (a1_a5hV [Occ=Once!], a2_a5hW [Occ=Once!], a3_a5hX [Occ=Once],
                    a4_a5hY [Occ=Once]) ->
                 case y_a5hG of
                 { (b1_a5i1 [Occ=Once*!], b2_a5i2 [Occ=Once*!], b3_a5i3 [Occ=Once],
                    b4_a5i4 [Occ=Once]) ->
                 join {
                   $j_s5NF [Occ=Once*T[0]] :: Bool
                   [LclId[JoinId(0)]]
                   $j_s5NF
                     = join {
                         $j1_s5NB [Occ=Once*T[0]] :: Bool
                         [LclId[JoinId(0)]]
                         $j1_s5NB
                           = case GHC.Classes.$fEq(,)_$c==
                                    @ Int
                                    @ Int
                                    GHC.Classes.$fEqInt
                                    GHC.Classes.$fEqInt
                                    a3_a5hX
                                    b3_a5i3
                             of {
                               False -> GHC.Types.True;
                               True ->
                                 case GHC.Classes.eqInt a4_a5hY b4_a5i4 of {
                                   False -> GHC.Types.True;
                                   True -> GHC.Types.False
                                 }
                             } } in
                       case a2_a5hW of {
                         Black ->
                           case b2_a5i2 of {
                             Black -> jump $j1_s5NB;
                             White -> GHC.Types.True
                           };
                         White ->
                           case b2_a5i2 of {
                             Black -> GHC.Types.True;
                             White -> jump $j1_s5NB
                           }
                       } } in
                 case a1_a5hV of {
                   Pawn ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       Pawn -> jump $j_s5NF
                     };
                   Knight ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       Knight -> jump $j_s5NF
                     };
                   Bishop ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       Bishop -> jump $j_s5NF
                     };
                   Rook ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       Rook -> jump $j_s5NF
                     };
                   Queen ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       Queen -> jump $j_s5NF
                     };
                   King ->
                     case b1_a5i1 of {
                       __DEFAULT -> GHC.Types.True;
                       King -> jump $j_s5NF
                     }
                 }
                 }
                 }}]
Util.$s$fEq(,,,)_$s$fEq(,,,)_$c/=
  = \ (x_a5hF :: (PieceType, Colour, (Int, Int), Int))
      (y_a5hG :: (PieceType, Colour, (Int, Int), Int)) ->
      case x_a5hF of { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
      case y_a5hG of { (b1_a5i1, b2_a5i2, b3_a5i3, b4_a5i4) ->
      join {
        $j_s5Np [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5Np
          = join {
              $j1_s5Nl [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5Nl
                = case a3_a5hX of { (ww4_a5iu, ww5_a5iv) ->
                  case b3_a5i3 of { (ww7_a5iA, ww8_a5iB) ->
                  case ww4_a5iu of { GHC.Types.I# x1_a5hr ->
                  case ww7_a5iA of { GHC.Types.I# y1_a5hu ->
                  case GHC.Prim.==# x1_a5hr y1_a5hu of {
                    __DEFAULT -> GHC.Types.True;
                    1# ->
                      case ww5_a5iv of { GHC.Types.I# x2_X5pW ->
                      case ww8_a5iB of { GHC.Types.I# y2_X5q4 ->
                      case GHC.Prim.==# x2_X5pW y2_X5q4 of {
                        __DEFAULT -> GHC.Types.True;
                        1# ->
                          case a4_a5hY of { GHC.Types.I# x3_X5q9 ->
                          case b4_a5i4 of { GHC.Types.I# y3_X5qh ->
                          case GHC.Prim.==# x3_X5q9 y3_X5qh of {
                            __DEFAULT -> GHC.Types.True;
                            1# -> GHC.Types.False
                          }
                          }
                          }
                      }
                      }
                      }
                  }
                  }
                  }
                  }
                  } } in
            case a2_a5hW of {
              Black ->
                case b2_a5i2 of {
                  Black -> jump $j1_s5Nl;
                  White -> GHC.Types.True
                };
              White ->
                case b2_a5i2 of {
                  Black -> GHC.Types.True;
                  White -> jump $j1_s5Nl
                }
            } } in
      case a1_a5hV of {
        Pawn ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            Pawn -> jump $j_s5Np
          };
        Knight ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            Knight -> jump $j_s5Np
          };
        Bishop ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            Bishop -> jump $j_s5Np
          };
        Rook ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            Rook -> jump $j_s5Np
          };
        Queen ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            Queen -> jump $j_s5Np
          };
        King ->
          case b1_a5i1 of {
            __DEFAULT -> GHC.Types.True;
            King -> jump $j_s5Np
          }
      }
      }
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Util.$s$fEq(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: (PieceType, Colour, (Int, Int), Int)
                        \ (ds_a5hS [Occ=Once!] :: (PieceType, Colour, (Int, Int), Int))
                          (ds1_a5hT [Occ=Once!] :: (PieceType, Colour, (Int, Int), Int)) ->
                          case ds_a5hS of
                          { (a1_a5hV [Occ=Once!], a2_a5hW [Occ=Once!], a3_a5hX [Occ=Once],
                             a4_a5hY [Occ=Once]) ->
                          case ds1_a5hT of
                          { (b1_a5i1 [Occ=Once*!], b2_a5i2 [Occ=Once*!], b3_a5i3 [Occ=Once],
                             b4_a5i4 [Occ=Once]) ->
                          join {
                            $j_s5Oc [Occ=Once*T[0]] :: Bool
                            [LclId[JoinId(0)]]
                            $j_s5Oc
                              = join {
                                  $j1_s5O8 [Occ=Once*T[0]] :: Bool
                                  [LclId[JoinId(0)]]
                                  $j1_s5O8
                                    = case GHC.Classes.$fEq(,)_$c==
                                             @ Int
                                             @ Int
                                             GHC.Classes.$fEqInt
                                             GHC.Classes.$fEqInt
                                             a3_a5hX
                                             b3_a5i3
                                      of {
                                        False -> GHC.Types.False;
                                        True -> GHC.Classes.eqInt a4_a5hY b4_a5i4
                                      } } in
                                case a2_a5hW of {
                                  Black ->
                                    case b2_a5i2 of {
                                      Black -> jump $j1_s5O8;
                                      White -> GHC.Types.False
                                    };
                                  White ->
                                    case b2_a5i2 of {
                                      Black -> GHC.Types.False;
                                      White -> jump $j1_s5O8
                                    }
                                } } in
                          case a1_a5hV of {
                            Pawn ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                Pawn -> jump $j_s5Oc
                              };
                            Knight ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                Knight -> jump $j_s5Oc
                              };
                            Bishop ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                Bishop -> jump $j_s5Oc
                              };
                            Rook ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                Rook -> jump $j_s5Oc
                              };
                            Queen ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                Queen -> jump $j_s5Oc
                              };
                            King ->
                              case b1_a5i1 of {
                                __DEFAULT -> GHC.Types.False;
                                King -> jump $j_s5Oc
                              }
                          }
                          }
                          }
                        Util.$s$fEq(,,,)_$s$fEq(,,,)_$c/=]
Util.$s$fEq(,,,)
  = GHC.Classes.C:Eq
      @ (PieceType, Colour, (Int, Int), Int)
      lvl2_rcja
      Util.$s$fEq(,,,)_$s$fEq(,,,)_$c/=

-- RHS size: {terms: 8, types: 8, coercions: 0, joins: 0/0}
isEmpty :: Pos -> AllPieces -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U),U(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (pos_a4bk [Occ=Once] :: Pos)
                 (ps_a4bl [Occ=Once] :: AllPieces) ->
                 GHC.Classes.$fEq[]_$c==
                   @ (PieceType, Colour, Pos, Movecount)
                   Util.$s$fEq(,,,)
                   (findPiece pos_a4bk ps_a4bl)
                   (GHC.Types.[] @ Piece)}]
isEmpty
  = \ (pos_a4bk :: Pos) (ps_a4bl :: AllPieces) ->
      GHC.Classes.$fEq[]_$c==
        @ (PieceType, Colour, Pos, Movecount)
        Util.$s$fEq(,,,)
        (findPiece pos_a4bk ps_a4bl)
        (GHC.Types.[] @ Piece)

-- RHS size: {terms: 47, types: 50, coercions: 0, joins: 0/1}
targetNotKing :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*U(1*U(U),1*U(U)),A)><L,1*U(1*U(U),1*U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 20 0] 280 30}]
targetNotKing
  = \ (p_a4he :: Piece) (m_a4hf :: Move) (ps_a4hg :: AllPieces) ->
      let {
        t_s5Jh [Dmd=<L,U(U(U),U(U))>] :: Pos
        [LclId]
        t_s5Jh
          = case p_a4he of { (ds_d4Xh, ds1_d4Xi, pos_a3ZY, ds2_d4Xj) ->
            case pos_a3ZY of { (a_a40e, b_a40f) ->
            case m_a4hf of { (c_a40g, d_a40h) ->
            (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
             GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
            }
            }
            } } in
      case GHC.Classes.$fEq[]_$c==
             @ (PieceType, Colour, Pos, Movecount)
             Util.$s$fEq(,,,)
             (findPiece t_s5Jh ps_a4hg)
             (GHC.Types.[] @ Piece)
      of {
        False ->
          case findPiece t_s5Jh ps_a4hg of {
            [] -> case GHC.List.badHead of wild2_00 { };
            : x_a4SP ds1_a4SQ ->
              case x_a4SP of { (x1_a3ZZ, ds_d4WW, ds2_d4WX, ds3_d4WY) ->
              case x1_a3ZZ of {
                __DEFAULT -> GHC.Types.True;
                King -> GHC.Types.False
              }
              }
          };
        True -> GHC.Types.True
      }

-- RHS size: {terms: 71, types: 78, coercions: 0, joins: 0/1}
isTargetEnemy :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U(A,1*U,1*U(1*U(U),1*U(U)),A)><L,1*U(1*U(U),1*U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 20 0] 390 50}]
isTargetEnemy
  = \ (p_a4cN :: Piece) (move_a4cO :: Move) (ps_a4cP :: AllPieces) ->
      let {
        t_s5Jf [Dmd=<L,U(U(U),U(U))>] :: Pos
        [LclId]
        t_s5Jf
          = case p_a4cN of { (ds_d4Xh, ds1_d4Xi, pos_a3ZY, ds2_d4Xj) ->
            case pos_a3ZY of { (a_a40e, b_a40f) ->
            case move_a4cO of { (c_a40g, d_a40h) ->
            (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
             GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
            }
            }
            } } in
      case GHC.Classes.$fEq[]_$c==
             @ (PieceType, Colour, Pos, Movecount)
             Util.$s$fEq(,,,)
             (findPiece t_s5Jf ps_a4cP)
             (GHC.Types.[] @ Piece)
      of {
        False ->
          case p_a4cN of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
          case colour_a3ZX of {
            Black ->
              case findPiece t_s5Jf ps_a4cP of {
                [] -> case GHC.List.badHead of wild4_00 { };
                : x_a4SP ds3_a4SQ ->
                  case x_a4SP of { (ds4_X58b, colour1_X460, ds5_X58e, ds6_X58g) ->
                  case colour1_X460 of {
                    Black -> GHC.Types.False;
                    White -> GHC.Types.True
                  }
                  }
              };
            White ->
              case findPiece t_s5Jf ps_a4cP of {
                [] -> case GHC.List.badHead of wild4_00 { };
                : x_a4SP ds3_a4SQ ->
                  case x_a4SP of { (ds4_X58b, colour1_X460, ds5_X58e, ds6_X58g) ->
                  case colour1_X460 of {
                    Black -> GHC.Types.True;
                    White -> GHC.Types.False
                  }
                  }
              }
          }
          };
        True -> GHC.Types.False
      }

-- RHS size: {terms: 216, types: 117, coercions: 0, joins: 3/3}
Util.$wisValidEnPassant [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> GHC.Prim.Int# -> Int -> AllPieces -> Bool
[GblId,
 Arity=5,
 Str=<S,U><L,U(U(U),U(U))><S,1*U><L,U(U)><L,U>,
 Unf=OtherCon []]
Util.$wisValidEnPassant
  = \ (ww_s8q4 :: Colour)
      (ww1_s8q5 :: Pos)
      (ww2_s8qd :: GHC.Prim.Int#)
      (ww3_s8qf :: Int)
      (w_s8q0 :: AllPieces) ->
      join {
        $j_s6Hv [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s6Hv
          = join {
              $j1_s5RI [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5RI
                = case GHC.Classes.$fEq[]_$c==
                         @ (PieceType, Colour, Pos, Movecount)
                         Util.$s$fEq(,,,)
                         (findPiece
                            (case ww1_s8q5 of { (a_a40e, b_a40f) ->
                             (a_a40e,
                              case b_a40f of { GHC.Types.I# x_a5kQ ->
                              case ww3_s8qf of { GHC.Types.I# y_a5kT ->
                              GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                              }
                              })
                             })
                            w_s8q0)
                         (GHC.Types.[] @ Piece)
                  of {
                    False ->
                      case findPiece
                             (case ww1_s8q5 of { (a_a40e, b_a40f) ->
                              (a_a40e,
                               case b_a40f of { GHC.Types.I# x_a5kQ ->
                               case ww3_s8qf of { GHC.Types.I# y_a5kT ->
                               GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                               }
                               })
                              })
                             w_s8q0
                      of {
                        [] -> case GHC.List.badHead of wild2_00 { };
                        : x_a4SP ds1_a4SQ ->
                          case x_a4SP of { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
                          case a1_a5hV of {
                            Pawn ->
                              join {
                                $j2_s5RA [Dmd=<L,1*U>] :: Bool
                                [LclId[JoinId(0)]]
                                $j2_s5RA
                                  = case a3_a5hX of { (ww5_a5iu, ww6_a5iv) ->
                                    case ww5_a5iu of { GHC.Types.I# x1_a5hr ->
                                    case ww1_s8q5 of { (row_a3ZW, ds_d52J) ->
                                    case row_a3ZW of { GHC.Types.I# y_a5hu ->
                                    case GHC.Prim.==# x1_a5hr y_a5hu of {
                                      __DEFAULT -> GHC.Types.False;
                                      1# ->
                                        case ds_d52J of { GHC.Types.I# x2_a5kQ ->
                                        case ww3_s8qf of { GHC.Types.I# y1_a5kT ->
                                        case ww6_a5iv of { GHC.Types.I# x3_X5qH ->
                                        case GHC.Prim.==# x3_X5qH (GHC.Prim.+# x2_a5kQ y1_a5kT) of {
                                          __DEFAULT -> GHC.Types.False;
                                          1# ->
                                            case a4_a5hY of { GHC.Types.I# x4_X5qQ ->
                                            case x4_X5qQ of {
                                              __DEFAULT -> GHC.Types.False;
                                              2# -> GHC.Types.True
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }
                                    }
                                    }
                                    }
                                    } } in
                              case a2_a5hW of {
                                Black ->
                                  case ww_s8q4 of {
                                    Black -> GHC.Types.False;
                                    White -> jump $j2_s5RA
                                  };
                                White ->
                                  case ww_s8q4 of {
                                    Black -> jump $j2_s5RA;
                                    White -> GHC.Types.False
                                  }
                              };
                            Knight -> GHC.Types.False;
                            Bishop -> GHC.Types.False;
                            Rook -> GHC.Types.False;
                            Queen -> GHC.Types.False;
                            King -> GHC.Types.False
                          }
                          }
                      };
                    True -> GHC.Types.False
                  } } in
            case ww_s8q4 of {
              Black ->
                case ww1_s8q5 of { (row_a3ZW, ds_d52J) ->
                case row_a3ZW of { GHC.Types.I# x_a5hr ->
                case x_a5hr of {
                  __DEFAULT -> GHC.Types.False;
                  4# -> jump $j1_s5RI
                }
                }
                };
              White ->
                case ww1_s8q5 of { (row_a3ZW, ds_d52J) ->
                case row_a3ZW of { GHC.Types.I# x_a5hr ->
                case x_a5hr of {
                  __DEFAULT -> GHC.Types.False;
                  3# -> jump $j1_s5RI
                }
                }
                }
            } } in
      case ww_s8q4 of {
        Black ->
          case ww2_s8qd of {
            __DEFAULT -> GHC.Types.False;
            1# ->
              case ww3_s8qf of { GHC.Types.I# x_a5ky ->
              case GHC.Prim.>=# x_a5ky 0# of {
                __DEFAULT ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    -1# -> jump $j_s6Hv
                  };
                1# ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    1# -> jump $j_s6Hv
                  }
              }
              }
          };
        White ->
          case ww2_s8qd of {
            __DEFAULT -> GHC.Types.False;
            -1# ->
              case ww3_s8qf of { GHC.Types.I# x_a5ky ->
              case GHC.Prim.>=# x_a5ky 0# of {
                __DEFAULT ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    -1# -> jump $j_s6Hv
                  };
                1# ->
                  case x_a5ky of {
                    __DEFAULT -> GHC.Types.False;
                    1# -> jump $j_s6Hv
                  }
              }
              }
          }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
isValidEnPassant [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S(LSLL),1*U(A,U,U(U(U),U(U)),A)><S(S(S)L),1*U(1*U(1*U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8pY [Occ=Once!] :: Piece)
                 (w1_s8pZ [Occ=Once!] :: Move)
                 (w2_s8q0 [Occ=Once] :: AllPieces) ->
                 case w_s8pY of
                 { (_ [Occ=Dead], ww2_s8q4 [Occ=Once], ww3_s8q5 [Occ=Once],
                    _ [Occ=Dead]) ->
                 case w1_s8pZ of { (ww6_s8qa [Occ=Once!], ww7_s8qf [Occ=Once]) ->
                 case ww6_s8qa of { GHC.Types.I# ww9_s8qd [Occ=Once] ->
                 Util.$wisValidEnPassant ww2_s8q4 ww3_s8q5 ww9_s8qd ww7_s8qf w2_s8q0
                 }
                 }
                 }}]
isValidEnPassant
  = \ (w_s8pY :: Piece) (w1_s8pZ :: Move) (w2_s8q0 :: AllPieces) ->
      case w_s8pY of { (ww1_s8q3, ww2_s8q4, ww3_s8q5, ww4_s8q6) ->
      case w1_s8pZ of { (ww6_s8qa, ww7_s8qf) ->
      case ww6_s8qa of { GHC.Types.I# ww9_s8qd ->
      Util.$wisValidEnPassant ww2_s8q4 ww3_s8q5 ww9_s8qd ww7_s8qf w2_s8q0
      }
      }
      }

Rec {
-- RHS size: {terms: 86, types: 33, coercions: 0, joins: 1/1}
Util.$wisDiagonalMovePathEmpty [InlPrag=NOUSERINLINE[2],
                                Occ=LoopBreaker]
  :: Pos -> GHC.Prim.Int# -> Int -> AllPieces -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(U),U(U))><S,U><L,U(U)><L,U>,
 Unf=OtherCon []]
Util.$wisDiagonalMovePathEmpty
  = \ (w_s8qj :: Pos)
      (ww_s8qr :: GHC.Prim.Int#)
      (ww1_s8qt :: Int)
      (w1_s8ql :: AllPieces) ->
      join {
        fail_s5IZ [Dmd=<L,1*C1(U)>] :: GHC.Prim.Void# -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_s5IZ _ [Occ=Dead, OS=OneShot]
          = case GHC.Classes.$fEq[]_$c==
                   @ (PieceType, Colour, Pos, Movecount)
                   Util.$s$fEq(,,,)
                   (findPiece
                      (case w_s8qj of { (a_a40e, b_a40f) ->
                       (case a_a40e of { GHC.Types.I# x_a5kQ ->
                        GHC.Types.I# (GHC.Prim.+# x_a5kQ ww_s8qr)
                        },
                        case b_a40f of { GHC.Types.I# x_a5kQ ->
                        case ww1_s8qt of { GHC.Types.I# y_a5kT ->
                        GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                        }
                        })
                       })
                      w1_s8ql)
                   (GHC.Types.[] @ Piece)
            of {
              False -> GHC.Types.False;
              True ->
                case GHC.Prim.<# ww_s8qr 0# of {
                  __DEFAULT ->
                    case GHC.Prim.># ww_s8qr 0# of {
                      __DEFAULT ->
                        Util.$wisDiagonalMovePathEmpty
                          w_s8qj ww_s8qr (closerToZero ww1_s8qt) w1_s8ql;
                      1# ->
                        Util.$wisDiagonalMovePathEmpty
                          w_s8qj (GHC.Prim.-# ww_s8qr 1#) (closerToZero ww1_s8qt) w1_s8ql
                    };
                  1# ->
                    Util.$wisDiagonalMovePathEmpty
                      w_s8qj (GHC.Prim.+# ww_s8qr 1#) (closerToZero ww1_s8qt) w1_s8ql
                }
            } } in
      case ww_s8qr of {
        __DEFAULT -> jump fail_s5IZ GHC.Prim.void#;
        0# ->
          case ww1_s8qt of { GHC.Types.I# ds1_d4XP ->
          case ds1_d4XP of {
            __DEFAULT -> jump fail_s5IZ GHC.Prim.void#;
            0# -> GHC.Types.True
          }
          }
      }
end Rec }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
isDiagonalMovePathEmpty [InlPrag=NOUSERINLINE[2]]
  :: Pos -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(U),U(U))><S(S(S)L),1*U(1*U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8qj [Occ=Once] :: Pos)
                 (w1_s8qk [Occ=Once!] :: Move)
                 (w2_s8ql [Occ=Once] :: AllPieces) ->
                 case w1_s8qk of { (ww1_s8qo [Occ=Once!], ww2_s8qt [Occ=Once]) ->
                 case ww1_s8qo of { GHC.Types.I# ww4_s8qr [Occ=Once] ->
                 Util.$wisDiagonalMovePathEmpty w_s8qj ww4_s8qr ww2_s8qt w2_s8ql
                 }
                 }}]
isDiagonalMovePathEmpty
  = \ (w_s8qj :: Pos) (w1_s8qk :: Move) (w2_s8ql :: AllPieces) ->
      case w1_s8qk of { (ww1_s8qo, ww2_s8qt) ->
      case ww1_s8qo of { GHC.Types.I# ww4_s8qr ->
      Util.$wisDiagonalMovePathEmpty w_s8qj ww4_s8qr ww2_s8qt w2_s8ql
      }
      }

Rec {
-- RHS size: {terms: 121, types: 39, coercions: 0, joins: 0/0}
Util.clearCastlePath_$s$wisStraightMovePathEmpty [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> Int -> Bool
[GblId,
 Arity=5,
 Str=<L,U><S,1*U><S,1*U><L,U><L,U(U)>,
 Unf=OtherCon []]
Util.clearCastlePath_$s$wisStraightMovePathEmpty
  = \ (sc_saCW :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saCV :: GHC.Prim.Int#)
      (sc2_saCU :: GHC.Prim.Int#)
      (sc3_saCS :: GHC.Prim.Int#)
      (sc4_saCT :: Int) ->
      case sc2_saCU of ds_X4ZR {
        __DEFAULT ->
          case sc1_saCV of {
            __DEFAULT -> lvl1_rcj8;
            0# ->
              case GHC.Classes.$fEq[]_$c==
                     @ (PieceType, Colour, Pos, Movecount)
                     Util.$s$fEq(,,,)
                     (findPiece
                        (GHC.Types.I# (GHC.Prim.+# sc3_saCS ds_X4ZR), sc4_saCT) sc_saCW)
                     (GHC.Types.[] @ Piece)
              of {
                False -> GHC.Types.False;
                True ->
                  case GHC.Prim.<# ds_X4ZR 0# of {
                    __DEFAULT ->
                      case GHC.Prim.># ds_X4ZR 0# of {
                        __DEFAULT ->
                          Util.clearCastlePath_$s$wisStraightMovePathEmpty
                            sc_saCW 0# ds_X4ZR sc3_saCS sc4_saCT;
                        1# ->
                          Util.clearCastlePath_$s$wisStraightMovePathEmpty
                            sc_saCW 0# (GHC.Prim.-# ds_X4ZR 1#) sc3_saCS sc4_saCT
                      };
                    1# ->
                      Util.clearCastlePath_$s$wisStraightMovePathEmpty
                        sc_saCW 0# (GHC.Prim.+# ds_X4ZR 1#) sc3_saCS sc4_saCT
                  }
              }
          };
        0# ->
          case sc1_saCV of ds1_X4ZV {
            __DEFAULT ->
              case GHC.Classes.$fEq[]_$c==
                     @ (PieceType, Colour, Pos, Movecount)
                     Util.$s$fEq(,,,)
                     (findPiece
                        (GHC.Types.I# sc3_saCS,
                         case sc4_saCT of { GHC.Types.I# x_a5kQ ->
                         GHC.Types.I# (GHC.Prim.+# x_a5kQ ds1_X4ZV)
                         })
                        sc_saCW)
                     (GHC.Types.[] @ Piece)
              of {
                False -> GHC.Types.False;
                True ->
                  case GHC.Prim.<# ds1_X4ZV 0# of {
                    __DEFAULT ->
                      case GHC.Prim.># ds1_X4ZV 0# of {
                        __DEFAULT ->
                          Util.clearCastlePath_$s$wisStraightMovePathEmpty
                            sc_saCW ds1_X4ZV 0# sc3_saCS sc4_saCT;
                        1# ->
                          Util.clearCastlePath_$s$wisStraightMovePathEmpty
                            sc_saCW (GHC.Prim.-# ds1_X4ZV 1#) 0# sc3_saCS sc4_saCT
                      };
                    1# ->
                      Util.clearCastlePath_$s$wisStraightMovePathEmpty
                        sc_saCW (GHC.Prim.+# ds1_X4ZV 1#) 0# sc3_saCS sc4_saCT
                  }
              };
            0# -> GHC.Types.True
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 122, types: 43, coercions: 0, joins: 0/0}
Util.$wisStraightMovePathEmpty [InlPrag=NOUSERINLINE[2],
                                Occ=LoopBreaker]
  :: Pos -> GHC.Prim.Int# -> GHC.Prim.Int# -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,U(U(U),U(U))><S,1*U><S,1*U><L,U>,
 Unf=OtherCon []]
Util.$wisStraightMovePathEmpty
  = \ (w_s8qw :: Pos)
      (ww_s8qE :: GHC.Prim.Int#)
      (ww1_s8qJ :: GHC.Prim.Int#)
      (w1_s8qy :: AllPieces) ->
      case ww_s8qE of ds_X4ZR {
        __DEFAULT ->
          case ww1_s8qJ of {
            __DEFAULT -> lvl1_rcj8;
            0# ->
              case GHC.Classes.$fEq[]_$c==
                     @ (PieceType, Colour, Pos, Movecount)
                     Util.$s$fEq(,,,)
                     (findPiece
                        (case w_s8qw of { (a_a40e, b_a40f) ->
                         (case a_a40e of { GHC.Types.I# x_a5kQ ->
                          GHC.Types.I# (GHC.Prim.+# x_a5kQ ds_X4ZR)
                          },
                          b_a40f)
                         })
                        w1_s8qy)
                     (GHC.Types.[] @ Piece)
              of {
                False -> GHC.Types.False;
                True ->
                  case GHC.Prim.<# ds_X4ZR 0# of {
                    __DEFAULT ->
                      case GHC.Prim.># ds_X4ZR 0# of {
                        __DEFAULT ->
                          Util.$wisStraightMovePathEmpty w_s8qw ds_X4ZR 0# w1_s8qy;
                        1# ->
                          Util.$wisStraightMovePathEmpty
                            w_s8qw (GHC.Prim.-# ds_X4ZR 1#) 0# w1_s8qy
                      };
                    1# ->
                      Util.$wisStraightMovePathEmpty
                        w_s8qw (GHC.Prim.+# ds_X4ZR 1#) 0# w1_s8qy
                  }
              }
          };
        0# ->
          case ww1_s8qJ of ds1_X4ZV {
            __DEFAULT ->
              case GHC.Classes.$fEq[]_$c==
                     @ (PieceType, Colour, Pos, Movecount)
                     Util.$s$fEq(,,,)
                     (findPiece
                        (case w_s8qw of { (a_a40e, b_a40f) ->
                         (a_a40e,
                          case b_a40f of { GHC.Types.I# x_a5kQ ->
                          GHC.Types.I# (GHC.Prim.+# x_a5kQ ds1_X4ZV)
                          })
                         })
                        w1_s8qy)
                     (GHC.Types.[] @ Piece)
              of {
                False -> GHC.Types.False;
                True ->
                  case GHC.Prim.<# ds1_X4ZV 0# of {
                    __DEFAULT ->
                      case GHC.Prim.># ds1_X4ZV 0# of {
                        __DEFAULT ->
                          Util.$wisStraightMovePathEmpty w_s8qw 0# ds1_X4ZV w1_s8qy;
                        1# ->
                          Util.$wisStraightMovePathEmpty
                            w_s8qw 0# (GHC.Prim.-# ds1_X4ZV 1#) w1_s8qy
                      };
                    1# ->
                      Util.$wisStraightMovePathEmpty
                        w_s8qw 0# (GHC.Prim.+# ds1_X4ZV 1#) w1_s8qy
                  }
              };
            0# -> GHC.Types.True
          }
      }
end Rec }

-- RHS size: {terms: 17, types: 10, coercions: 0, joins: 0/0}
isStraightMovePathEmpty [InlPrag=NOUSERINLINE[2]]
  :: Pos -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U(U(U),U(U))><S(S(S)S(S)),1*U(1*U(1*U),1*U(1*U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8qw [Occ=Once] :: Pos)
                 (w1_s8qx [Occ=Once!] :: Move)
                 (w2_s8qy [Occ=Once] :: AllPieces) ->
                 case w1_s8qx of { (ww1_s8qB [Occ=Once!], ww2_s8qG [Occ=Once!]) ->
                 case ww1_s8qB of { GHC.Types.I# ww4_s8qE [Occ=Once] ->
                 case ww2_s8qG of { GHC.Types.I# ww6_s8qJ [Occ=Once] ->
                 Util.$wisStraightMovePathEmpty w_s8qw ww4_s8qE ww6_s8qJ w2_s8qy
                 }
                 }
                 }}]
isStraightMovePathEmpty
  = \ (w_s8qw :: Pos) (w1_s8qx :: Move) (w2_s8qy :: AllPieces) ->
      case w1_s8qx of { (ww1_s8qB, ww2_s8qG) ->
      case ww1_s8qB of { GHC.Types.I# ww4_s8qE ->
      case ww2_s8qG of { GHC.Types.I# ww6_s8qJ ->
      Util.$wisStraightMovePathEmpty w_s8qw ww4_s8qE ww6_s8qJ w2_s8qy
      }
      }
      }

-- RHS size: {terms: 114, types: 33, coercions: 0, joins: 0/0}
Util.$wisBasicPawnMove [InlPrag=NOUSERINLINE[2]]
  :: Colour
     -> GHC.Prim.Int#
     -> Int
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> Bool
[GblId,
 Arity=6,
 Str=<S,1*U><S,1*U><L,U(U)><S,1*U><L,1*U(1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [270 160 0 200 120 0] 500 180}]
Util.$wisBasicPawnMove
  = \ (ww_s8qT :: Colour)
      (ww1_s8r0 :: GHC.Prim.Int#)
      (ww2_s8r2 :: Int)
      (ww3_s8rb :: GHC.Prim.Int#)
      (ww4_s8rd :: Int)
      (w_s8qP :: AllPieces) ->
      case ww_s8qT of {
        Black ->
          case ww1_s8r0 of {
            __DEFAULT ->
              case ww3_s8rb of {
                __DEFAULT -> GHC.Types.False;
                1# ->
                  case ww4_s8rd of { GHC.Types.I# x_X5q2 ->
                  case x_X5q2 of {
                    __DEFAULT -> GHC.Types.False;
                    0# -> GHC.Types.True
                  }
                  }
              };
            1# ->
              case ww3_s8rb of {
                __DEFAULT -> GHC.Types.False;
                1# ->
                  case ww4_s8rd of { GHC.Types.I# x_X5q4 ->
                  case x_X5q4 of {
                    __DEFAULT -> GHC.Types.False;
                    0# -> GHC.Types.True
                  }
                  };
                2# ->
                  case Util.clearCastlePath_$s$wisStraightMovePathEmpty
                         w_s8qP 0# 2# 1# ww2_s8r2
                  of {
                    False -> GHC.Types.False;
                    True ->
                      case ww4_s8rd of { GHC.Types.I# x_X5q8 ->
                      case x_X5q8 of {
                        __DEFAULT -> GHC.Types.False;
                        0# -> GHC.Types.True
                      }
                      }
                  }
              }
          };
        White ->
          case ww1_s8r0 of {
            __DEFAULT ->
              case ww3_s8rb of {
                __DEFAULT -> GHC.Types.False;
                -1# ->
                  case ww4_s8rd of { GHC.Types.I# x_X5q2 ->
                  case x_X5q2 of {
                    __DEFAULT -> GHC.Types.False;
                    0# -> GHC.Types.True
                  }
                  }
              };
            6# ->
              case ww3_s8rb of {
                __DEFAULT -> GHC.Types.False;
                -2# ->
                  case Util.clearCastlePath_$s$wisStraightMovePathEmpty
                         w_s8qP 0# -2# 6# ww2_s8r2
                  of {
                    False -> GHC.Types.False;
                    True ->
                      case ww4_s8rd of { GHC.Types.I# x_X5q8 ->
                      case x_X5q8 of {
                        __DEFAULT -> GHC.Types.False;
                        0# -> GHC.Types.True
                      }
                      }
                  };
                -1# ->
                  case ww4_s8rd of { GHC.Types.I# x_X5q4 ->
                  case x_X5q4 of {
                    __DEFAULT -> GHC.Types.False;
                    0# -> GHC.Types.True
                  }
                  }
              }
          }
      }

-- RHS size: {terms: 25, types: 18, coercions: 0, joins: 0/0}
isBasicPawnMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S(LSS(S(S)L)L),1*U(A,1*U,1*U(1*U(1*U),U(U)),A)><S(S(S)L),1*U(1*U(1*U),1*U(1*U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8qN [Occ=Once!] :: Piece)
                 (w1_s8qO [Occ=Once!] :: Move)
                 (w2_s8qP [Occ=Once] :: AllPieces) ->
                 case w_s8qN of
                 { (_ [Occ=Dead], ww2_s8qT [Occ=Once], ww3_s8qU [Occ=Once!],
                    _ [Occ=Dead]) ->
                 case ww3_s8qU of { (ww6_s8qX [Occ=Once!], ww7_s8r2 [Occ=Once]) ->
                 case ww6_s8qX of { GHC.Types.I# ww9_s8r0 [Occ=Once] ->
                 case w1_s8qO of { (ww11_s8r8 [Occ=Once!], ww12_s8rd [Occ=Once]) ->
                 case ww11_s8r8 of { GHC.Types.I# ww14_s8rb [Occ=Once] ->
                 Util.$wisBasicPawnMove
                   ww2_s8qT ww9_s8r0 ww7_s8r2 ww14_s8rb ww12_s8rd w2_s8qP
                 }
                 }
                 }
                 }
                 }}]
isBasicPawnMove
  = \ (w_s8qN :: Piece) (w1_s8qO :: Move) (w2_s8qP :: AllPieces) ->
      case w_s8qN of { (ww1_s8qS, ww2_s8qT, ww3_s8qU, ww4_s8r4) ->
      case ww3_s8qU of { (ww6_s8qX, ww7_s8r2) ->
      case ww6_s8qX of { GHC.Types.I# ww9_s8r0 ->
      case w1_s8qO of { (ww11_s8r8, ww12_s8rd) ->
      case ww11_s8r8 of { GHC.Types.I# ww14_s8rb ->
      Util.$wisBasicPawnMove
        ww2_s8qT ww9_s8r0 ww7_s8r2 ww14_s8rb ww12_s8rd w2_s8qP
      }
      }
      }
      }
      }

-- RHS size: {terms: 132, types: 84, coercions: 0, joins: 1/4}
Util.$wisValidTarget [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> Move -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,1*U><L,U(U(U),U(U))><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [112 40 40 0] 562 20}]
Util.$wisValidTarget
  = \ (ww_s8rm :: Colour)
      (ww1_s8rn :: Pos)
      (w_s8rh :: Move)
      (w1_s8ri :: AllPieces) ->
      let {
        t_s5IQ [Dmd=<L,U(U(U),U(U))>] :: Pos
        [LclId]
        t_s5IQ
          = case ww1_s8rn of { (a_a40e, b_a40f) ->
            case w_s8rh of { (c_a40g, d_a40h) ->
            (GHC.Num.$fNumInt_$c+ a_a40e c_a40g,
             GHC.Num.$fNumInt_$c+ b_a40f d_a40h)
            }
            } } in
      join {
        $j_s5TC [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5TC
          = case ww1_s8rn of { (ww3_s8mm, ww4_s8mr) ->
            case ww3_s8mm of { GHC.Types.I# ww6_s8mp ->
            case w_s8rh of { (ww8_s8mx, ww9_s8mC) ->
            case ww8_s8mx of { GHC.Types.I# ww11_s8mA ->
            let {
              x_a5nX :: GHC.Prim.Int#
              [LclId]
              x_a5nX = GHC.Prim.+# ww6_s8mp ww11_s8mA } in
            case GHC.Prim.>=# x_a5nX 0# of {
              __DEFAULT -> GHC.Types.False;
              1# ->
                case GHC.Prim.<=# x_a5nX 7# of {
                  __DEFAULT -> GHC.Types.False;
                  1# ->
                    case ww4_s8mr of { GHC.Types.I# x1_X5qe ->
                    case ww9_s8mC of { GHC.Types.I# y_X5qm ->
                    let {
                      x2_X5uf :: GHC.Prim.Int#
                      [LclId]
                      x2_X5uf = GHC.Prim.+# x1_X5qe y_X5qm } in
                    case GHC.Prim.>=# x2_X5uf 0# of {
                      __DEFAULT -> GHC.Types.False;
                      1# ->
                        case GHC.Prim.<=# x2_X5uf 7# of {
                          __DEFAULT -> GHC.Types.False;
                          1# ->
                            case ww6_s8mp of {
                              __DEFAULT -> GHC.Types.True;
                              -1# ->
                                case x1_X5qe of {
                                  __DEFAULT -> GHC.Types.True;
                                  -1# -> GHC.Types.False
                                }
                            }
                        }
                    }
                    }
                    }
                }
            }
            }
            }
            }
            } } in
      case GHC.Classes.$fEq[]_$c==
             @ (PieceType, Colour, Pos, Movecount)
             Util.$s$fEq(,,,)
             (findPiece t_s5IQ w1_s8ri)
             (GHC.Types.[] @ Piece)
      of {
        False ->
          case ww_s8rm of {
            Black ->
              case findPiece t_s5IQ w1_s8ri of {
                [] -> case GHC.List.badHead of wild3_00 { };
                : x_a4SP ds1_a4SQ ->
                  case x_a4SP of { (ds_X59o, colour_X47d, ds2_X59r, ds3_X59t) ->
                  case colour_X47d of {
                    Black -> GHC.Types.False;
                    White -> jump $j_s5TC
                  }
                  }
              };
            White ->
              case findPiece t_s5IQ w1_s8ri of {
                [] -> case GHC.List.badHead of wild3_00 { };
                : x_a4SP ds1_a4SQ ->
                  case x_a4SP of { (ds_X59o, colour_X47d, ds2_X59r, ds3_X59t) ->
                  case colour_X47d of {
                    Black -> jump $j_s5TC;
                    White -> GHC.Types.False
                  }
                  }
              }
          };
        True -> jump $j_s5TC
      }

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
isValidTarget [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S,1*U(A,1*U,U(U(U),U(U)),A)><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8rg [Occ=Once!] :: Piece)
                 (w1_s8rh [Occ=Once] :: Move)
                 (w2_s8ri [Occ=Once] :: AllPieces) ->
                 case w_s8rg of
                 { (_ [Occ=Dead], ww2_s8rm [Occ=Once], ww3_s8rn [Occ=Once],
                    _ [Occ=Dead]) ->
                 Util.$wisValidTarget ww2_s8rm ww3_s8rn w1_s8rh w2_s8ri
                 }}]
isValidTarget
  = \ (w_s8rg :: Piece) (w1_s8rh :: Move) (w2_s8ri :: AllPieces) ->
      case w_s8rg of { (ww1_s8rl, ww2_s8rm, ww3_s8rn, ww4_s8ro) ->
      Util.$wisValidTarget ww2_s8rm ww3_s8rn w1_s8rh w2_s8ri
      }

-- RHS size: {terms: 17, types: 9, coercions: 0, joins: 0/0}
isKnightValidMove :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S,1*U(A,1*U,U(U(U),U(U)),A)><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4e5 [Occ=Once] :: Piece)
                 (move_a4e6 :: Move)
                 (ps_a4e7 [Occ=Once] :: AllPieces) ->
                 case isValidTarget p_a4e5 move_a4e6 ps_a4e7 of {
                   False -> GHC.Types.False;
                   True -> isLShaped move_a4e6
                 }}]
isKnightValidMove
  = \ (p_a4e5 :: Piece) (move_a4e6 :: Move) (ps_a4e7 :: AllPieces) ->
      case p_a4e5 of { (ww1_s8rl, ww2_s8rm, ww3_s8rn, ww4_s8ro) ->
      case Util.$wisValidTarget ww2_s8rm ww3_s8rn move_a4e6 ps_a4e7 of {
        False -> GHC.Types.False;
        True -> isLShaped move_a4e6
      }
      }

-- RHS size: {terms: 126, types: 28, coercions: 0, joins: 2/3}
Util.$wisBishopValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> GHC.Prim.Int# -> GHC.Prim.Int# -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*U,U(U(U),U(U)),A)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0 0] 449 40}]
Util.$wisBishopValidMove
  = \ (w_s8rr :: Piece)
      (ww_s8rz :: GHC.Prim.Int#)
      (ww1_s8rE :: GHC.Prim.Int#)
      (w1_s8rt :: AllPieces) ->
      join {
        $j_s8Gk [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s8Gk
          = case w_s8rr of { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
            let {
              move_s8Gc [Dmd=<L,U(U)>] :: Int
              [LclId, Unf=OtherCon []]
              move_s8Gc = GHC.Types.I# ww1_s8rE } in
            case Util.$wisValidTarget
                   ww4_s8rm ww5_s8rn (GHC.Types.I# ww_s8rz, move_s8Gc) w1_s8rt
            of {
              False -> GHC.Types.False;
              True ->
                join {
                  $j1_s8W5 [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> Bool
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                  $j1_s8W5 (ww7_s8qr [OS=OneShot] :: GHC.Prim.Int#)
                    = Util.$wisDiagonalMovePathEmpty
                        ww5_s8rn
                        ww7_s8qr
                        (case GHC.Prim.<# ww1_s8rE 0# of {
                           __DEFAULT ->
                             case GHC.Prim.># ww1_s8rE 0# of {
                               __DEFAULT -> move_s8Gc;
                               1# -> GHC.Types.I# (GHC.Prim.-# ww1_s8rE 1#)
                             };
                           1# -> GHC.Types.I# (GHC.Prim.+# ww1_s8rE 1#)
                         })
                        w1_s8rt } in
                case GHC.Prim.<# ww_s8rz 0# of {
                  __DEFAULT ->
                    case GHC.Prim.># ww_s8rz 0# of {
                      __DEFAULT -> jump $j1_s8W5 ww_s8rz;
                      1# -> jump $j1_s8W5 (GHC.Prim.-# ww_s8rz 1#)
                    };
                  1# -> jump $j1_s8W5 (GHC.Prim.+# ww_s8rz 1#)
                }
            }
            } } in
      case GHC.Prim.>=# ww_s8rz 0# of {
        __DEFAULT ->
          case GHC.Prim.>=# ww1_s8rE 0# of {
            __DEFAULT ->
              case GHC.Prim.==#
                     (GHC.Prim.negateInt# ww_s8rz) (GHC.Prim.negateInt# ww1_s8rE)
              of {
                __DEFAULT -> GHC.Types.False;
                1# -> jump $j_s8Gk
              };
            1# ->
              case GHC.Prim.==# (GHC.Prim.negateInt# ww_s8rz) ww1_s8rE of {
                __DEFAULT -> GHC.Types.False;
                1# -> jump $j_s8Gk
              }
          };
        1# ->
          case GHC.Prim.>=# ww1_s8rE 0# of {
            __DEFAULT ->
              case GHC.Prim.==# ww_s8rz (GHC.Prim.negateInt# ww1_s8rE) of {
                __DEFAULT -> GHC.Types.False;
                1# -> jump $j_s8Gk
              };
            1# ->
              case GHC.Prim.==# ww_s8rz ww1_s8rE of {
                __DEFAULT -> GHC.Types.False;
                1# -> jump $j_s8Gk
              }
          }
      }

-- RHS size: {terms: 17, types: 10, coercions: 0, joins: 0/0}
isBishopValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*U,U(U(U),U(U)),A)><S(SS),1*U(1*U(U),1*U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8rr [Occ=Once] :: Piece)
                 (w1_s8rs [Occ=Once!] :: Move)
                 (w2_s8rt [Occ=Once] :: AllPieces) ->
                 case w1_s8rs of { (ww1_s8rw [Occ=Once!], ww2_s8rB [Occ=Once!]) ->
                 case ww1_s8rw of { GHC.Types.I# ww4_s8rz [Occ=Once] ->
                 case ww2_s8rB of { GHC.Types.I# ww6_s8rE [Occ=Once] ->
                 Util.$wisBishopValidMove w_s8rr ww4_s8rz ww6_s8rE w2_s8rt
                 }
                 }
                 }}]
isBishopValidMove
  = \ (w_s8rr :: Piece) (w1_s8rs :: Move) (w2_s8rt :: AllPieces) ->
      case w1_s8rs of { (ww1_s8rw, ww2_s8rB) ->
      case ww1_s8rw of { GHC.Types.I# ww4_s8rz ->
      case ww2_s8rB of { GHC.Types.I# ww6_s8rE ->
      Util.$wisBishopValidMove w_s8rr ww4_s8rz ww6_s8rE w2_s8rt
      }
      }
      }

-- RHS size: {terms: 110, types: 30, coercions: 0, joins: 0/0}
Util.$wisRookValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> GHC.Prim.Int# -> Int -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*U,U(U(U),U(U)),A)><S,1*U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 324 40 0] 638 30}]
Util.$wisRookValidMove
  = \ (w_s8rI :: Piece)
      (ww_s8rQ :: GHC.Prim.Int#)
      (ww1_s8rS :: Int)
      (w1_s8rK :: AllPieces) ->
      case ww_s8rQ of ds_X54s {
        __DEFAULT ->
          case ww1_s8rS of { GHC.Types.I# ds1_d53l ->
          case ds1_d53l of {
            __DEFAULT -> GHC.Types.False;
            0# ->
              case w_s8rI of { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
              case Util.$wisValidTarget
                     ww4_s8rm
                     ww5_s8rn
                     (GHC.Types.I# ds_X54s, Util.allPiecesMoved1)
                     w1_s8rK
              of {
                False -> GHC.Types.False;
                True ->
                  case GHC.Prim.<# ds_X54s 0# of {
                    __DEFAULT ->
                      case GHC.Prim.># ds_X54s 0# of {
                        __DEFAULT ->
                          Util.$wisStraightMovePathEmpty ww5_s8rn ds_X54s 0# w1_s8rK;
                        1# ->
                          Util.$wisStraightMovePathEmpty
                            ww5_s8rn (GHC.Prim.-# ds_X54s 1#) 0# w1_s8rK
                      };
                    1# ->
                      Util.$wisStraightMovePathEmpty
                        ww5_s8rn (GHC.Prim.+# ds_X54s 1#) 0# w1_s8rK
                  }
              }
              }
          }
          };
        0# ->
          case w_s8rI of { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
          case Util.$wisValidTarget
                 ww4_s8rm ww5_s8rn (Util.allPiecesMoved1, ww1_s8rS) w1_s8rK
          of {
            False -> GHC.Types.False;
            True ->
              case ww1_s8rS of { GHC.Types.I# x_a5k9 ->
              case GHC.Prim.<# x_a5k9 0# of {
                __DEFAULT ->
                  case GHC.Prim.># x_a5k9 0# of {
                    __DEFAULT ->
                      Util.$wisStraightMovePathEmpty ww5_s8rn 0# x_a5k9 w1_s8rK;
                    1# ->
                      Util.$wisStraightMovePathEmpty
                        ww5_s8rn 0# (GHC.Prim.-# x_a5k9 1#) w1_s8rK
                  };
                1# ->
                  Util.$wisStraightMovePathEmpty
                    ww5_s8rn 0# (GHC.Prim.+# x_a5k9 1#) w1_s8rK
              }
              }
          }
          }
      }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
isRookValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*U,U(U(U),U(U)),A)><S(S(S)L),1*U(1*U(1*U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8rI [Occ=Once] :: Piece)
                 (w1_s8rJ [Occ=Once!] :: Move)
                 (w2_s8rK [Occ=Once] :: AllPieces) ->
                 case w1_s8rJ of { (ww1_s8rN [Occ=Once!], ww2_s8rS [Occ=Once]) ->
                 case ww1_s8rN of { GHC.Types.I# ww4_s8rQ [Occ=Once] ->
                 Util.$wisRookValidMove w_s8rI ww4_s8rQ ww2_s8rS w2_s8rK
                 }
                 }}]
isRookValidMove
  = \ (w_s8rI :: Piece) (w1_s8rJ :: Move) (w2_s8rK :: AllPieces) ->
      case w1_s8rJ of { (ww1_s8rN, ww2_s8rS) ->
      case ww1_s8rN of { GHC.Types.I# ww4_s8rQ ->
      Util.$wisRookValidMove w_s8rI ww4_s8rQ ww2_s8rS w2_s8rK
      }
      }

-- RHS size: {terms: 26, types: 11, coercions: 0, joins: 0/0}
isQueenValidMove :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U(A,U,U(U(U),U(U)),A)><S(S(S)L),1*U(1*U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4ek :: Piece)
                 (move_a4el :: Move)
                 (ps_a4em :: AllPieces) ->
                 case isRookValidMove p_a4ek move_a4el ps_a4em of {
                   False -> isBishopValidMove p_a4ek move_a4el ps_a4em;
                   True -> GHC.Types.True
                 }}]
isQueenValidMove
  = \ (p_a4ek :: Piece) (move_a4el :: Move) (ps_a4em :: AllPieces) ->
      case move_a4el of { (ww1_s8rN, ww2_s8rS) ->
      case ww1_s8rN of { GHC.Types.I# ww4_s8rQ ->
      case Util.$wisRookValidMove p_a4ek ww4_s8rQ ww2_s8rS ps_a4em of {
        False ->
          case ww2_s8rS of { GHC.Types.I# ww6_s8rE ->
          Util.$wisBishopValidMove p_a4ek ww4_s8rQ ww6_s8rE ps_a4em
          };
        True -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Util.clearCastlePath4 = "ww PieceType"#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Util.clearCastlePath3 :: PieceType
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Util.clearCastlePath3
  = Control.Exception.Base.absentError
      @ PieceType Util.clearCastlePath4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Util.clearCastlePath2 = "ww Movecount"#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Util.clearCastlePath1 :: Movecount
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Util.clearCastlePath1
  = Control.Exception.Base.absentError
      @ Movecount Util.clearCastlePath2

-- RHS size: {terms: 109, types: 57, coercions: 0, joins: 1/1}
Util.$wisPawnValidMove [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> Move -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,U><L,U(U(U),U(U))><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 40 60 0] 608 20}]
Util.$wisPawnValidMove
  = \ (ww_s8s1 :: Colour)
      (ww1_s8s2 :: Pos)
      (w_s8rW :: Move)
      (w1_s8rX :: AllPieces) ->
      case Util.$wisValidTarget ww_s8s1 ww1_s8s2 w_s8rW w1_s8rX of {
        False -> GHC.Types.False;
        True ->
          join {
            $j_s5TU [Dmd=<L,1*U>] :: Bool
            [LclId[JoinId(0)]]
            $j_s5TU
              = case isTargetEnemy
                       (Util.clearCastlePath3, ww_s8s1, ww1_s8s2, Util.clearCastlePath1)
                       w_s8rW
                       w1_s8rX
                of {
                  False -> GHC.Types.False;
                  True ->
                    case w_s8rW of { (ww3_s8o1, ww4_s8o6) ->
                    case ww3_s8o1 of { GHC.Types.I# ww6_s8o4 ->
                    Util.$wisPawnCapture ww_s8s1 ww6_s8o4 ww4_s8o6
                    }
                    }
                } } in
          case GHC.Classes.$fEq[]_$c==
                 @ (PieceType, Colour, Pos, Movecount)
                 Util.$s$fEq(,,,)
                 (findPiece
                    (case ww1_s8s2 of { (a_a40e, b_a40f) ->
                     case w_s8rW of { (c_a40g, d_a40h) ->
                     (case a_a40e of { GHC.Types.I# x_a5kQ ->
                      case c_a40g of { GHC.Types.I# y_a5kT ->
                      GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                      }
                      },
                      case b_a40f of { GHC.Types.I# x_a5kQ ->
                      case d_a40h of { GHC.Types.I# y_a5kT ->
                      GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                      }
                      })
                     }
                     })
                    w1_s8rX)
                 (GHC.Types.[] @ Piece)
          of {
            False -> jump $j_s5TU;
            True ->
              case ww1_s8s2 of { (ww3_s8qX, ww4_s8r2) ->
              case ww3_s8qX of { GHC.Types.I# ww6_s8r0 ->
              case w_s8rW of { (ww8_s8r8, ww9_s8rd) ->
              case ww8_s8r8 of { GHC.Types.I# ww11_s8rb ->
              case Util.$wisBasicPawnMove
                     ww_s8s1 ww6_s8r0 ww4_s8r2 ww11_s8rb ww9_s8rd w1_s8rX
              of {
                False -> jump $j_s5TU;
                True ->
                  case ww9_s8rd of { GHC.Types.I# ww13_s8qJ ->
                  case Util.clearCastlePath_$s$wisStraightMovePathEmpty
                         w1_s8rX ww13_s8qJ ww11_s8rb ww6_s8r0 ww4_s8r2
                  of {
                    False -> jump $j_s5TU;
                    True -> GHC.Types.True
                  }
                  }
              }
              }
              }
              }
              }
          }
      }

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
isPawnValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S,1*U(A,U,U(U(U),U(U)),A)><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8rV [Occ=Once!] :: Piece)
                 (w1_s8rW [Occ=Once] :: Move)
                 (w2_s8rX [Occ=Once] :: AllPieces) ->
                 case w_s8rV of
                 { (_ [Occ=Dead], ww2_s8s1 [Occ=Once], ww3_s8s2 [Occ=Once],
                    _ [Occ=Dead]) ->
                 Util.$wisPawnValidMove ww2_s8s1 ww3_s8s2 w1_s8rW w2_s8rX
                 }}]
isPawnValidMove
  = \ (w_s8rV :: Piece) (w1_s8rW :: Move) (w2_s8rX :: AllPieces) ->
      case w_s8rV of { (ww1_s8s0, ww2_s8s1, ww3_s8s2, ww4_s8s3) ->
      Util.$wisPawnValidMove ww2_s8s1 ww3_s8s2 w1_s8rW w2_s8rX
      }

-- RHS size: {terms: 59, types: 24, coercions: 0, joins: 0/0}
Util.$wisValidPromotion [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> Pos -> Move -> AllPieces -> Bool
[GblId,
 Arity=5,
 Str=<S,1*U><L,U><L,U(U(U),U(U))><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [70 51 20 20 0] 232 100}]
Util.$wisValidPromotion
  = \ (ww_s8sb :: PieceType)
      (ww1_s8sc :: Colour)
      (ww2_s8sd :: Pos)
      (w_s8s7 :: Move)
      (w1_s8s8 :: AllPieces) ->
      case ww_s8sb of {
        Pawn ->
          case Util.$wisPawnValidMove ww1_s8sc ww2_s8sd w_s8s7 w1_s8s8 of {
            False -> GHC.Types.False;
            True ->
              case ww2_s8sd of { (a_a40e, b_a40f) ->
              case w_s8s7 of { (c_a40g, d_a40h) ->
              case a_a40e of { GHC.Types.I# x_a5kQ ->
              case c_a40g of { GHC.Types.I# y_a5kT ->
              case ww1_s8sc of {
                Black ->
                  case GHC.Prim.+# x_a5kQ y_a5kT of {
                    __DEFAULT -> GHC.Types.False;
                    7# -> GHC.Types.True
                  };
                White ->
                  case GHC.Prim.+# x_a5kQ y_a5kT of {
                    __DEFAULT -> GHC.Types.False;
                    0# -> GHC.Types.True
                  }
              }
              }
              }
              }
              }
          };
        Knight -> GHC.Types.False;
        Bishop -> GHC.Types.False;
        Rook -> GHC.Types.False;
        Queen -> GHC.Types.False;
        King -> GHC.Types.False
      }

-- RHS size: {terms: 12, types: 8, coercions: 0, joins: 0/0}
isValidPromotion [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),A)><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8s6 [Occ=Once!] :: Piece)
                 (w1_s8s7 [Occ=Once] :: Move)
                 (w2_s8s8 [Occ=Once] :: AllPieces) ->
                 case w_s8s6 of
                 { (ww1_s8sb [Occ=Once], ww2_s8sc [Occ=Once], ww3_s8sd [Occ=Once],
                    _ [Occ=Dead]) ->
                 Util.$wisValidPromotion ww1_s8sb ww2_s8sc ww3_s8sd w1_s8s7 w2_s8s8
                 }}]
isValidPromotion
  = \ (w_s8s6 :: Piece) (w1_s8s7 :: Move) (w2_s8s8 :: AllPieces) ->
      case w_s8s6 of { (ww1_s8sb, ww2_s8sc, ww3_s8sd, ww4_s8se) ->
      Util.$wisValidPromotion ww1_s8sb ww2_s8sc ww3_s8sd w1_s8s7 w2_s8s8
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Util.clearCastlePath9 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Util.clearCastlePath9 = "lvl Colour"#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Util.clearCastlePath8 :: Colour
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Util.clearCastlePath8
  = Control.Exception.Base.absentError @ Colour Util.clearCastlePath9

Rec {
-- RHS size: {terms: 201, types: 66, coercions: 0, joins: 3/6}
Util.clearCastlePath_$s$wvalidKingMove
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> Bool
[GblId,
 Arity=7,
 Str=<L,U><S,U><L,U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 64 0 0 30 20 0] 713 0}]
Util.clearCastlePath_$s$wvalidKingMove
  = \ (sc_sayI :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_sayH :: GHC.Prim.Int#)
      (sc2_sayG :: GHC.Prim.Int#)
      (sc3_sayC :: PieceType)
      (sc4_sayD :: Colour)
      (sc5_sayE :: (Int, Int))
      (sc6_sayF :: Int) ->
      join {
        $j_s5VJ [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5VJ
          = join {
              $j1_s5VF [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5VF
                = join {
                    $j2_s5VB [Dmd=<L,1*U>] :: Bool
                    [LclId[JoinId(0)]]
                    $j2_s5VB
                      = case Util.$wisValidTarget
                               sc4_sayD
                               sc5_sayE
                               (GHC.Types.I# sc2_sayG, GHC.Types.I# sc1_sayH)
                               sc_sayI
                        of {
                          False -> GHC.Types.False;
                          True ->
                            case sc5_sayE of { (a_a40e, b_a40f) ->
                            case b_a40f of { GHC.Types.I# x_a5kQ ->
                            case findKing
                                   (case sc4_sayD of {
                                      Black -> TypeDefs.White;
                                      White -> TypeDefs.Black
                                    })
                                   sc_sayI
                            of
                            { (ds_X5aZ, col_X482) ->
                            case col_X482 of { GHC.Types.I# y_a5lE ->
                            let {
                              x1_s5IJ :: GHC.Prim.Int#
                              [LclId]
                              x1_s5IJ = GHC.Prim.-# (GHC.Prim.+# x_a5kQ sc1_sayH) y_a5lE } in
                            case GHC.Prim.>=# x1_s5IJ 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># (GHC.Prim.negateInt# x1_s5IJ) 1# of {
                                  __DEFAULT ->
                                    case a_a40e of { GHC.Types.I# x2_X5tF ->
                                    case ds_X5aZ of { GHC.Types.I# y1_X5ua ->
                                    let {
                                      x3_s5IL :: GHC.Prim.Int#
                                      [LclId]
                                      x3_s5IL
                                        = GHC.Prim.-# (GHC.Prim.+# x2_X5tF sc2_sayG) y1_X5ua } in
                                    case GHC.Prim.>=# x3_s5IL 0# of {
                                      __DEFAULT ->
                                        GHC.Prim.tagToEnum#
                                          @ Bool (GHC.Prim.># (GHC.Prim.negateInt# x3_s5IL) 1#);
                                      1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># x3_s5IL 1#)
                                    }
                                    }
                                    };
                                  1# -> GHC.Types.True
                                };
                              1# ->
                                case GHC.Prim.># x1_s5IJ 1# of {
                                  __DEFAULT ->
                                    case a_a40e of { GHC.Types.I# x2_X5tF ->
                                    case ds_X5aZ of { GHC.Types.I# y1_X5ua ->
                                    let {
                                      x3_s5IL :: GHC.Prim.Int#
                                      [LclId]
                                      x3_s5IL
                                        = GHC.Prim.-# (GHC.Prim.+# x2_X5tF sc2_sayG) y1_X5ua } in
                                    case GHC.Prim.>=# x3_s5IL 0# of {
                                      __DEFAULT ->
                                        GHC.Prim.tagToEnum#
                                          @ Bool (GHC.Prim.># (GHC.Prim.negateInt# x3_s5IL) 1#);
                                      1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># x3_s5IL 1#)
                                    }
                                    }
                                    };
                                  1# -> GHC.Types.True
                                }
                            }
                            }
                            }
                            }
                            }
                        } } in
                  case GHC.Prim.>=# sc1_sayH 0# of {
                    __DEFAULT ->
                      case GHC.Prim.<=# (GHC.Prim.negateInt# sc1_sayH) 1# of {
                        __DEFAULT -> GHC.Types.False;
                        1# -> jump $j2_s5VB
                      };
                    1# ->
                      case GHC.Prim.<=# sc1_sayH 1# of {
                        __DEFAULT -> GHC.Types.False;
                        1# -> jump $j2_s5VB
                      }
                  } } in
            case GHC.Prim.>=# sc2_sayG 0# of {
              __DEFAULT ->
                case GHC.Prim.<=# (GHC.Prim.negateInt# sc2_sayG) 1# of {
                  __DEFAULT -> GHC.Types.False;
                  1# -> jump $j1_s5VF
                };
              1# ->
                case GHC.Prim.<=# sc2_sayG 1# of {
                  __DEFAULT -> GHC.Types.False;
                  1# -> jump $j1_s5VF
                }
            } } in
      case GHC.Prim.>=# sc1_sayH 0# of {
        __DEFAULT ->
          case sc1_sayH of {
            __DEFAULT -> jump $j_s5VJ;
            -2# ->
              Util.clearCastlePath_$s$wvalidCastle
                sc_sayI -2# sc2_sayG sc3_sayC sc4_sayD sc5_sayE sc6_sayF
          };
        1# ->
          case sc1_sayH of {
            __DEFAULT -> jump $j_s5VJ;
            2# ->
              Util.clearCastlePath_$s$wvalidCastle
                sc_sayI 2# sc2_sayG sc3_sayC sc4_sayD sc5_sayE sc6_sayF
          }
      }

-- RHS size: {terms: 119, types: 55, coercions: 0, joins: 0/1}
Util.clearCastlePath_$s$wisValidMove
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> Int -> Int -> Int -> (Int, Int) -> Colour -> PieceType -> Bool
[GblId,
 Arity=7,
 Str=<L,U><L,U(U)><L,U(U)><L,U(U)><L,U(U(U),U(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0 0 0 590] 740 30}]
Util.clearCastlePath_$s$wisValidMove
  = \ (sc_sazc :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saza :: Int)
      (sc2_sazb :: Int)
      (sc3_saz9 :: Int)
      (sc4_saz8 :: (Int, Int))
      (sc5_saz7 :: Colour)
      (sc6_saz6 :: PieceType) ->
      case sc6_saz6 of {
        Pawn ->
          case Util.$wisPawnValidMove
                 sc5_saz7 sc4_saz8 (sc1_saza, sc2_sazb) sc_sazc
          of {
            False ->
              case sc1_saza of { GHC.Types.I# ww1_s8qd ->
              Util.$wisValidEnPassant sc5_saz7 sc4_saz8 ww1_s8qd sc2_sazb sc_sazc
              };
            True -> GHC.Types.True
          };
        Knight ->
          case Util.$wisValidTarget
                 sc5_saz7 sc4_saz8 (sc1_saza, sc2_sazb) sc_sazc
          of {
            False -> GHC.Types.False;
            True ->
              case sc1_saza of { GHC.Types.I# ww1_s8oM ->
              Util.$wisLShaped ww1_s8oM sc2_sazb
              }
          };
        Bishop ->
          case sc1_saza of { GHC.Types.I# ww1_s8rz ->
          case sc2_sazb of { GHC.Types.I# ww3_s8rE ->
          Util.$wisBishopValidMove
            (TypeDefs.Bishop, sc5_saz7, sc4_saz8, sc3_saz9)
            ww1_s8rz
            ww3_s8rE
            sc_sazc
          }
          };
        Rook ->
          case sc1_saza of { GHC.Types.I# ww1_s8rQ ->
          Util.$wisRookValidMove
            (TypeDefs.Rook, sc5_saz7, sc4_saz8, sc3_saz9)
            ww1_s8rQ
            sc2_sazb
            sc_sazc
          };
        Queen ->
          case sc1_saza of { GHC.Types.I# ww1_s8rQ ->
          let {
            p_s5Ix [Dmd=<L,U(A,U,U(U(U),U(U)),A)>] :: Piece
            [LclId, Unf=OtherCon []]
            p_s5Ix = (TypeDefs.Queen, sc5_saz7, sc4_saz8, sc3_saz9) } in
          case Util.$wisRookValidMove p_s5Ix ww1_s8rQ sc2_sazb sc_sazc of {
            False ->
              case sc2_sazb of { GHC.Types.I# ww3_s8rE ->
              Util.$wisBishopValidMove p_s5Ix ww1_s8rQ ww3_s8rE sc_sazc
              };
            True -> GHC.Types.True
          }
          };
        King ->
          case sc1_saza of { GHC.Types.I# ww1_s8sp ->
          case sc2_sazb of { GHC.Types.I# ww3_s8su ->
          Util.clearCastlePath_$s$wvalidKingMove
            sc_sazc ww3_s8su ww1_s8sp TypeDefs.King sc5_saz7 sc4_saz8 sc3_saz9
          }
          }
      }

-- RHS size: {terms: 58, types: 49, coercions: 0, joins: 0/1}
Util.clearCastlePath_$sthreatenedBy1
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType -> Colour -> Int -> Int -> [Piece]
[GblId,
 Arity=5,
 Str=<S,U><L,A><L,A><L,U(U)><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 20 20] 302 0}]
Util.clearCastlePath_$sthreatenedBy1
  = \ (sc_sazE :: [(PieceType, Colour, (Int, Int), Int)])
      _ [Occ=Dead]
      _ [Occ=Dead]
      (sc3_sazC :: Int)
      (sc4_sazD :: Int) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Piece;
                : y_a24x ys_a24y ->
                  case y_a24x of ww_s8sC
                  { (ww1_s8sD, ww2_s8sE, ww3_s8sF, ww4_s8sG) ->
                  case Util.clearCastlePath_$s$wisValidMove
                         sc_sazE
                         (case sc3_sazC of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (row_X47T, ds1_X5aH) ->
                          case row_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          })
                         (case sc4_sazD of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (ds1_X5aQ, col_X47T) ->
                          case col_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          })
                         ww4_s8sG
                         ww3_s8sF
                         ww2_s8sE
                         ww1_s8sD
                  of {
                    False -> go_a24t ys_a24y;
                    True -> GHC.Types.: @ Piece ww_s8sC (go_a24t ys_a24y)
                  }
                  }
              }; } in
      go_a24t sc_sazE

-- RHS size: {terms: 64, types: 61, coercions: 0, joins: 0/1}
Util.clearCastlePath_$sthreatenedBy
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType -> Colour -> (Int, Int) -> Int -> [Piece]
[GblId,
 Arity=5,
 Str=<S,U><L,A><L,A><L,U(U(U),U(U))><L,A>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 40 0] 322 0}]
Util.clearCastlePath_$sthreatenedBy
  = \ (sc_sazu :: [(PieceType, Colour, (Int, Int), Int)])
      _ [Occ=Dead]
      _ [Occ=Dead]
      (sc3_sazs :: (Int, Int))
      _ [Occ=Dead] ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Piece;
                : y_a24x ys_a24y ->
                  case y_a24x of ww_s8sC
                  { (ww1_s8sD, ww2_s8sE, ww3_s8sF, ww4_s8sG) ->
                  case Util.clearCastlePath_$s$wisValidMove
                         sc_sazu
                         (case sc3_sazs of { (row_a3ZW, ds1_d52J) ->
                          case row_a3ZW of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (row1_X47T, ds2_X5aH) ->
                          case row1_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          }
                          })
                         (case sc3_sazs of { (ds1_d52T, col_a3ZV) ->
                          case col_a3ZV of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (ds2_X5aQ, col1_X47T) ->
                          case col1_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          }
                          })
                         ww4_s8sG
                         ww3_s8sF
                         ww2_s8sE
                         ww1_s8sD
                  of {
                    False -> go_a24t ys_a24y;
                    True -> GHC.Types.: @ Piece ww_s8sC (go_a24t ys_a24y)
                  }
                  }
              }; } in
      go_a24t sc_sazu

-- RHS size: {terms: 86, types: 110, coercions: 0, joins: 0/4}
Util.clearCastlePath_$sclearCastlePath2
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType -> Colour -> (Int, Int) -> Int -> Bool
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 30 0 0] 550 30}]
Util.clearCastlePath_$sclearCastlePath2
  = \ (sc_saBD :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saBz :: PieceType)
      (sc2_saBA :: Colour)
      (sc3_saBB :: (Int, Int))
      (sc4_saBC :: Int) ->
      let {
        m_s5ID [Dmd=<L,U(U)>] :: Int
        [LclId]
        m_s5ID
          = case sc2_saBA of {
              Black -> Util.allPiecesMoved1;
              White -> Util.clearCastlePath10
            } } in
      let {
        arg_s5UO [Dmd=<C(C(S)),C(C1(U))>]
          :: Int -> [(Int, Int)] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,U>, Unf=OtherCon []]
        arg_s5UO
          = \ (ds_d53Q :: Int) (ds1_d53P [OS=OneShot] :: [(Int, Int)]) ->
              case Util.clearCastlePath_$sthreatenedBy1
                     (GHC.Types.:
                        @ (PieceType, Colour, (Int, Int), Movecount)
                        (TypeDefs.Pawn, sc2_saBA, (m_s5ID, ds_d53Q), Util.allPiecesMoved1)
                        sc_saBD)
                     TypeDefs.Pawn
                     Util.clearCastlePath8
                     m_s5ID
                     ds_d53Q
              of {
                [] -> ds1_d53P;
                : ds2_a5jz ds3_a5jA ->
                  GHC.Types.: @ (Int, Int) (m_s5ID, ds_d53Q) ds1_d53P
              } } in
      letrec {
        $sgo_saBW [Occ=LoopBreaker] :: Int -> [Int] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
        $sgo_saBW
          = \ (sc5_saBU :: Int) (sc6_saBV :: [Int]) ->
              arg_s5UO sc5_saBU (go_a24t sc6_saBV);
        go_a24t [Occ=LoopBreaker] :: [Int] -> [(Int, Int)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Int]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Int, Int);
                : y_a24x ys_a24y -> arg_s5UO y_a24x (go_a24t ys_a24y)
              }; } in
      case $sgo_saBW Util.clearCastlePath13 Util.clearCastlePath11 of {
        [] ->
          case Util.clearCastlePath_$sthreatenedBy
                 (GHC.Types.:
                    @ (PieceType, Colour, Pos, Movecount)
                    (TypeDefs.Pawn, sc2_saBA, sc3_saBB, sc4_saBC)
                    (removePiece (sc1_saBz, sc2_saBA, sc3_saBB, sc4_saBC) sc_saBD))
                 TypeDefs.Pawn
                 sc2_saBA
                 sc3_saBB
                 sc4_saBC
          of {
            [] -> GHC.Types.True;
            : ds1_a5jz ds2_a5jA -> GHC.Types.False
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 90, types: 131, coercions: 0, joins: 0/5}
Util.clearCastlePath_$sclearCastlePath
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> (PieceType, Colour, (Int, Int), Int) -> Bool
[GblId,
 Arity=2,
 Str=<L,U><L,U(U,U,U(U(U),U(U)),U(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 580 30}]
Util.clearCastlePath_$sclearCastlePath
  = \ (sc_saA2 :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saA1 :: (PieceType, Colour, (Int, Int), Int)) ->
      let {
        lvl4_s5LF :: Colour
        [LclId]
        lvl4_s5LF
          = case sc1_saA1 of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            colour_a3ZX
            } } in
      let {
        m_s5ID [Dmd=<L,U(U)>] :: Int
        [LclId]
        m_s5ID
          = case sc1_saA1 of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            case colour_a3ZX of {
              Black -> Util.allPiecesMoved1;
              White -> Util.clearCastlePath10
            }
            } } in
      let {
        arg_s5UO [Dmd=<C(C(S)),C(C1(U))>]
          :: Int -> [(Int, Int)] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,U>, Unf=OtherCon []]
        arg_s5UO
          = \ (ds_d53Q :: Int) (ds1_d53P [OS=OneShot] :: [(Int, Int)]) ->
              case Util.clearCastlePath_$sthreatenedBy1
                     (GHC.Types.:
                        @ (PieceType, Colour, (Int, Int), Movecount)
                        (TypeDefs.Pawn, lvl4_s5LF, (m_s5ID, ds_d53Q), Util.allPiecesMoved1)
                        sc_saA2)
                     TypeDefs.Pawn
                     Util.clearCastlePath8
                     m_s5ID
                     ds_d53Q
              of {
                [] -> ds1_d53P;
                : ds2_a5jz ds3_a5jA ->
                  GHC.Types.: @ (Int, Int) (m_s5ID, ds_d53Q) ds1_d53P
              } } in
      letrec {
        $sgo_saAg [Occ=LoopBreaker] :: Int -> [Int] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
        $sgo_saAg
          = \ (sc2_saAe :: Int) (sc3_saAf :: [Int]) ->
              arg_s5UO sc2_saAe (go_a24t sc3_saAf);
        go_a24t [Occ=LoopBreaker] :: [Int] -> [(Int, Int)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Int]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Int, Int);
                : y_a24x ys_a24y -> arg_s5UO y_a24x (go_a24t ys_a24y)
              }; } in
      case $sgo_saAg Util.clearCastlePath7 Util.clearCastlePath5 of {
        [] ->
          case sc1_saA1 of ww_s8sP
          { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
          case Util.clearCastlePath_$sthreatenedBy
                 (GHC.Types.:
                    @ (PieceType, Colour, Pos, Movecount)
                    (TypeDefs.Pawn, ww2_s8sR, ww3_s8sS, ww4_s8sT)
                    (removePiece ww_s8sP sc_saA2))
                 TypeDefs.Pawn
                 ww2_s8sR
                 ww3_s8sS
                 ww4_s8sT
          of {
            [] -> GHC.Types.True;
            : ds1_a5jz ds2_a5jA -> GHC.Types.False
          }
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 137, types: 100, coercions: 0, joins: 0/0}
Util.clearCastlePath_$s$wvalidCastle [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> Bool
[GblId,
 Arity=7,
 Str=<L,U><L,1*U><S,1*U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=OtherCon []]
Util.clearCastlePath_$s$wvalidCastle
  = \ (sc_saAI :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saAH :: GHC.Prim.Int#)
      (sc2_saAG :: GHC.Prim.Int#)
      (sc3_saAC :: PieceType)
      (sc4_saAD :: Colour)
      (sc5_saAE :: (Int, Int))
      (sc6_saAF :: Int) ->
      case sc2_saAG of {
        __DEFAULT -> GHC.Types.False;
        0# ->
          case sc1_saAH of {
            __DEFAULT -> GHC.Types.False;
            -2# ->
              case Util.$wisStraightMovePathEmpty sc5_saAE 0# -3# sc_saAI of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc4_saAD of {
                            Black -> Util.executeCastle4;
                            White -> Util.executeCastle3
                          })
                         sc_saAI
                  of {
                    [] -> GHC.Types.False;
                    : ds2_a5jz ds3_a5jA ->
                      case findPiece (findKing sc4_saAD sc_saAI) sc_saAI of {
                        [] -> case GHC.List.badHead of wild3_00 { };
                        : x_a4SP ds4_a4SQ ->
                          case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds2_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# ->
                                  Util.clearCastlePath_$sclearCastlePath2
                                    sc_saAI sc3_saAC sc4_saAD sc5_saAE sc6_saAF
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              };
            2# ->
              case Util.$wisStraightMovePathEmpty sc5_saAE 0# 2# sc_saAI of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc4_saAD of {
                            Black -> Util.executeCastle2;
                            White -> Util.executeCastle1
                          })
                         sc_saAI
                  of {
                    [] -> GHC.Types.False;
                    : ds2_a5jz ds3_a5jA ->
                      case findPiece (findKing sc4_saAD sc_saAI) sc_saAI of {
                        [] -> case GHC.List.badHead of wild3_00 { };
                        : x_a4SP ds4_a4SQ ->
                          case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds2_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# ->
                                  Util.clearCastlePath_$sclearCastlePath
                                    sc_saAI (sc3_saAC, sc4_saAD, sc5_saAE, sc6_saAF)
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              }
          }
      }
end Rec }

-- RHS size: {terms: 90, types: 131, coercions: 0, joins: 0/5}
Util.clearCastlePath_$sclearCastlePath1
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> (PieceType, Colour, (Int, Int), Int) -> Bool
[GblId,
 Arity=2,
 Str=<L,U><L,U(U,U,U(U(U),U(U)),U(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60] 580 30}]
Util.clearCastlePath_$sclearCastlePath1
  = \ (sc_saA0 :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_sazZ :: (PieceType, Colour, (Int, Int), Int)) ->
      let {
        lvl4_s5LF :: Colour
        [LclId]
        lvl4_s5LF
          = case sc1_sazZ of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            colour_a3ZX
            } } in
      let {
        m_s5ID [Dmd=<L,U(U)>] :: Int
        [LclId]
        m_s5ID
          = case sc1_sazZ of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            case colour_a3ZX of {
              Black -> Util.allPiecesMoved1;
              White -> Util.clearCastlePath10
            }
            } } in
      let {
        arg_s5UO [Dmd=<C(C(S)),C(C1(U))>]
          :: Int -> [(Int, Int)] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,U>, Unf=OtherCon []]
        arg_s5UO
          = \ (ds_d53Q :: Int) (ds1_d53P [OS=OneShot] :: [(Int, Int)]) ->
              case Util.clearCastlePath_$sthreatenedBy1
                     (GHC.Types.:
                        @ (PieceType, Colour, (Int, Int), Movecount)
                        (TypeDefs.Pawn, lvl4_s5LF, (m_s5ID, ds_d53Q), Util.allPiecesMoved1)
                        sc_saA0)
                     TypeDefs.Pawn
                     Util.clearCastlePath8
                     m_s5ID
                     ds_d53Q
              of {
                [] -> ds1_d53P;
                : ds2_a5jz ds3_a5jA ->
                  GHC.Types.: @ (Int, Int) (m_s5ID, ds_d53Q) ds1_d53P
              } } in
      letrec {
        $sgo_saA6 [Occ=LoopBreaker] :: Int -> [Int] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
        $sgo_saA6
          = \ (sc2_saA4 :: Int) (sc3_saA5 :: [Int]) ->
              arg_s5UO sc2_saA4 (go_a24t sc3_saA5);
        go_a24t [Occ=LoopBreaker] :: [Int] -> [(Int, Int)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Int]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Int, Int);
                : y_a24x ys_a24y -> arg_s5UO y_a24x (go_a24t ys_a24y)
              }; } in
      case $sgo_saA6 Util.clearCastlePath13 Util.clearCastlePath11 of {
        [] ->
          case sc1_sazZ of ww_s8sP
          { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
          case Util.clearCastlePath_$sthreatenedBy
                 (GHC.Types.:
                    @ (PieceType, Colour, Pos, Movecount)
                    (TypeDefs.Pawn, ww2_s8sR, ww3_s8sS, ww4_s8sT)
                    (removePiece ww_s8sP sc_saA0))
                 TypeDefs.Pawn
                 ww2_s8sR
                 ww3_s8sS
                 ww4_s8sT
          of {
            [] -> GHC.Types.True;
            : ds1_a5jz ds2_a5jA -> GHC.Types.False
          }
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 145, types: 151, coercions: 0, joins: 0/0}
Util.validCastle_$s$wvalidCastle1
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> (PieceType, Colour, (Int, Int), Int)
     -> Bool
[GblId,
 Arity=4,
 Str=<L,U><L,1*U><S,1*U><L,U(U,U,U(U(U),U(U)),U(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 400 30 120] 770 100}]
Util.validCastle_$s$wvalidCastle1
  = \ (sc_saAq :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saAp :: GHC.Prim.Int#)
      (sc2_saAo :: GHC.Prim.Int#)
      (sc3_saAn :: (PieceType, Colour, (Int, Int), Int)) ->
      case sc2_saAo of {
        __DEFAULT -> GHC.Types.False;
        0# ->
          case sc1_saAp of {
            __DEFAULT -> GHC.Types.False;
            -2# ->
              case Util.$wisStraightMovePathEmpty
                     (case sc3_saAn of { (ds2_d4Xh, ds3_d4Xi, pos_a3ZY, ds4_d4Xj) ->
                      pos_a3ZY
                      })
                     0#
                     -3#
                     sc_saAq
              of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc3_saAn of { (ds2_d529, colour_a3ZX, ds3_d52a, ds4_d52b) ->
                          case colour_a3ZX of {
                            Black -> Util.executeCastle4;
                            White -> Util.executeCastle3
                          }
                          })
                         sc_saAq
                  of {
                    [] -> GHC.Types.False;
                    : ds2_a5jz ds3_a5jA ->
                      case findPiece
                             (findKing
                                (case sc3_saAn of { (ds4_d529, colour_a3ZX, ds5_d52a, ds6_d52b) ->
                                 colour_a3ZX
                                 })
                                sc_saAq)
                             sc_saAq
                      of {
                        [] -> case GHC.List.badHead of wild3_00 { };
                        : x_a4SP ds4_a4SQ ->
                          case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds2_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# -> Util.clearCastlePath_$sclearCastlePath1 sc_saAq sc3_saAn
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              };
            2# ->
              case Util.$wisStraightMovePathEmpty
                     (case sc3_saAn of { (ds2_d4Xh, ds3_d4Xi, pos_a3ZY, ds4_d4Xj) ->
                      pos_a3ZY
                      })
                     0#
                     2#
                     sc_saAq
              of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc3_saAn of { (ds2_d529, colour_a3ZX, ds3_d52a, ds4_d52b) ->
                          case colour_a3ZX of {
                            Black -> Util.executeCastle2;
                            White -> Util.executeCastle1
                          }
                          })
                         sc_saAq
                  of {
                    [] -> GHC.Types.False;
                    : ds2_a5jz ds3_a5jA ->
                      case findPiece
                             (findKing
                                (case sc3_saAn of { (ds4_d529, colour_a3ZX, ds5_d52a, ds6_d52b) ->
                                 colour_a3ZX
                                 })
                                sc_saAq)
                             sc_saAq
                      of {
                        [] -> case GHC.List.badHead of wild3_00 { };
                        : x_a4SP ds4_a4SQ ->
                          case x_a4SP of { (ds5_d4Vi, ds6_d4Vj, ds7_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds2_a5jz of { (ds8_X517, ds9_X519, ds10_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# -> Util.clearCastlePath_$sclearCastlePath sc_saAq sc3_saAn
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              }
          }
      }

-- RHS size: {terms: 195, types: 59, coercions: 0, joins: 3/6}
Util.$wvalidKingMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> GHC.Prim.Int# -> GHC.Prim.Int# -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 64 0] 663 0}]
Util.$wvalidKingMove
  = \ (w_s8sh :: Piece)
      (ww_s8sp :: GHC.Prim.Int#)
      (ww1_s8su :: GHC.Prim.Int#)
      (w1_s8sj :: AllPieces) ->
      join {
        $j_s5VJ [Dmd=<L,1*U>] :: Bool
        [LclId[JoinId(0)]]
        $j_s5VJ
          = join {
              $j1_s5VF [Dmd=<L,1*U>] :: Bool
              [LclId[JoinId(0)]]
              $j1_s5VF
                = join {
                    $j2_s5VB [Dmd=<L,1*U>] :: Bool
                    [LclId[JoinId(0)]]
                    $j2_s5VB
                      = case w_s8sh of { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
                        case Util.$wisValidTarget
                               ww4_s8rm
                               ww5_s8rn
                               (GHC.Types.I# ww_s8sp, GHC.Types.I# ww1_s8su)
                               w1_s8sj
                        of {
                          False -> GHC.Types.False;
                          True ->
                            case ww5_s8rn of { (a_a40e, b_a40f) ->
                            case b_a40f of { GHC.Types.I# x_a5kQ ->
                            case findKing
                                   (case ww4_s8rm of {
                                      Black -> TypeDefs.White;
                                      White -> TypeDefs.Black
                                    })
                                   w1_s8sj
                            of
                            { (ds_X5aZ, col_X482) ->
                            case col_X482 of { GHC.Types.I# y_a5lE ->
                            let {
                              x1_s5IJ :: GHC.Prim.Int#
                              [LclId]
                              x1_s5IJ = GHC.Prim.-# (GHC.Prim.+# x_a5kQ ww1_s8su) y_a5lE } in
                            case GHC.Prim.>=# x1_s5IJ 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># (GHC.Prim.negateInt# x1_s5IJ) 1# of {
                                  __DEFAULT ->
                                    case a_a40e of { GHC.Types.I# x2_X5tF ->
                                    case ds_X5aZ of { GHC.Types.I# y1_X5ua ->
                                    let {
                                      x3_s5IL :: GHC.Prim.Int#
                                      [LclId]
                                      x3_s5IL
                                        = GHC.Prim.-# (GHC.Prim.+# x2_X5tF ww_s8sp) y1_X5ua } in
                                    case GHC.Prim.>=# x3_s5IL 0# of {
                                      __DEFAULT ->
                                        GHC.Prim.tagToEnum#
                                          @ Bool (GHC.Prim.># (GHC.Prim.negateInt# x3_s5IL) 1#);
                                      1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># x3_s5IL 1#)
                                    }
                                    }
                                    };
                                  1# -> GHC.Types.True
                                };
                              1# ->
                                case GHC.Prim.># x1_s5IJ 1# of {
                                  __DEFAULT ->
                                    case a_a40e of { GHC.Types.I# x2_X5tF ->
                                    case ds_X5aZ of { GHC.Types.I# y1_X5ua ->
                                    let {
                                      x3_s5IL :: GHC.Prim.Int#
                                      [LclId]
                                      x3_s5IL
                                        = GHC.Prim.-# (GHC.Prim.+# x2_X5tF ww_s8sp) y1_X5ua } in
                                    case GHC.Prim.>=# x3_s5IL 0# of {
                                      __DEFAULT ->
                                        GHC.Prim.tagToEnum#
                                          @ Bool (GHC.Prim.># (GHC.Prim.negateInt# x3_s5IL) 1#);
                                      1# -> GHC.Prim.tagToEnum# @ Bool (GHC.Prim.># x3_s5IL 1#)
                                    }
                                    }
                                    };
                                  1# -> GHC.Types.True
                                }
                            }
                            }
                            }
                            }
                            }
                        }
                        } } in
                  case GHC.Prim.>=# ww1_s8su 0# of {
                    __DEFAULT ->
                      case GHC.Prim.<=# (GHC.Prim.negateInt# ww1_s8su) 1# of {
                        __DEFAULT -> GHC.Types.False;
                        1# -> jump $j2_s5VB
                      };
                    1# ->
                      case GHC.Prim.<=# ww1_s8su 1# of {
                        __DEFAULT -> GHC.Types.False;
                        1# -> jump $j2_s5VB
                      }
                  } } in
            case GHC.Prim.>=# ww_s8sp 0# of {
              __DEFAULT ->
                case GHC.Prim.<=# (GHC.Prim.negateInt# ww_s8sp) 1# of {
                  __DEFAULT -> GHC.Types.False;
                  1# -> jump $j1_s5VF
                };
              1# ->
                case GHC.Prim.<=# ww_s8sp 1# of {
                  __DEFAULT -> GHC.Types.False;
                  1# -> jump $j1_s5VF
                }
            } } in
      case GHC.Prim.>=# ww1_s8su 0# of {
        __DEFAULT ->
          case ww1_s8su of {
            __DEFAULT -> jump $j_s5VJ;
            -2# -> Util.validCastle_$s$wvalidCastle1 w1_s8sj -2# ww_s8sp w_s8sh
          };
        1# ->
          case ww1_s8su of {
            __DEFAULT -> jump $j_s5VJ;
            2# -> Util.validCastle_$s$wvalidCastle1 w1_s8sj 2# ww_s8sp w_s8sh
          }
      }

-- RHS size: {terms: 140, types: 102, coercions: 0, joins: 0/0}
Util.validCastle_$s$wvalidCastle
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> Int
     -> GHC.Prim.Int#
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> Bool
[GblId,
 Arity=7,
 Str=<L,U><L,1*U(1*U)><S,1*U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 20 30 0 60 0 0] 760 100}]
Util.validCastle_$s$wvalidCastle
  = \ (sc_saAB :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saAA :: Int)
      (sc2_saAz :: GHC.Prim.Int#)
      (sc3_saAv :: PieceType)
      (sc4_saAw :: Colour)
      (sc5_saAx :: (Int, Int))
      (sc6_saAy :: Int) ->
      case sc2_saAz of {
        __DEFAULT -> GHC.Types.False;
        0# ->
          case sc1_saAA of { GHC.Types.I# ds1_d54x ->
          case ds1_d54x of {
            __DEFAULT -> GHC.Types.False;
            -2# ->
              case Util.$wisStraightMovePathEmpty sc5_saAx 0# -3# sc_saAB of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc4_saAw of {
                            Black -> Util.executeCastle4;
                            White -> Util.executeCastle3
                          })
                         sc_saAB
                  of {
                    [] -> GHC.Types.False;
                    : ds3_a5jz ds4_a5jA ->
                      case findPiece (findKing sc4_saAw sc_saAB) sc_saAB of {
                        [] -> case GHC.List.badHead of wild4_00 { };
                        : x_a4SP ds5_a4SQ ->
                          case x_a4SP of { (ds6_d4Vi, ds7_d4Vj, ds8_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds3_a5jz of { (ds9_X517, ds10_X519, ds11_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# ->
                                  Util.clearCastlePath_$sclearCastlePath2
                                    sc_saAB sc3_saAv sc4_saAw sc5_saAx sc6_saAy
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              };
            2# ->
              case Util.$wisStraightMovePathEmpty sc5_saAx 0# 2# sc_saAB of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case sc4_saAw of {
                            Black -> Util.executeCastle2;
                            White -> Util.executeCastle1
                          })
                         sc_saAB
                  of {
                    [] -> GHC.Types.False;
                    : ds3_a5jz ds4_a5jA ->
                      case findPiece (findKing sc4_saAw sc_saAB) sc_saAB of {
                        [] -> case GHC.List.badHead of wild4_00 { };
                        : x_a4SP ds5_a4SQ ->
                          case x_a4SP of { (ds6_d4Vi, ds7_d4Vj, ds8_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds3_a5jz of { (ds9_X517, ds10_X519, ds11_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# ->
                                  Util.clearCastlePath_$sclearCastlePath
                                    sc_saAB (sc3_saAv, sc4_saAw, sc5_saAx, sc6_saAy)
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              }
          }
          }
      }

-- RHS size: {terms: 142, types: 176, coercions: 0, joins: 0/7}
clearCastlePath :: Piece -> AllPieces -> Bool -> Bool
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U><S,1*U>,
 Unf=OtherCon []]
clearCastlePath
  = \ (p_a4gb :: Piece) (ps_a4gc :: AllPieces) (s_a4gd :: Bool) ->
      let {
        lvl4_s5LF :: Colour
        [LclId]
        lvl4_s5LF
          = case p_a4gb of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            colour_a3ZX
            } } in
      let {
        m_s5ID [Dmd=<L,U(U)>] :: Int
        [LclId]
        m_s5ID
          = case p_a4gb of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
            case colour_a3ZX of {
              Black -> Util.allPiecesMoved1;
              White -> Util.clearCastlePath10
            }
            } } in
      let {
        arg_s5UO [Dmd=<C(C(S)),C(C1(U))>]
          :: Int -> [(Int, Int)] -> [(Int, Int)]
        [LclId, Arity=2, Str=<L,U(U)><L,U>, Unf=OtherCon []]
        arg_s5UO
          = \ (ds_d53Q :: Int) (ds1_d53P [OS=OneShot] :: [(Int, Int)]) ->
              case Util.clearCastlePath_$sthreatenedBy1
                     (GHC.Types.:
                        @ (PieceType, Colour, (Int, Int), Movecount)
                        (TypeDefs.Pawn, lvl4_s5LF, (m_s5ID, ds_d53Q), Util.allPiecesMoved1)
                        ps_a4gc)
                     TypeDefs.Pawn
                     Util.clearCastlePath8
                     m_s5ID
                     ds_d53Q
              of {
                [] -> ds1_d53P;
                : ds2_a5jz ds3_a5jA ->
                  GHC.Types.: @ (Int, Int) (m_s5ID, ds_d53Q) ds1_d53P
              } } in
      case s_a4gd of {
        False ->
          letrec {
            $sgo_saym [Occ=LoopBreaker] :: Int -> [Int] -> [(Int, Int)]
            [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
            $sgo_saym
              = \ (sc_sayk :: Int) (sc1_sayl :: [Int]) ->
                  arg_s5UO sc_sayk (go_a24t sc1_sayl);
            go_a24t [Occ=LoopBreaker] :: [Int] -> [(Int, Int)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_a24t
              = \ (ds_a24u :: [Int]) ->
                  case ds_a24u of {
                    [] -> GHC.Types.[] @ (Int, Int);
                    : y_a24x ys_a24y -> arg_s5UO y_a24x (go_a24t ys_a24y)
                  }; } in
          case $sgo_saym Util.clearCastlePath13 Util.clearCastlePath11 of {
            [] ->
              case p_a4gb of ww_s8sP
              { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
              case Util.clearCastlePath_$sthreatenedBy
                     (GHC.Types.:
                        @ (PieceType, Colour, Pos, Movecount)
                        (TypeDefs.Pawn, ww2_s8sR, ww3_s8sS, ww4_s8sT)
                        (removePiece ww_s8sP ps_a4gc))
                     TypeDefs.Pawn
                     ww2_s8sR
                     ww3_s8sS
                     ww4_s8sT
              of {
                [] -> GHC.Types.True;
                : ds1_a5jz ds2_a5jA -> GHC.Types.False
              }
              };
            : ds1_a5jz ds2_a5jA -> GHC.Types.False
          };
        True ->
          letrec {
            $sgo_sayr [Occ=LoopBreaker] :: Int -> [Int] -> [(Int, Int)]
            [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
            $sgo_sayr
              = \ (sc_sayp :: Int) (sc1_sayq :: [Int]) ->
                  arg_s5UO sc_sayp (go_a24t sc1_sayq);
            go_a24t [Occ=LoopBreaker] :: [Int] -> [(Int, Int)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_a24t
              = \ (ds_a24u :: [Int]) ->
                  case ds_a24u of {
                    [] -> GHC.Types.[] @ (Int, Int);
                    : y_a24x ys_a24y -> arg_s5UO y_a24x (go_a24t ys_a24y)
                  }; } in
          case $sgo_sayr Util.clearCastlePath7 Util.clearCastlePath5 of {
            [] ->
              case p_a4gb of ww_s8sP
              { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
              case Util.clearCastlePath_$sthreatenedBy
                     (GHC.Types.:
                        @ (PieceType, Colour, Pos, Movecount)
                        (TypeDefs.Pawn, ww2_s8sR, ww3_s8sS, ww4_s8sT)
                        (removePiece ww_s8sP ps_a4gc))
                     TypeDefs.Pawn
                     ww2_s8sR
                     ww3_s8sS
                     ww4_s8sT
              of {
                [] -> GHC.Types.True;
                : ds1_a5jz ds2_a5jA -> GHC.Types.False
              }
              };
            : ds1_a5jz ds2_a5jA -> GHC.Types.False
          }
      }

-- RHS size: {terms: 67, types: 67, coercions: 0, joins: 0/1}
threatenedBy :: Piece -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Str=<L,U(A,A,U(U(U),U(U)),A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 0] 342 0}]
threatenedBy
  = \ (p_a4f7 :: Piece) (ps_a4f8 :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Piece;
                : y_a24x ys_a24y ->
                  case y_a24x of ww_s8sC
                  { (ww1_s8sD, ww2_s8sE, ww3_s8sF, ww4_s8sG) ->
                  case Util.clearCastlePath_$s$wisValidMove
                         ps_a4f8
                         (case p_a4f7 of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                          case pos_a3ZY of { (row_a3ZW, ds4_d52J) ->
                          case row_a3ZW of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (row1_X47T, ds5_X5aH) ->
                          case row1_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          }
                          }
                          })
                         (case p_a4f7 of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                          case pos_a3ZY of { (ds4_d52T, col_a3ZV) ->
                          case col_a3ZV of { GHC.Types.I# x_a5lB ->
                          case ww3_s8sF of { (ds5_X5aQ, col1_X47T) ->
                          case col1_X47T of { GHC.Types.I# y1_a5lE ->
                          GHC.Types.I# (GHC.Prim.-# x_a5lB y1_a5lE)
                          }
                          }
                          }
                          }
                          })
                         ww4_s8sG
                         ww3_s8sF
                         ww2_s8sE
                         ww1_s8sD
                  of {
                    False -> go_a24t ys_a24y;
                    True -> GHC.Types.: @ Piece ww_s8sC (go_a24t ys_a24y)
                  }
                  }
              }; } in
      go_a24t ps_a4f8

-- RHS size: {terms: 125, types: 54, coercions: 0, joins: 0/1}
Util.$wisValidMove [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour -> Pos -> Movecount -> Move -> AllPieces -> Bool
[GblId,
 Arity=6,
 Str=<S,1*U><L,U><L,U(U(U),U(U))><L,U(U)><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [590 0 0 0 100 0] 750 30}]
Util.$wisValidMove
  = \ (ww_s8sD :: PieceType)
      (ww1_s8sE :: Colour)
      (ww2_s8sF :: Pos)
      (ww3_s8sG :: Movecount)
      (w_s8sz :: Move)
      (w1_s8sA :: AllPieces) ->
      case ww_s8sD of {
        Pawn ->
          case Util.$wisPawnValidMove ww1_s8sE ww2_s8sF w_s8sz w1_s8sA of {
            False ->
              case w_s8sz of { (ww5_s8qa, ww6_s8qf) ->
              case ww5_s8qa of { GHC.Types.I# ww8_s8qd ->
              Util.$wisValidEnPassant ww1_s8sE ww2_s8sF ww8_s8qd ww6_s8qf w1_s8sA
              }
              };
            True -> GHC.Types.True
          };
        Knight ->
          case Util.$wisValidTarget ww1_s8sE ww2_s8sF w_s8sz w1_s8sA of {
            False -> GHC.Types.False;
            True -> isLShaped w_s8sz
          };
        Bishop ->
          case w_s8sz of { (ww5_s8rw, ww6_s8rB) ->
          case ww5_s8rw of { GHC.Types.I# ww8_s8rz ->
          case ww6_s8rB of { GHC.Types.I# ww10_s8rE ->
          Util.$wisBishopValidMove
            (TypeDefs.Bishop, ww1_s8sE, ww2_s8sF, ww3_s8sG)
            ww8_s8rz
            ww10_s8rE
            w1_s8sA
          }
          }
          };
        Rook ->
          case w_s8sz of { (ww5_s8rN, ww6_s8rS) ->
          case ww5_s8rN of { GHC.Types.I# ww8_s8rQ ->
          Util.$wisRookValidMove
            (TypeDefs.Rook, ww1_s8sE, ww2_s8sF, ww3_s8sG)
            ww8_s8rQ
            ww6_s8rS
            w1_s8sA
          }
          };
        Queen ->
          case w_s8sz of { (ww5_s8rN, ww6_s8rS) ->
          case ww5_s8rN of { GHC.Types.I# ww8_s8rQ ->
          let {
            p_s5Ix [Dmd=<L,U(A,U,U(U(U),U(U)),A)>] :: Piece
            [LclId, Unf=OtherCon []]
            p_s5Ix = (TypeDefs.Queen, ww1_s8sE, ww2_s8sF, ww3_s8sG) } in
          case Util.$wisRookValidMove p_s5Ix ww8_s8rQ ww6_s8rS w1_s8sA of {
            False ->
              case ww6_s8rS of { GHC.Types.I# ww10_s8rE ->
              Util.$wisBishopValidMove p_s5Ix ww8_s8rQ ww10_s8rE w1_s8sA
              };
            True -> GHC.Types.True
          }
          }
          };
        King ->
          case w_s8sz of { (ww5_s8sm, ww6_s8sr) ->
          case ww5_s8sm of { GHC.Types.I# ww8_s8sp ->
          case ww6_s8sr of { GHC.Types.I# ww10_s8su ->
          Util.clearCastlePath_$s$wvalidKingMove
            w1_s8sA ww10_s8su ww8_s8sp TypeDefs.King ww1_s8sE ww2_s8sF ww3_s8sG
          }
          }
          }
      }

-- RHS size: {terms: 148, types: 140, coercions: 0, joins: 0/0}
Util.$wvalidCastle [InlPrag=NOUSERINLINE[2]]
  :: Piece -> GHC.Prim.Int# -> Int -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,1*U><L,1*U(1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 30 20 0] 780 100}]
Util.$wvalidCastle
  = \ (w_s8t3 :: Piece)
      (ww_s8tb :: GHC.Prim.Int#)
      (ww1_s8td :: Int)
      (w1_s8t5 :: AllPieces) ->
      case ww_s8tb of {
        __DEFAULT -> GHC.Types.False;
        0# ->
          case ww1_s8td of { GHC.Types.I# ds1_d54x ->
          case ds1_d54x of {
            __DEFAULT -> GHC.Types.False;
            -2# ->
              case Util.$wisStraightMovePathEmpty
                     (case w_s8t3 of { (ds3_d4Xh, ds4_d4Xi, pos_a3ZY, ds5_d4Xj) ->
                      pos_a3ZY
                      })
                     0#
                     -3#
                     w1_s8t5
              of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case w_s8t3 of { (ds3_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
                          case colour_a3ZX of {
                            Black -> Util.executeCastle4;
                            White -> Util.executeCastle3
                          }
                          })
                         w1_s8t5
                  of {
                    [] -> GHC.Types.False;
                    : ds3_a5jz ds4_a5jA ->
                      case findPiece
                             (findKing
                                (case w_s8t3 of { (ds5_d529, colour_a3ZX, ds6_d52a, ds7_d52b) ->
                                 colour_a3ZX
                                 })
                                w1_s8t5)
                             w1_s8t5
                      of {
                        [] -> case GHC.List.badHead of wild4_00 { };
                        : x_a4SP ds5_a4SQ ->
                          case x_a4SP of { (ds6_d4Vi, ds7_d4Vj, ds8_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds3_a5jz of { (ds9_X517, ds10_X519, ds11_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# -> Util.clearCastlePath_$sclearCastlePath1 w1_s8t5 w_s8t3
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              };
            2# ->
              case Util.$wisStraightMovePathEmpty
                     (case w_s8t3 of { (ds3_d4Xh, ds4_d4Xi, pos_a3ZY, ds5_d4Xj) ->
                      pos_a3ZY
                      })
                     0#
                     2#
                     w1_s8t5
              of {
                False -> GHC.Types.False;
                True ->
                  case findPiece
                         (case w_s8t3 of { (ds3_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
                          case colour_a3ZX of {
                            Black -> Util.executeCastle2;
                            White -> Util.executeCastle1
                          }
                          })
                         w1_s8t5
                  of {
                    [] -> GHC.Types.False;
                    : ds3_a5jz ds4_a5jA ->
                      case findPiece
                             (findKing
                                (case w_s8t3 of { (ds5_d529, colour_a3ZX, ds6_d52a, ds7_d52b) ->
                                 colour_a3ZX
                                 })
                                w1_s8t5)
                             w1_s8t5
                      of {
                        [] -> case GHC.List.badHead of wild4_00 { };
                        : x_a4SP ds5_a4SQ ->
                          case x_a4SP of { (ds6_d4Vi, ds7_d4Vj, ds8_d4Vk, mc_a40p) ->
                          case mc_a40p of { GHC.Types.I# x1_a5hr ->
                          case x1_a5hr of {
                            __DEFAULT -> GHC.Types.False;
                            0# ->
                              case ds3_a5jz of { (ds9_X517, ds10_X519, ds11_X51b, mc1_X46h) ->
                              case mc1_X46h of { GHC.Types.I# x2_X5qC ->
                              case x2_X5qC of {
                                __DEFAULT -> GHC.Types.False;
                                0# -> Util.clearCastlePath_$sclearCastlePath w1_s8t5 w_s8t3
                              }
                              }
                              }
                          }
                          }
                          }
                      }
                  }
              }
          }
          }
      }

-- RHS size: {terms: 17, types: 10, coercions: 0, joins: 0/0}
validKingMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S(SS(S)),1*U(1*U(U),1*U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8sh [Occ=Once] :: Piece)
                 (w1_s8si [Occ=Once!] :: Move)
                 (w2_s8sj [Occ=Once] :: AllPieces) ->
                 case w1_s8si of { (ww1_s8sm [Occ=Once!], ww2_s8sr [Occ=Once!]) ->
                 case ww1_s8sm of { GHC.Types.I# ww4_s8sp [Occ=Once] ->
                 case ww2_s8sr of { GHC.Types.I# ww6_s8su [Occ=Once] ->
                 Util.$wvalidKingMove w_s8sh ww4_s8sp ww6_s8su w2_s8sj
                 }
                 }
                 }}]
validKingMove
  = \ (w_s8sh :: Piece) (w1_s8si :: Move) (w2_s8sj :: AllPieces) ->
      case w1_s8si of { (ww1_s8sm, ww2_s8sr) ->
      case ww1_s8sm of { GHC.Types.I# ww4_s8sp ->
      case ww2_s8sr of { GHC.Types.I# ww6_s8su ->
      Util.$wvalidKingMove w_s8sh ww4_s8sp ww6_s8su w2_s8sj
      }
      }
      }

-- RHS size: {terms: 13, types: 8, coercions: 0, joins: 0/0}
isValidMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8sy [Occ=Once!] :: Piece)
                 (w1_s8sz [Occ=Once] :: Move)
                 (w2_s8sA [Occ=Once] :: AllPieces) ->
                 case w_s8sy of
                 { (ww1_s8sD [Occ=Once], ww2_s8sE [Occ=Once], ww3_s8sF [Occ=Once],
                    ww4_s8sG [Occ=Once]) ->
                 Util.$wisValidMove
                   ww1_s8sD ww2_s8sE ww3_s8sF ww4_s8sG w1_s8sz w2_s8sA
                 }}]
isValidMove
  = \ (w_s8sy :: Piece) (w1_s8sz :: Move) (w2_s8sA :: AllPieces) ->
      case w_s8sy of { (ww1_s8sD, ww2_s8sE, ww3_s8sF, ww4_s8sG) ->
      Util.$wisValidMove
        ww1_s8sD ww2_s8sE ww3_s8sF ww4_s8sG w1_s8sz w2_s8sA
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Util.$wisKingInCheck [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> Pos -> Movecount -> AllPieces -> Bool
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U(U(U),U(U))><L,U(U)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0] 140 20}]
Util.$wisKingInCheck
  = \ (ww_s8sQ :: PieceType)
      (ww1_s8sR :: Colour)
      (ww2_s8sS :: Pos)
      (ww3_s8sT :: Movecount)
      (w_s8sN :: AllPieces) ->
      case Util.clearCastlePath_$sthreatenedBy
             (GHC.Types.:
                @ (PieceType, Colour, Pos, Movecount)
                (TypeDefs.Pawn, ww1_s8sR, ww2_s8sS, ww3_s8sT)
                (removePiece (ww_s8sQ, ww1_s8sR, ww2_s8sS, ww3_s8sT) w_s8sN))
             TypeDefs.Pawn
             ww1_s8sR
             ww2_s8sS
             ww3_s8sT
      of {
        [] -> GHC.Types.False;
        : ds1_a5jz ds2_a5jA -> GHC.Types.True
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
isKingInCheck [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<S,1*U(U,U,U(U(U),U(U)),U(U))><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8sM [Occ=Once!] :: Piece)
                 (w1_s8sN [Occ=Once] :: AllPieces) ->
                 case w_s8sM of
                 { (ww1_s8sQ [Occ=Once], ww2_s8sR [Occ=Once], ww3_s8sS [Occ=Once],
                    ww4_s8sT [Occ=Once]) ->
                 Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT w1_s8sN
                 }}]
isKingInCheck
  = \ (w_s8sM :: Piece) (w1_s8sN :: AllPieces) ->
      case w_s8sM of { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
      Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT w1_s8sN
      }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
validCastle [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S(S(S)L),1*U(1*U(1*U),1*U(1*U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8t3 [Occ=Once] :: Piece)
                 (w1_s8t4 [Occ=Once!] :: Move)
                 (w2_s8t5 [Occ=Once] :: AllPieces) ->
                 case w1_s8t4 of { (ww1_s8t8 [Occ=Once!], ww2_s8td [Occ=Once]) ->
                 case ww1_s8t8 of { GHC.Types.I# ww4_s8tb [Occ=Once] ->
                 Util.$wvalidCastle w_s8t3 ww4_s8tb ww2_s8td w2_s8t5
                 }
                 }}]
validCastle
  = \ (w_s8t3 :: Piece) (w1_s8t4 :: Move) (w2_s8t5 :: AllPieces) ->
      case w1_s8t4 of { (ww1_s8t8, ww2_s8td) ->
      case ww1_s8t8 of { GHC.Types.I# ww4_s8tb ->
      Util.$wvalidCastle w_s8t3 ww4_s8tb ww2_s8td w2_s8t5
      }
      }

Rec {
-- RHS size: {terms: 124, types: 86, coercions: 0, joins: 0/0}
Util.executeCastle_$s$wexecuteCastle1
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> AllPieces
[GblId,
 Arity=7,
 Str=<L,U><L,1*U><S,1*U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 322 30 0 60 40 40] 614 60}]
Util.executeCastle_$s$wexecuteCastle1
  = \ (sc_saxy :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saxx :: GHC.Prim.Int#)
      (sc2_saxw :: GHC.Prim.Int#)
      (sc3_saxs :: PieceType)
      (sc4_saxt :: Colour)
      (sc5_saxu :: (Int, Int))
      (sc6_saxv :: Int) ->
      case sc2_saxw of {
        __DEFAULT -> sc_saxy;
        0# ->
          case sc1_saxx of {
            __DEFAULT -> sc_saxy;
            -2# ->
              GHC.Types.:
                @ Piece
                (sc3_saxs, sc4_saxt,
                 case sc5_saxu of { (a_a40e, b_a40f) ->
                 (a_a40e,
                  case b_a40f of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ -2#)
                  })
                 },
                 case sc6_saxv of { GHC.Types.I# x_a5kQ ->
                 GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                 })
                (case findPiece
                        (case sc4_saxt of {
                           Black -> Util.executeCastle4;
                           White -> Util.executeCastle3
                         })
                        sc_saxy
                 of {
                   [] -> case GHC.List.badHead of wild1_00 { };
                   : x_a4SP ds2_a4SQ ->
                     case x_a4SP of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                     removePiece
                       (sc3_saxs, sc4_saxt, sc5_saxu, sc6_saxv)
                       (Util.captureEnPassant_$s$wexecuteMove
                          sc_saxy 3# 0# ww4_s8tV ww3_s8tU ww2_s8tT ww1_s8tS)
                     }
                 });
            2# ->
              GHC.Types.:
                @ Piece
                (sc3_saxs, sc4_saxt,
                 case sc5_saxu of { (a_a40e, b_a40f) ->
                 (a_a40e,
                  case b_a40f of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                  })
                 },
                 case sc6_saxv of { GHC.Types.I# x_a5kQ ->
                 GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                 })
                (case findPiece
                        (case sc4_saxt of {
                           Black -> Util.executeCastle2;
                           White -> Util.executeCastle1
                         })
                        sc_saxy
                 of {
                   [] -> case GHC.List.badHead of wild1_00 { };
                   : x_a4SP ds2_a4SQ ->
                     case x_a4SP of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                     removePiece
                       (sc3_saxs, sc4_saxt, sc5_saxu, sc6_saxv)
                       (Util.captureEnPassant_$s$wexecuteMove
                          sc_saxy -2# 0# ww4_s8tV ww3_s8tU ww2_s8tT ww1_s8tS)
                     }
                 })
          }
      }

-- RHS size: {terms: 35, types: 31, coercions: 0, joins: 0/0}
Util.captureEnPassant_$s$wcaptureEnPassant
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> Int
     -> (Int, Int)
     -> Colour
     -> PieceType
     -> AllPieces
[GblId,
 Arity=7,
 Str=<L,U><L,U><L,U><L,U(U)><L,U(U(U),U(U))><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 20 0 0] 201 0}]
Util.captureEnPassant_$s$wcaptureEnPassant
  = \ (sc_saxG :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saxF :: GHC.Prim.Int#)
      (sc2_saxE :: GHC.Prim.Int#)
      (sc3_saxD :: Int)
      (sc4_saxC :: (Int, Int))
      (sc5_saxB :: Colour)
      (sc6_saxA :: PieceType) ->
      Util.captureEnPassant_$s$wexecuteMove
        (removePiece
           (case findPiece
                   (case sc4_saxC of { (a_a40e, b_a40f) ->
                    (a_a40e,
                     case b_a40f of { GHC.Types.I# x_a5kQ ->
                     GHC.Types.I# (GHC.Prim.+# x_a5kQ sc1_saxF)
                     })
                    })
                   sc_saxG
            of {
              [] -> GHC.List.badHead @ Piece;
              : x_a4SP ds1_a4SQ -> x_a4SP
            })
           sc_saxG)
        sc1_saxF
        sc2_saxE
        sc3_saxD
        sc4_saxC
        sc5_saxB
        sc6_saxA

-- RHS size: {terms: 244, types: 143, coercions: 0, joins: 1/5}
Util.captureEnPassant_$s$wexecuteMove [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> Int
     -> (Int, Int)
     -> Colour
     -> PieceType
     -> AllPieces
[GblId,
 Arity=7,
 Str=<L,U><L,U><L,U><L,U(U)><L,U(U(U),U(U))><L,U><S,U>,
 Unf=OtherCon []]
Util.captureEnPassant_$s$wexecuteMove
  = \ (sc_saxc :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_saxb :: GHC.Prim.Int#)
      (sc2_saxa :: GHC.Prim.Int#)
      (sc3_sax9 :: Int)
      (sc4_sax8 :: (Int, Int))
      (sc5_sax7 :: Colour)
      (sc6_sax6 :: PieceType) ->
      let {
        wild_X1z [Dmd=<L,U(U,U,U(U(U),U(U)),U(U))>]
          :: (PieceType, Colour, Pos, Movecount)
        [LclId, Unf=OtherCon []]
        wild_X1z = (sc6_sax6, sc5_sax7, sc4_sax8, sc3_sax9) } in
      let {
        move_s8K2 [Dmd=<L,U(U)>] :: Int
        [LclId, Unf=OtherCon []]
        move_s8K2 = GHC.Types.I# sc2_saxa } in
      let {
        move1_sb33 [Dmd=<L,U(U)>] :: Int
        [LclId, Unf=OtherCon []]
        move1_sb33 = GHC.Types.I# sc1_saxb } in
      let {
        move2_a4fQ [Dmd=<L,U(U(U),U(U))>] :: Move
        [LclId, Unf=OtherCon []]
        move2_a4fQ = (move_s8K2, move1_sb33) } in
      join {
        $j_s6zQ [Dmd=<L,1*U>] :: AllPieces
        [LclId[JoinId(0)]]
        $j_s6zQ
          = case Util.clearCastlePath_$s$wvalidCastle
                   sc_saxc sc1_saxb sc2_saxa sc6_sax6 sc5_sax7 sc4_sax8 sc3_sax9
            of {
              False ->
                case Util.$wisValidEnPassant
                       sc5_sax7 sc4_sax8 sc2_saxa (GHC.Types.I# sc1_saxb) sc_saxc
                of {
                  False ->
                    case isTargetEnemy wild_X1z move2_a4fQ sc_saxc of {
                      False ->
                        resetEnemyPawns
                          sc5_sax7
                          (GHC.Types.:
                             @ Piece
                             (sc6_sax6, sc5_sax7,
                              case sc4_sax8 of { (a_a40e, b_a40f) ->
                              (case a_a40e of { GHC.Types.I# x_a5kQ ->
                               GHC.Types.I# (GHC.Prim.+# x_a5kQ sc2_saxa)
                               },
                               case b_a40f of { GHC.Types.I# x_a5kQ ->
                               GHC.Types.I# (GHC.Prim.+# x_a5kQ sc1_saxb)
                               })
                              },
                              case sc3_sax9 of { GHC.Types.I# x_a5kQ ->
                              GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                              })
                             (removePiece wild_X1z sc_saxc));
                      True ->
                        case findPiece
                               (case sc4_sax8 of { (a_a40e, b_a40f) ->
                                (case a_a40e of { GHC.Types.I# x_a5kQ ->
                                 GHC.Types.I# (GHC.Prim.+# x_a5kQ sc2_saxa)
                                 },
                                 case b_a40f of { GHC.Types.I# x_a5kQ ->
                                 GHC.Types.I# (GHC.Prim.+# x_a5kQ sc1_saxb)
                                 })
                                })
                               sc_saxc
                        of {
                          [] -> case GHC.List.badHead of wild5_00 { };
                          : x_a4SP ds1_a4SQ ->
                            case x_a4SP of wild5_X2b
                            { (p_a4fC, colour_a4fD, pos_a4fE, mc_a4fF) ->
                            resetEnemyPawns
                              sc5_sax7
                              (GHC.Types.:
                                 @ (PieceType, Colour, (Int, Int), Movecount)
                                 (p_a4fC, colour_a4fD, Util.findKing1, Util.allPiecesMoved1)
                                 (removePiece
                                    wild5_X2b
                                    (GHC.Types.:
                                       @ Piece
                                       (sc6_sax6, sc5_sax7,
                                        case sc4_sax8 of { (a_a40e, b_a40f) ->
                                        (case a_a40e of { GHC.Types.I# x1_a5kQ ->
                                         GHC.Types.I# (GHC.Prim.+# x1_a5kQ sc2_saxa)
                                         },
                                         case b_a40f of { GHC.Types.I# x1_a5kQ ->
                                         GHC.Types.I# (GHC.Prim.+# x1_a5kQ sc1_saxb)
                                         })
                                        },
                                        case sc3_sax9 of { GHC.Types.I# x1_a5kQ ->
                                        GHC.Types.I# (GHC.Prim.+# x1_a5kQ 2#)
                                        })
                                       (removePiece wild_X1z sc_saxc))))
                            }
                        }
                    };
                  True ->
                    resetEnemyPawns
                      sc5_sax7
                      (Util.captureEnPassant_$s$wcaptureEnPassant
                         sc_saxc sc1_saxb sc2_saxa sc3_sax9 sc4_sax8 sc5_sax7 sc6_sax6)
                };
              True ->
                resetEnemyPawns
                  sc5_sax7
                  (Util.executeCastle_$s$wexecuteCastle1
                     sc_saxc sc1_saxb sc2_saxa sc6_sax6 sc5_sax7 sc4_sax8 sc3_sax9)
            } } in
      case sc6_sax6 of {
        Pawn ->
          case Util.$wisPawnValidMove sc5_sax7 sc4_sax8 move2_a4fQ sc_saxc
          of {
            False -> jump $j_s6zQ;
            True ->
              case sc4_sax8 of { (a_a40e, b_a40f) ->
              case a_a40e of { GHC.Types.I# x_a5kQ ->
              case sc5_sax7 of {
                Black ->
                  case GHC.Prim.+# x_a5kQ sc2_saxa of {
                    __DEFAULT -> jump $j_s6zQ;
                    7# ->
                      case Util.$wpromotePawn wild_X1z move2_a4fQ sc_saxc of
                      { (# ww1_s8wd, ww2_s8we #) ->
                      resetEnemyPawns
                        TypeDefs.Black (GHC.Types.: @ Piece ww1_s8wd ww2_s8we)
                      }
                  };
                White ->
                  case GHC.Prim.+# x_a5kQ sc2_saxa of {
                    __DEFAULT -> jump $j_s6zQ;
                    0# ->
                      case Util.$wpromotePawn wild_X1z move2_a4fQ sc_saxc of
                      { (# ww1_s8wd, ww2_s8we #) ->
                      resetEnemyPawns
                        TypeDefs.White (GHC.Types.: @ Piece ww1_s8wd ww2_s8we)
                      }
                  }
              }
              }
              }
          };
        Knight -> jump $j_s6zQ;
        Bishop -> jump $j_s6zQ;
        Rook -> jump $j_s6zQ;
        Queen -> jump $j_s6zQ;
        King -> jump $j_s6zQ
      }
end Rec }

-- RHS size: {terms: 127, types: 88, coercions: 0, joins: 0/0}
Util.executeCastle_$s$wexecuteCastle
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> Int
     -> GHC.Prim.Int#
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> AllPieces
[GblId,
 Arity=7,
 Str=<L,U><L,1*U(1*U)><S,1*U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 20 30 0 60 40 40] 624 60}]
Util.executeCastle_$s$wexecuteCastle
  = \ (sc_sawX :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_sawW :: Int)
      (sc2_sawV :: GHC.Prim.Int#)
      (sc3_sawR :: PieceType)
      (sc4_sawS :: Colour)
      (sc5_sawT :: (Int, Int))
      (sc6_sawU :: Int) ->
      case sc2_sawV of {
        __DEFAULT -> sc_sawX;
        0# ->
          case sc1_sawW of { GHC.Types.I# ds1_d56e ->
          case ds1_d56e of {
            __DEFAULT -> sc_sawX;
            -2# ->
              GHC.Types.:
                @ Piece
                (sc3_sawR, sc4_sawS,
                 case sc5_sawT of { (a_a40e, b_a40f) ->
                 (a_a40e,
                  case b_a40f of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ -2#)
                  })
                 },
                 case sc6_sawU of { GHC.Types.I# x_a5kQ ->
                 GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                 })
                (case findPiece
                        (case sc4_sawS of {
                           Black -> Util.executeCastle4;
                           White -> Util.executeCastle3
                         })
                        sc_sawX
                 of {
                   [] -> case GHC.List.badHead of wild2_00 { };
                   : x_a4SP ds3_a4SQ ->
                     case x_a4SP of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                     removePiece
                       (sc3_sawR, sc4_sawS, sc5_sawT, sc6_sawU)
                       (Util.captureEnPassant_$s$wexecuteMove
                          sc_sawX 3# 0# ww4_s8tV ww3_s8tU ww2_s8tT ww1_s8tS)
                     }
                 });
            2# ->
              GHC.Types.:
                @ Piece
                (sc3_sawR, sc4_sawS,
                 case sc5_sawT of { (a_a40e, b_a40f) ->
                 (a_a40e,
                  case b_a40f of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                  })
                 },
                 case sc6_sawU of { GHC.Types.I# x_a5kQ ->
                 GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                 })
                (case findPiece
                        (case sc4_sawS of {
                           Black -> Util.executeCastle2;
                           White -> Util.executeCastle1
                         })
                        sc_sawX
                 of {
                   [] -> case GHC.List.badHead of wild2_00 { };
                   : x_a4SP ds3_a4SQ ->
                     case x_a4SP of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                     removePiece
                       (sc3_sawR, sc4_sawS, sc5_sawT, sc6_sawU)
                       (Util.captureEnPassant_$s$wexecuteMove
                          sc_sawX -2# 0# ww4_s8tV ww3_s8tU ww2_s8tT ww1_s8tS)
                     }
                 })
          }
          }
      }

-- RHS size: {terms: 128, types: 96, coercions: 0, joins: 0/0}
Util.$wexecuteCastle [InlPrag=NOUSERINLINE[2]]
  :: Piece -> GHC.Prim.Int# -> Int -> AllPieces -> AllPieces
[GblId,
 Arity=4,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,1*U><L,1*U(1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [80 30 20 0] 644 60}]
Util.$wexecuteCastle
  = \ (w_s8tg :: Piece)
      (ww_s8to :: GHC.Prim.Int#)
      (ww1_s8tq :: Int)
      (w1_s8ti :: AllPieces) ->
      case ww_s8to of {
        __DEFAULT -> w1_s8ti;
        0# ->
          case ww1_s8tq of { GHC.Types.I# ds1_d56e ->
          case ds1_d56e of {
            __DEFAULT -> w1_s8ti;
            -2# ->
              GHC.Types.:
                @ Piece
                (case w_s8tg of { (ww3_s8nC, ww4_s8nD, ww5_s8nE, ww6_s8nF) ->
                 (ww3_s8nC, ww4_s8nD,
                  case ww5_s8nE of { (a_a40e, b_a40f) ->
                  (a_a40e,
                   case b_a40f of { GHC.Types.I# x_a5kQ ->
                   GHC.Types.I# (GHC.Prim.+# x_a5kQ -2#)
                   })
                  },
                  case ww6_s8nF of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                  })
                 })
                (case findPiece
                        (case w_s8tg of { (ds3_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
                         case colour_a3ZX of {
                           Black -> Util.executeCastle4;
                           White -> Util.executeCastle3
                         }
                         })
                        w1_s8ti
                 of {
                   [] -> case GHC.List.badHead of wild2_00 { };
                   : x_a4SP ds3_a4SQ ->
                     case x_a4SP of { (ww3_s8tS, ww4_s8tT, ww5_s8tU, ww6_s8tV) ->
                     removePiece
                       w_s8tg
                       (Util.captureEnPassant_$s$wexecuteMove
                          w1_s8ti 3# 0# ww6_s8tV ww5_s8tU ww4_s8tT ww3_s8tS)
                     }
                 });
            2# ->
              GHC.Types.:
                @ Piece
                (case w_s8tg of { (ww3_s8nC, ww4_s8nD, ww5_s8nE, ww6_s8nF) ->
                 (ww3_s8nC, ww4_s8nD,
                  case ww5_s8nE of { (a_a40e, b_a40f) ->
                  (a_a40e,
                   case b_a40f of { GHC.Types.I# x_a5kQ ->
                   GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                   })
                  },
                  case ww6_s8nF of { GHC.Types.I# x_a5kQ ->
                  GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                  })
                 })
                (case findPiece
                        (case w_s8tg of { (ds3_d529, colour_a3ZX, ds4_d52a, ds5_d52b) ->
                         case colour_a3ZX of {
                           Black -> Util.executeCastle2;
                           White -> Util.executeCastle1
                         }
                         })
                        w1_s8ti
                 of {
                   [] -> case GHC.List.badHead of wild2_00 { };
                   : x_a4SP ds3_a4SQ ->
                     case x_a4SP of { (ww3_s8tS, ww4_s8tT, ww5_s8tU, ww6_s8tV) ->
                     removePiece
                       w_s8tg
                       (Util.captureEnPassant_$s$wexecuteMove
                          w1_s8ti -2# 0# ww6_s8tV ww5_s8tU ww4_s8tT ww3_s8tS)
                     }
                 })
          }
          }
      }

Rec {
-- RHS size: {terms: 38, types: 24, coercions: 0, joins: 0/0}
Util.$wcaptureEnPassant [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> AllPieces
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 20 0 0 20 0] 211 0}]
Util.$wcaptureEnPassant
  = \ (ww_s8ty :: PieceType)
      (ww1_s8tz :: Colour)
      (ww2_s8tA :: Pos)
      (ww3_s8tB :: Movecount)
      (ww4_s8tI :: GHC.Prim.Int#)
      (ww5_s8tK :: Int)
      (w_s8tv :: AllPieces) ->
      Util.$wexecuteMove
        ww_s8ty
        ww1_s8tz
        ww2_s8tA
        ww3_s8tB
        ww4_s8tI
        ww5_s8tK
        (removePiece
           (case findPiece
                   (case ww2_s8tA of { (a_a40e, b_a40f) ->
                    (a_a40e,
                     case b_a40f of { GHC.Types.I# x_a5kQ ->
                     case ww5_s8tK of { GHC.Types.I# y_a5kT ->
                     GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                     }
                     })
                    })
                   w_s8tv
            of {
              [] -> GHC.List.badHead @ Piece;
              : x_a4SP ds1_a4SQ -> x_a4SP
            })
           w_s8tv)

-- RHS size: {terms: 235, types: 131, coercions: 0, joins: 1/4}
Util.$wexecuteMove [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> AllPieces
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=OtherCon []]
Util.$wexecuteMove
  = \ (ww_s8tS :: PieceType)
      (ww1_s8tT :: Colour)
      (ww2_s8tU :: Pos)
      (ww3_s8tV :: Movecount)
      (ww4_s8u2 :: GHC.Prim.Int#)
      (ww5_s8u4 :: Int)
      (w_s8tP :: AllPieces) ->
      let {
        wild_X1z [Dmd=<L,U(U,U,U(U(U),U(U)),U(U))>]
          :: (PieceType, Colour, Pos, Movecount)
        [LclId, Unf=OtherCon []]
        wild_X1z = (ww_s8tS, ww1_s8tT, ww2_s8tU, ww3_s8tV) } in
      let {
        move_s8K2 [Dmd=<L,U(U)>] :: Int
        [LclId, Unf=OtherCon []]
        move_s8K2 = GHC.Types.I# ww4_s8u2 } in
      let {
        move1_a4fQ [Dmd=<L,U(U(U),U(U))>] :: Move
        [LclId, Unf=OtherCon []]
        move1_a4fQ = (move_s8K2, ww5_s8u4) } in
      join {
        $j_s6zQ [Dmd=<L,1*U>] :: AllPieces
        [LclId[JoinId(0)]]
        $j_s6zQ
          = case Util.validCastle_$s$wvalidCastle
                   w_s8tP ww5_s8u4 ww4_s8u2 ww_s8tS ww1_s8tT ww2_s8tU ww3_s8tV
            of {
              False ->
                case Util.$wisValidEnPassant
                       ww1_s8tT ww2_s8tU ww4_s8u2 ww5_s8u4 w_s8tP
                of {
                  False ->
                    case isTargetEnemy wild_X1z move1_a4fQ w_s8tP of {
                      False ->
                        resetEnemyPawns
                          ww1_s8tT
                          (GHC.Types.:
                             @ Piece
                             (ww_s8tS, ww1_s8tT,
                              case ww2_s8tU of { (a_a40e, b_a40f) ->
                              (case a_a40e of { GHC.Types.I# x_a5kQ ->
                               GHC.Types.I# (GHC.Prim.+# x_a5kQ ww4_s8u2)
                               },
                               GHC.Num.$fNumInt_$c+ b_a40f ww5_s8u4)
                              },
                              case ww3_s8tV of { GHC.Types.I# x_a5kQ ->
                              GHC.Types.I# (GHC.Prim.+# x_a5kQ 2#)
                              })
                             (removePiece wild_X1z w_s8tP));
                      True ->
                        case findPiece
                               (case ww2_s8tU of { (a_a40e, b_a40f) ->
                                (case a_a40e of { GHC.Types.I# x_a5kQ ->
                                 GHC.Types.I# (GHC.Prim.+# x_a5kQ ww4_s8u2)
                                 },
                                 case b_a40f of { GHC.Types.I# x_a5kQ ->
                                 case ww5_s8u4 of { GHC.Types.I# y_a5kT ->
                                 GHC.Types.I# (GHC.Prim.+# x_a5kQ y_a5kT)
                                 }
                                 })
                                })
                               w_s8tP
                        of {
                          [] -> case GHC.List.badHead of wild5_00 { };
                          : x_a4SP ds1_a4SQ ->
                            case x_a4SP of wild5_X2b
                            { (p_a4fC, colour_a4fD, pos_a4fE, mc_a4fF) ->
                            resetEnemyPawns
                              ww1_s8tT
                              (GHC.Types.:
                                 @ (PieceType, Colour, (Int, Int), Movecount)
                                 (p_a4fC, colour_a4fD, Util.findKing1, Util.allPiecesMoved1)
                                 (removePiece
                                    wild5_X2b
                                    (GHC.Types.:
                                       @ Piece
                                       (ww_s8tS, ww1_s8tT,
                                        case ww2_s8tU of { (a_a40e, b_a40f) ->
                                        (case a_a40e of { GHC.Types.I# x1_a5kQ ->
                                         GHC.Types.I# (GHC.Prim.+# x1_a5kQ ww4_s8u2)
                                         },
                                         GHC.Num.$fNumInt_$c+ b_a40f ww5_s8u4)
                                        },
                                        case ww3_s8tV of { GHC.Types.I# x1_a5kQ ->
                                        GHC.Types.I# (GHC.Prim.+# x1_a5kQ 2#)
                                        })
                                       (removePiece wild_X1z w_s8tP))))
                            }
                        }
                    };
                  True ->
                    resetEnemyPawns
                      ww1_s8tT
                      (Util.$wcaptureEnPassant
                         ww_s8tS ww1_s8tT ww2_s8tU ww3_s8tV ww4_s8u2 ww5_s8u4 w_s8tP)
                };
              True ->
                resetEnemyPawns
                  ww1_s8tT
                  (Util.executeCastle_$s$wexecuteCastle
                     w_s8tP ww5_s8u4 ww4_s8u2 ww_s8tS ww1_s8tT ww2_s8tU ww3_s8tV)
            } } in
      case ww_s8tS of {
        Pawn ->
          case Util.$wisPawnValidMove ww1_s8tT ww2_s8tU move1_a4fQ w_s8tP
          of {
            False -> jump $j_s6zQ;
            True ->
              case ww2_s8tU of { (a_a40e, b_a40f) ->
              case a_a40e of { GHC.Types.I# x_a5kQ ->
              case ww1_s8tT of {
                Black ->
                  case GHC.Prim.+# x_a5kQ ww4_s8u2 of {
                    __DEFAULT -> jump $j_s6zQ;
                    7# ->
                      case Util.$wpromotePawn wild_X1z move1_a4fQ w_s8tP of
                      { (# ww7_s8wd, ww8_s8we #) ->
                      resetEnemyPawns
                        TypeDefs.Black (GHC.Types.: @ Piece ww7_s8wd ww8_s8we)
                      }
                  };
                White ->
                  case GHC.Prim.+# x_a5kQ ww4_s8u2 of {
                    __DEFAULT -> jump $j_s6zQ;
                    0# ->
                      case Util.$wpromotePawn wild_X1z move1_a4fQ w_s8tP of
                      { (# ww7_s8wd, ww8_s8we #) ->
                      resetEnemyPawns
                        TypeDefs.White (GHC.Types.: @ Piece ww7_s8wd ww8_s8we)
                      }
                  }
              }
              }
              }
          };
        Knight -> jump $j_s6zQ;
        Bishop -> jump $j_s6zQ;
        Rook -> jump $j_s6zQ;
        Queen -> jump $j_s6zQ;
        King -> jump $j_s6zQ
      }
end Rec }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
executeCastle [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S(S(S)L),1*U(1*U(1*U),1*U(1*U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8tg [Occ=Once] :: Piece)
                 (w1_s8th [Occ=Once!] :: Move)
                 (w2_s8ti [Occ=Once] :: AllPieces) ->
                 case w1_s8th of { (ww1_s8tl [Occ=Once!], ww2_s8tq [Occ=Once]) ->
                 case ww1_s8tl of { GHC.Types.I# ww4_s8to [Occ=Once] ->
                 Util.$wexecuteCastle w_s8tg ww4_s8to ww2_s8tq w2_s8ti
                 }
                 }}]
executeCastle
  = \ (w_s8tg :: Piece) (w1_s8th :: Move) (w2_s8ti :: AllPieces) ->
      case w1_s8th of { (ww1_s8tl, ww2_s8tq) ->
      case ww1_s8tl of { GHC.Types.I# ww4_s8to ->
      Util.$wexecuteCastle w_s8tg ww4_s8to ww2_s8tq w2_s8ti
      }
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
captureEnPassant [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8tt [Occ=Once!] :: Piece)
                 (w1_s8tu [Occ=Once!] :: Move)
                 (w2_s8tv [Occ=Once] :: AllPieces) ->
                 case w_s8tt of
                 { (ww1_s8ty [Occ=Once], ww2_s8tz [Occ=Once], ww3_s8tA [Occ=Once],
                    ww4_s8tB [Occ=Once]) ->
                 case w1_s8tu of { (ww6_s8tF [Occ=Once!], ww7_s8tK [Occ=Once]) ->
                 case ww6_s8tF of { GHC.Types.I# ww9_s8tI [Occ=Once] ->
                 Util.$wcaptureEnPassant
                   ww1_s8ty ww2_s8tz ww3_s8tA ww4_s8tB ww9_s8tI ww7_s8tK w2_s8tv
                 }
                 }
                 }}]
captureEnPassant
  = \ (w_s8tt :: Piece) (w1_s8tu :: Move) (w2_s8tv :: AllPieces) ->
      case w_s8tt of { (ww1_s8ty, ww2_s8tz, ww3_s8tA, ww4_s8tB) ->
      case w1_s8tu of { (ww6_s8tF, ww7_s8tK) ->
      case ww6_s8tF of { GHC.Types.I# ww9_s8tI ->
      Util.$wcaptureEnPassant
        ww1_s8ty ww2_s8tz ww3_s8tA ww4_s8tB ww9_s8tI ww7_s8tK w2_s8tv
      }
      }
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
executeMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8tN [Occ=Once!] :: Piece)
                 (w1_s8tO [Occ=Once!] :: Move)
                 (w2_s8tP [Occ=Once] :: AllPieces) ->
                 case w_s8tN of
                 { (ww1_s8tS [Occ=Once], ww2_s8tT [Occ=Once], ww3_s8tU [Occ=Once],
                    ww4_s8tV [Occ=Once]) ->
                 case w1_s8tO of { (ww6_s8tZ [Occ=Once!], ww7_s8u4 [Occ=Once]) ->
                 case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 [Occ=Once] ->
                 Util.$wexecuteMove
                   ww1_s8tS ww2_s8tT ww3_s8tU ww4_s8tV ww9_s8u2 ww7_s8u4 w2_s8tP
                 }
                 }
                 }}]
executeMove
  = \ (w_s8tN :: Piece) (w1_s8tO :: Move) (w2_s8tP :: AllPieces) ->
      case w_s8tN of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
      case w1_s8tO of { (ww6_s8tZ, ww7_s8u4) ->
      case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 ->
      Util.$wexecuteMove
        ww1_s8tS ww2_s8tT ww3_s8tU ww4_s8tV ww9_s8u2 ww7_s8u4 w2_s8tP
      }
      }
      }

-- RHS size: {terms: 28, types: 13, coercions: 0, joins: 0/1}
Util.$wwillKingBeInCheck [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> Bool
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 200 10}]
Util.$wwillKingBeInCheck
  = \ (ww_s8uc :: PieceType)
      (ww1_s8ud :: Colour)
      (ww2_s8ue :: Pos)
      (ww3_s8uf :: Movecount)
      (ww4_s8um :: GHC.Prim.Int#)
      (ww5_s8uo :: Int)
      (w_s8u9 :: AllPieces) ->
      let {
        n_s5Iv [Dmd=<S,U>] :: AllPieces
        [LclId]
        n_s5Iv
          = Util.$wexecuteMove
              ww_s8uc ww1_s8ud ww2_s8ue ww3_s8uf ww4_s8um ww5_s8uo w_s8u9 } in
      case findPiece (findKing ww1_s8ud n_s5Iv) n_s5Iv of {
        [] -> GHC.Types.False;
        : ds1_a5jz ds2_a5jA -> isKingInCheck ds1_a5jz n_s5Iv
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
willKingBeInCheck [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8u7 [Occ=Once!] :: Piece)
                 (w1_s8u8 [Occ=Once!] :: Move)
                 (w2_s8u9 [Occ=Once] :: AllPieces) ->
                 case w_s8u7 of
                 { (ww1_s8uc [Occ=Once], ww2_s8ud [Occ=Once], ww3_s8ue [Occ=Once],
                    ww4_s8uf [Occ=Once]) ->
                 case w1_s8u8 of { (ww6_s8uj [Occ=Once!], ww7_s8uo [Occ=Once]) ->
                 case ww6_s8uj of { GHC.Types.I# ww9_s8um [Occ=Once] ->
                 Util.$wwillKingBeInCheck
                   ww1_s8uc ww2_s8ud ww3_s8ue ww4_s8uf ww9_s8um ww7_s8uo w2_s8u9
                 }
                 }
                 }}]
willKingBeInCheck
  = \ (w_s8u7 :: Piece) (w1_s8u8 :: Move) (w2_s8u9 :: AllPieces) ->
      case w_s8u7 of { (ww1_s8uc, ww2_s8ud, ww3_s8ue, ww4_s8uf) ->
      case w1_s8u8 of { (ww6_s8uj, ww7_s8uo) ->
      case ww6_s8uj of { GHC.Types.I# ww9_s8um ->
      Util.$wwillKingBeInCheck
        ww1_s8uc ww2_s8ud ww3_s8ue ww4_s8uf ww9_s8um ww7_s8uo w2_s8u9
      }
      }
      }

-- RHS size: {terms: 1,241, types: 479, coercions: 0, joins: 0/57}
legalKnightMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=OtherCon []]
legalKnightMoves
  = \ (p_a4gh :: Piece) (ps_a4gi :: AllPieces) ->
      letrec {
        $sgo_savf [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Int] -> [Move]
        [LclId, Arity=2, Str=<S,U><L,1*U>, Unf=OtherCon []]
        $sgo_savf
          = \ (sc_savd :: GHC.Prim.Int#) (sc1_save :: [Int]) ->
              let {
                z4_X2b6 :: [Move]
                [LclId]
                z4_X2b6 = go_a24t sc1_save } in
              case Util.$wisLShaped sc_savd z_rcj3 of {
                False ->
                  letrec {
                    $sgo1_savi [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                    [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                    $sgo1_savi
                      = \ (sc2_savg :: Int) (sc3_savh :: [Int]) ->
                          case Util.$wisLShaped sc_savd sc2_savg of {
                            False -> go1_X2b9 sc3_savh;
                            True ->
                              case p_a4gh of ww_s8rk
                              { (ww1_s8rl, ww2_s8rm, ww3_s8rn, ww4_s8ro) ->
                              let {
                                ds_sb4X [Dmd=<L,U(U)>] :: Int
                                [LclId, Unf=OtherCon []]
                                ds_sb4X = GHC.Types.I# sc_savd } in
                              let {
                                ds1_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                [LclId, Unf=OtherCon []]
                                ds1_s5Ir = (ds_sb4X, sc2_savg) } in
                              case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds1_s5Ir ps_a4gi of {
                                False -> go1_X2b9 sc3_savh;
                                True ->
                                  case targetNotKing ww_s8rk ds1_s5Ir ps_a4gi of {
                                    False -> go1_X2b9 sc3_savh;
                                    True ->
                                      case Util.$wwillKingBeInCheck
                                             ww1_s8rl
                                             ww2_s8rm
                                             ww3_s8rn
                                             ww4_s8ro
                                             sc_savd
                                             sc2_savg
                                             ps_a4gi
                                      of {
                                        False -> GHC.Types.: @ Move ds1_s5Ir (go1_X2b9 sc3_savh);
                                        True -> go1_X2b9 sc3_savh
                                      }
                                  }
                              }
                              }
                          };
                    go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go1_X2b9
                      = \ (ds_X2bb :: [Int]) ->
                          case ds_X2bb of {
                            [] -> z4_X2b6;
                            : y_X2gy ys_X2gB ->
                              case Util.$wisLShaped sc_savd y_X2gy of {
                                False -> go1_X2b9 ys_X2gB;
                                True ->
                                  case p_a4gh of ww_s8rk
                                  { (ww1_s8rl, ww2_s8rm, ww3_s8rn, ww4_s8ro) ->
                                  let {
                                    ds1_sb59 [Dmd=<L,U(U)>] :: Int
                                    [LclId, Unf=OtherCon []]
                                    ds1_sb59 = GHC.Types.I# sc_savd } in
                                  let {
                                    ds2_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                    [LclId, Unf=OtherCon []]
                                    ds2_s5Ir = (ds1_sb59, y_X2gy) } in
                                  case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds2_s5Ir ps_a4gi of {
                                    False -> go1_X2b9 ys_X2gB;
                                    True ->
                                      case targetNotKing ww_s8rk ds2_s5Ir ps_a4gi of {
                                        False -> go1_X2b9 ys_X2gB;
                                        True ->
                                          case Util.$wwillKingBeInCheck
                                                 ww1_s8rl
                                                 ww2_s8rm
                                                 ww3_s8rn
                                                 ww4_s8ro
                                                 sc_savd
                                                 y_X2gy
                                                 ps_a4gi
                                          of {
                                            False -> GHC.Types.: @ Move ds2_s5Ir (go1_X2b9 ys_X2gB);
                                            True -> go1_X2b9 ys_X2gB
                                          }
                                      }
                                  }
                                  }
                              }
                          }; } in
                  $sgo1_savi Util.findKing2 z2_rcj5;
                True ->
                  case p_a4gh of ww_s8rk
                  { (ww1_s8rl, ww2_s8rm, ww3_s8rn, ww4_s8ro) ->
                  let {
                    ds_sb5h [Dmd=<L,U(U)>] :: Int
                    [LclId, Unf=OtherCon []]
                    ds_sb5h = GHC.Types.I# sc_savd } in
                  let {
                    ds1_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                    [LclId, Unf=OtherCon []]
                    ds1_s5Ir = (ds_sb5h, z_rcj3) } in
                  case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds1_s5Ir ps_a4gi of {
                    False ->
                      letrec {
                        $sgo1_savv [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                        [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                        $sgo1_savv
                          = \ (sc2_savt :: Int) (sc3_savu :: [Int]) ->
                              case Util.$wisLShaped sc_savd sc2_savt of {
                                False -> go1_X2b9 sc3_savu;
                                True ->
                                  let {
                                    ds2_sb5m [Dmd=<L,U(U)>] :: Int
                                    [LclId, Unf=OtherCon []]
                                    ds2_sb5m = GHC.Types.I# sc_savd } in
                                  let {
                                    ds3_X5Oe [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                    [LclId, Unf=OtherCon []]
                                    ds3_X5Oe = (ds2_sb5m, sc2_savt) } in
                                  case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds3_X5Oe ps_a4gi of {
                                    False -> go1_X2b9 sc3_savu;
                                    True ->
                                      case targetNotKing ww_s8rk ds3_X5Oe ps_a4gi of {
                                        False -> go1_X2b9 sc3_savu;
                                        True ->
                                          case Util.$wwillKingBeInCheck
                                                 ww1_s8rl
                                                 ww2_s8rm
                                                 ww3_s8rn
                                                 ww4_s8ro
                                                 sc_savd
                                                 sc2_savt
                                                 ps_a4gi
                                          of {
                                            False ->
                                              GHC.Types.: @ Move ds3_X5Oe (go1_X2b9 sc3_savu);
                                            True -> go1_X2b9 sc3_savu
                                          }
                                      }
                                  }
                              };
                        go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go1_X2b9
                          = \ (ds2_X2bb :: [Int]) ->
                              case ds2_X2bb of {
                                [] -> z4_X2b6;
                                : y_X2gM ys_X2gP ->
                                  case Util.$wisLShaped sc_savd y_X2gM of {
                                    False -> go1_X2b9 ys_X2gP;
                                    True ->
                                      let {
                                        ds3_sb5x [Dmd=<L,U(U)>] :: Int
                                        [LclId, Unf=OtherCon []]
                                        ds3_sb5x = GHC.Types.I# sc_savd } in
                                      let {
                                        ds4_X5Oe [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                        [LclId, Unf=OtherCon []]
                                        ds4_X5Oe = (ds3_sb5x, y_X2gM) } in
                                      case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds4_X5Oe ps_a4gi
                                      of {
                                        False -> go1_X2b9 ys_X2gP;
                                        True ->
                                          case targetNotKing ww_s8rk ds4_X5Oe ps_a4gi of {
                                            False -> go1_X2b9 ys_X2gP;
                                            True ->
                                              case Util.$wwillKingBeInCheck
                                                     ww1_s8rl
                                                     ww2_s8rm
                                                     ww3_s8rn
                                                     ww4_s8ro
                                                     sc_savd
                                                     y_X2gM
                                                     ps_a4gi
                                              of {
                                                False ->
                                                  GHC.Types.: @ Move ds4_X5Oe (go1_X2b9 ys_X2gP);
                                                True -> go1_X2b9 ys_X2gP
                                              }
                                          }
                                      }
                                  }
                              }; } in
                      $sgo1_savv Util.findKing2 z2_rcj5;
                    True ->
                      case targetNotKing ww_s8rk ds1_s5Ir ps_a4gi of {
                        False ->
                          letrec {
                            $sgo1_savI [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                            [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                            $sgo1_savI
                              = \ (sc2_savG :: Int) (sc3_savH :: [Int]) ->
                                  case Util.$wisLShaped sc_savd sc2_savG of {
                                    False -> go1_X2b9 sc3_savH;
                                    True ->
                                      let {
                                        ds2_sb5I [Dmd=<L,U(U)>] :: Int
                                        [LclId, Unf=OtherCon []]
                                        ds2_sb5I = GHC.Types.I# sc_savd } in
                                      let {
                                        ds3_X5Oh [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                        [LclId, Unf=OtherCon []]
                                        ds3_X5Oh = (ds2_sb5I, sc2_savG) } in
                                      case Util.$wisValidTarget ww2_s8rm ww3_s8rn ds3_X5Oh ps_a4gi
                                      of {
                                        False -> go1_X2b9 sc3_savH;
                                        True ->
                                          case targetNotKing ww_s8rk ds3_X5Oh ps_a4gi of {
                                            False -> go1_X2b9 sc3_savH;
                                            True ->
                                              case Util.$wwillKingBeInCheck
                                                     ww1_s8rl
                                                     ww2_s8rm
                                                     ww3_s8rn
                                                     ww4_s8ro
                                                     sc_savd
                                                     sc2_savG
                                                     ps_a4gi
                                              of {
                                                False ->
                                                  GHC.Types.: @ Move ds3_X5Oh (go1_X2b9 sc3_savH);
                                                True -> go1_X2b9 sc3_savH
                                              }
                                          }
                                      }
                                  };
                            go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                            go1_X2b9
                              = \ (ds2_X2bb :: [Int]) ->
                                  case ds2_X2bb of {
                                    [] -> z4_X2b6;
                                    : y_X2gP ys_X2gS ->
                                      case Util.$wisLShaped sc_savd y_X2gP of {
                                        False -> go1_X2b9 ys_X2gS;
                                        True ->
                                          let {
                                            ds3_sb5T [Dmd=<L,U(U)>] :: Int
                                            [LclId, Unf=OtherCon []]
                                            ds3_sb5T = GHC.Types.I# sc_savd } in
                                          let {
                                            ds4_X5Oh [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                            [LclId, Unf=OtherCon []]
                                            ds4_X5Oh = (ds3_sb5T, y_X2gP) } in
                                          case Util.$wisValidTarget
                                                 ww2_s8rm ww3_s8rn ds4_X5Oh ps_a4gi
                                          of {
                                            False -> go1_X2b9 ys_X2gS;
                                            True ->
                                              case targetNotKing ww_s8rk ds4_X5Oh ps_a4gi of {
                                                False -> go1_X2b9 ys_X2gS;
                                                True ->
                                                  case Util.$wwillKingBeInCheck
                                                         ww1_s8rl
                                                         ww2_s8rm
                                                         ww3_s8rn
                                                         ww4_s8ro
                                                         sc_savd
                                                         y_X2gP
                                                         ps_a4gi
                                                  of {
                                                    False ->
                                                      GHC.Types.:
                                                        @ Move ds4_X5Oh (go1_X2b9 ys_X2gS);
                                                    True -> go1_X2b9 ys_X2gS
                                                  }
                                              }
                                          }
                                      }
                                  }; } in
                          $sgo1_savI Util.findKing2 z2_rcj5;
                        True ->
                          case Util.$wwillKingBeInCheck
                                 ww1_s8rl ww2_s8rm ww3_s8rn ww4_s8ro sc_savd z_rcj3 ps_a4gi
                          of {
                            False ->
                              GHC.Types.:
                                @ Move
                                ds1_s5Ir
                                (letrec {
                                   $sgo1_savV [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                                   [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                                   $sgo1_savV
                                     = \ (sc2_savT :: Int) (sc3_savU :: [Int]) ->
                                         case Util.$wisLShaped sc_savd sc2_savT of {
                                           False -> go1_X2b9 sc3_savU;
                                           True ->
                                             let {
                                               ds2_sb64 [Dmd=<L,U(U)>] :: Int
                                               [LclId, Unf=OtherCon []]
                                               ds2_sb64 = GHC.Types.I# sc_savd } in
                                             let {
                                               ds3_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                               [LclId, Unf=OtherCon []]
                                               ds3_X5Ok = (ds2_sb64, sc2_savT) } in
                                             case Util.$wisValidTarget
                                                    ww2_s8rm ww3_s8rn ds3_X5Ok ps_a4gi
                                             of {
                                               False -> go1_X2b9 sc3_savU;
                                               True ->
                                                 case targetNotKing ww_s8rk ds3_X5Ok ps_a4gi of {
                                                   False -> go1_X2b9 sc3_savU;
                                                   True ->
                                                     case Util.$wwillKingBeInCheck
                                                            ww1_s8rl
                                                            ww2_s8rm
                                                            ww3_s8rn
                                                            ww4_s8ro
                                                            sc_savd
                                                            sc2_savT
                                                            ps_a4gi
                                                     of {
                                                       False ->
                                                         GHC.Types.:
                                                           @ Move ds3_X5Ok (go1_X2b9 sc3_savU);
                                                       True -> go1_X2b9 sc3_savU
                                                     }
                                                 }
                                             }
                                         };
                                   go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                                   [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                   go1_X2b9
                                     = \ (ds2_X2bb :: [Int]) ->
                                         case ds2_X2bb of {
                                           [] -> z4_X2b6;
                                           : y_X2gS ys_X2gV ->
                                             case Util.$wisLShaped sc_savd y_X2gS of {
                                               False -> go1_X2b9 ys_X2gV;
                                               True ->
                                                 let {
                                                   ds3_sb6f [Dmd=<L,U(U)>] :: Int
                                                   [LclId, Unf=OtherCon []]
                                                   ds3_sb6f = GHC.Types.I# sc_savd } in
                                                 let {
                                                   ds4_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                   [LclId, Unf=OtherCon []]
                                                   ds4_X5Ok = (ds3_sb6f, y_X2gS) } in
                                                 case Util.$wisValidTarget
                                                        ww2_s8rm ww3_s8rn ds4_X5Ok ps_a4gi
                                                 of {
                                                   False -> go1_X2b9 ys_X2gV;
                                                   True ->
                                                     case targetNotKing ww_s8rk ds4_X5Ok ps_a4gi
                                                     of {
                                                       False -> go1_X2b9 ys_X2gV;
                                                       True ->
                                                         case Util.$wwillKingBeInCheck
                                                                ww1_s8rl
                                                                ww2_s8rm
                                                                ww3_s8rn
                                                                ww4_s8ro
                                                                sc_savd
                                                                y_X2gS
                                                                ps_a4gi
                                                         of {
                                                           False ->
                                                             GHC.Types.:
                                                               @ Move ds4_X5Ok (go1_X2b9 ys_X2gV);
                                                           True -> go1_X2b9 ys_X2gV
                                                         }
                                                     }
                                                 }
                                             }
                                         }; } in
                                 $sgo1_savV Util.findKing2 z2_rcj5);
                            True ->
                              letrec {
                                $sgo1_saw8 [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                                [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                                $sgo1_saw8
                                  = \ (sc2_saw6 :: Int) (sc3_saw7 :: [Int]) ->
                                      case Util.$wisLShaped sc_savd sc2_saw6 of {
                                        False -> go1_X2b9 sc3_saw7;
                                        True ->
                                          let {
                                            ds2_sb6o [Dmd=<L,U(U)>] :: Int
                                            [LclId, Unf=OtherCon []]
                                            ds2_sb6o = GHC.Types.I# sc_savd } in
                                          let {
                                            ds3_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                            [LclId, Unf=OtherCon []]
                                            ds3_X5Ok = (ds2_sb6o, sc2_saw6) } in
                                          case Util.$wisValidTarget
                                                 ww2_s8rm ww3_s8rn ds3_X5Ok ps_a4gi
                                          of {
                                            False -> go1_X2b9 sc3_saw7;
                                            True ->
                                              case targetNotKing ww_s8rk ds3_X5Ok ps_a4gi of {
                                                False -> go1_X2b9 sc3_saw7;
                                                True ->
                                                  case Util.$wwillKingBeInCheck
                                                         ww1_s8rl
                                                         ww2_s8rm
                                                         ww3_s8rn
                                                         ww4_s8ro
                                                         sc_savd
                                                         sc2_saw6
                                                         ps_a4gi
                                                  of {
                                                    False ->
                                                      GHC.Types.:
                                                        @ Move ds3_X5Ok (go1_X2b9 sc3_saw7);
                                                    True -> go1_X2b9 sc3_saw7
                                                  }
                                              }
                                          }
                                      };
                                go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                go1_X2b9
                                  = \ (ds2_X2bb :: [Int]) ->
                                      case ds2_X2bb of {
                                        [] -> z4_X2b6;
                                        : y_X2gS ys_X2gV ->
                                          case Util.$wisLShaped sc_savd y_X2gS of {
                                            False -> go1_X2b9 ys_X2gV;
                                            True ->
                                              let {
                                                ds3_sb6z [Dmd=<L,U(U)>] :: Int
                                                [LclId, Unf=OtherCon []]
                                                ds3_sb6z = GHC.Types.I# sc_savd } in
                                              let {
                                                ds4_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                [LclId, Unf=OtherCon []]
                                                ds4_X5Ok = (ds3_sb6z, y_X2gS) } in
                                              case Util.$wisValidTarget
                                                     ww2_s8rm ww3_s8rn ds4_X5Ok ps_a4gi
                                              of {
                                                False -> go1_X2b9 ys_X2gV;
                                                True ->
                                                  case targetNotKing ww_s8rk ds4_X5Ok ps_a4gi of {
                                                    False -> go1_X2b9 ys_X2gV;
                                                    True ->
                                                      case Util.$wwillKingBeInCheck
                                                             ww1_s8rl
                                                             ww2_s8rm
                                                             ww3_s8rn
                                                             ww4_s8ro
                                                             sc_savd
                                                             y_X2gS
                                                             ps_a4gi
                                                      of {
                                                        False ->
                                                          GHC.Types.:
                                                            @ Move ds4_X5Ok (go1_X2b9 ys_X2gV);
                                                        True -> go1_X2b9 ys_X2gV
                                                      }
                                                  }
                                              }
                                          }
                                      }; } in
                              $sgo1_saw8 Util.findKing2 z2_rcj5
                          }
                      }
                  }
                  }
              };
        go_a24t [Occ=LoopBreaker] :: [Int] -> [Move]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Int]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Move;
                : y_a24x ys_a24y ->
                  let {
                    z4_X2b6 :: [Move]
                    [LclId]
                    z4_X2b6 = go_a24t ys_a24y } in
                  case y_a24x of ww_s8oL { GHC.Types.I# ww1_s8oM ->
                  case Util.$wisLShaped ww1_s8oM z_rcj3 of {
                    False ->
                      letrec {
                        $sgo1_sauc [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                        [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                        $sgo1_sauc
                          = \ (sc_saua :: Int) (sc1_saub :: [Int]) ->
                              case Util.$wisLShaped ww1_s8oM sc_saua of {
                                False -> go1_X2b9 sc1_saub;
                                True ->
                                  case p_a4gh of ww2_s8rk
                                  { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
                                  let {
                                    ds1_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                    [LclId, Unf=OtherCon []]
                                    ds1_s5Ir = (ww_s8oL, sc_saua) } in
                                  case Util.$wisValidTarget ww4_s8rm ww5_s8rn ds1_s5Ir ps_a4gi of {
                                    False -> go1_X2b9 sc1_saub;
                                    True ->
                                      case targetNotKing ww2_s8rk ds1_s5Ir ps_a4gi of {
                                        False -> go1_X2b9 sc1_saub;
                                        True ->
                                          case Util.$wwillKingBeInCheck
                                                 ww3_s8rl
                                                 ww4_s8rm
                                                 ww5_s8rn
                                                 ww6_s8ro
                                                 ww1_s8oM
                                                 sc_saua
                                                 ps_a4gi
                                          of {
                                            False ->
                                              GHC.Types.: @ Move ds1_s5Ir (go1_X2b9 sc1_saub);
                                            True -> go1_X2b9 sc1_saub
                                          }
                                      }
                                  }
                                  }
                              };
                        go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go1_X2b9
                          = \ (ds1_X2bb :: [Int]) ->
                              case ds1_X2bb of {
                                [] -> z4_X2b6;
                                : y1_X2gy ys1_X2gB ->
                                  case Util.$wisLShaped ww1_s8oM y1_X2gy of {
                                    False -> go1_X2b9 ys1_X2gB;
                                    True ->
                                      case p_a4gh of ww2_s8rk
                                      { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
                                      let {
                                        ds2_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                        [LclId, Unf=OtherCon []]
                                        ds2_s5Ir = (ww_s8oL, y1_X2gy) } in
                                      case Util.$wisValidTarget ww4_s8rm ww5_s8rn ds2_s5Ir ps_a4gi
                                      of {
                                        False -> go1_X2b9 ys1_X2gB;
                                        True ->
                                          case targetNotKing ww2_s8rk ds2_s5Ir ps_a4gi of {
                                            False -> go1_X2b9 ys1_X2gB;
                                            True ->
                                              case Util.$wwillKingBeInCheck
                                                     ww3_s8rl
                                                     ww4_s8rm
                                                     ww5_s8rn
                                                     ww6_s8ro
                                                     ww1_s8oM
                                                     y1_X2gy
                                                     ps_a4gi
                                              of {
                                                False ->
                                                  GHC.Types.: @ Move ds2_s5Ir (go1_X2b9 ys1_X2gB);
                                                True -> go1_X2b9 ys1_X2gB
                                              }
                                          }
                                      }
                                      }
                                  }
                              }; } in
                      $sgo1_sauc Util.findKing2 z2_rcj5;
                    True ->
                      case p_a4gh of ww2_s8rk
                      { (ww3_s8rl, ww4_s8rm, ww5_s8rn, ww6_s8ro) ->
                      let {
                        ds1_s5Ir [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                        [LclId, Unf=OtherCon []]
                        ds1_s5Ir = (ww_s8oL, z_rcj3) } in
                      case Util.$wisValidTarget ww4_s8rm ww5_s8rn ds1_s5Ir ps_a4gi of {
                        False ->
                          letrec {
                            $sgo1_saup [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                            [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                            $sgo1_saup
                              = \ (sc_saun :: Int) (sc1_sauo :: [Int]) ->
                                  case Util.$wisLShaped ww1_s8oM sc_saun of {
                                    False -> go1_X2b9 sc1_sauo;
                                    True ->
                                      let {
                                        ds2_X5Oe [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                        [LclId, Unf=OtherCon []]
                                        ds2_X5Oe = (ww_s8oL, sc_saun) } in
                                      case Util.$wisValidTarget ww4_s8rm ww5_s8rn ds2_X5Oe ps_a4gi
                                      of {
                                        False -> go1_X2b9 sc1_sauo;
                                        True ->
                                          case targetNotKing ww2_s8rk ds2_X5Oe ps_a4gi of {
                                            False -> go1_X2b9 sc1_sauo;
                                            True ->
                                              case Util.$wwillKingBeInCheck
                                                     ww3_s8rl
                                                     ww4_s8rm
                                                     ww5_s8rn
                                                     ww6_s8ro
                                                     ww1_s8oM
                                                     sc_saun
                                                     ps_a4gi
                                              of {
                                                False ->
                                                  GHC.Types.: @ Move ds2_X5Oe (go1_X2b9 sc1_sauo);
                                                True -> go1_X2b9 sc1_sauo
                                              }
                                          }
                                      }
                                  };
                            go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                            go1_X2b9
                              = \ (ds2_X2bb :: [Int]) ->
                                  case ds2_X2bb of {
                                    [] -> z4_X2b6;
                                    : y1_X2gM ys1_X2gP ->
                                      case Util.$wisLShaped ww1_s8oM y1_X2gM of {
                                        False -> go1_X2b9 ys1_X2gP;
                                        True ->
                                          let {
                                            ds3_X5Oe [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                            [LclId, Unf=OtherCon []]
                                            ds3_X5Oe = (ww_s8oL, y1_X2gM) } in
                                          case Util.$wisValidTarget
                                                 ww4_s8rm ww5_s8rn ds3_X5Oe ps_a4gi
                                          of {
                                            False -> go1_X2b9 ys1_X2gP;
                                            True ->
                                              case targetNotKing ww2_s8rk ds3_X5Oe ps_a4gi of {
                                                False -> go1_X2b9 ys1_X2gP;
                                                True ->
                                                  case Util.$wwillKingBeInCheck
                                                         ww3_s8rl
                                                         ww4_s8rm
                                                         ww5_s8rn
                                                         ww6_s8ro
                                                         ww1_s8oM
                                                         y1_X2gM
                                                         ps_a4gi
                                                  of {
                                                    False ->
                                                      GHC.Types.:
                                                        @ Move ds3_X5Oe (go1_X2b9 ys1_X2gP);
                                                    True -> go1_X2b9 ys1_X2gP
                                                  }
                                              }
                                          }
                                      }
                                  }; } in
                          $sgo1_saup Util.findKing2 z2_rcj5;
                        True ->
                          case targetNotKing ww2_s8rk ds1_s5Ir ps_a4gi of {
                            False ->
                              letrec {
                                $sgo1_sauC [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                                [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                                $sgo1_sauC
                                  = \ (sc_sauA :: Int) (sc1_sauB :: [Int]) ->
                                      case Util.$wisLShaped ww1_s8oM sc_sauA of {
                                        False -> go1_X2b9 sc1_sauB;
                                        True ->
                                          let {
                                            ds2_X5Oh [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                            [LclId, Unf=OtherCon []]
                                            ds2_X5Oh = (ww_s8oL, sc_sauA) } in
                                          case Util.$wisValidTarget
                                                 ww4_s8rm ww5_s8rn ds2_X5Oh ps_a4gi
                                          of {
                                            False -> go1_X2b9 sc1_sauB;
                                            True ->
                                              case targetNotKing ww2_s8rk ds2_X5Oh ps_a4gi of {
                                                False -> go1_X2b9 sc1_sauB;
                                                True ->
                                                  case Util.$wwillKingBeInCheck
                                                         ww3_s8rl
                                                         ww4_s8rm
                                                         ww5_s8rn
                                                         ww6_s8ro
                                                         ww1_s8oM
                                                         sc_sauA
                                                         ps_a4gi
                                                  of {
                                                    False ->
                                                      GHC.Types.:
                                                        @ Move ds2_X5Oh (go1_X2b9 sc1_sauB);
                                                    True -> go1_X2b9 sc1_sauB
                                                  }
                                              }
                                          }
                                      };
                                go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                go1_X2b9
                                  = \ (ds2_X2bb :: [Int]) ->
                                      case ds2_X2bb of {
                                        [] -> z4_X2b6;
                                        : y1_X2gP ys1_X2gS ->
                                          case Util.$wisLShaped ww1_s8oM y1_X2gP of {
                                            False -> go1_X2b9 ys1_X2gS;
                                            True ->
                                              let {
                                                ds3_X5Oh [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                [LclId, Unf=OtherCon []]
                                                ds3_X5Oh = (ww_s8oL, y1_X2gP) } in
                                              case Util.$wisValidTarget
                                                     ww4_s8rm ww5_s8rn ds3_X5Oh ps_a4gi
                                              of {
                                                False -> go1_X2b9 ys1_X2gS;
                                                True ->
                                                  case targetNotKing ww2_s8rk ds3_X5Oh ps_a4gi of {
                                                    False -> go1_X2b9 ys1_X2gS;
                                                    True ->
                                                      case Util.$wwillKingBeInCheck
                                                             ww3_s8rl
                                                             ww4_s8rm
                                                             ww5_s8rn
                                                             ww6_s8ro
                                                             ww1_s8oM
                                                             y1_X2gP
                                                             ps_a4gi
                                                      of {
                                                        False ->
                                                          GHC.Types.:
                                                            @ Move ds3_X5Oh (go1_X2b9 ys1_X2gS);
                                                        True -> go1_X2b9 ys1_X2gS
                                                      }
                                                  }
                                              }
                                          }
                                      }; } in
                              $sgo1_sauC Util.findKing2 z2_rcj5;
                            True ->
                              case Util.$wwillKingBeInCheck
                                     ww3_s8rl ww4_s8rm ww5_s8rn ww6_s8ro ww1_s8oM z_rcj3 ps_a4gi
                              of {
                                False ->
                                  GHC.Types.:
                                    @ Move
                                    ds1_s5Ir
                                    (letrec {
                                       $sgo1_sauP [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                                       [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                                       $sgo1_sauP
                                         = \ (sc_sauN :: Int) (sc1_sauO :: [Int]) ->
                                             case Util.$wisLShaped ww1_s8oM sc_sauN of {
                                               False -> go1_X2b9 sc1_sauO;
                                               True ->
                                                 let {
                                                   ds2_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                   [LclId, Unf=OtherCon []]
                                                   ds2_X5Ok = (ww_s8oL, sc_sauN) } in
                                                 case Util.$wisValidTarget
                                                        ww4_s8rm ww5_s8rn ds2_X5Ok ps_a4gi
                                                 of {
                                                   False -> go1_X2b9 sc1_sauO;
                                                   True ->
                                                     case targetNotKing ww2_s8rk ds2_X5Ok ps_a4gi
                                                     of {
                                                       False -> go1_X2b9 sc1_sauO;
                                                       True ->
                                                         case Util.$wwillKingBeInCheck
                                                                ww3_s8rl
                                                                ww4_s8rm
                                                                ww5_s8rn
                                                                ww6_s8ro
                                                                ww1_s8oM
                                                                sc_sauN
                                                                ps_a4gi
                                                         of {
                                                           False ->
                                                             GHC.Types.:
                                                               @ Move ds2_X5Ok (go1_X2b9 sc1_sauO);
                                                           True -> go1_X2b9 sc1_sauO
                                                         }
                                                     }
                                                 }
                                             };
                                       go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                                       [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                       go1_X2b9
                                         = \ (ds2_X2bb :: [Int]) ->
                                             case ds2_X2bb of {
                                               [] -> z4_X2b6;
                                               : y1_X2gS ys1_X2gV ->
                                                 case Util.$wisLShaped ww1_s8oM y1_X2gS of {
                                                   False -> go1_X2b9 ys1_X2gV;
                                                   True ->
                                                     let {
                                                       ds3_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                       [LclId, Unf=OtherCon []]
                                                       ds3_X5Ok = (ww_s8oL, y1_X2gS) } in
                                                     case Util.$wisValidTarget
                                                            ww4_s8rm ww5_s8rn ds3_X5Ok ps_a4gi
                                                     of {
                                                       False -> go1_X2b9 ys1_X2gV;
                                                       True ->
                                                         case targetNotKing
                                                                ww2_s8rk ds3_X5Ok ps_a4gi
                                                         of {
                                                           False -> go1_X2b9 ys1_X2gV;
                                                           True ->
                                                             case Util.$wwillKingBeInCheck
                                                                    ww3_s8rl
                                                                    ww4_s8rm
                                                                    ww5_s8rn
                                                                    ww6_s8ro
                                                                    ww1_s8oM
                                                                    y1_X2gS
                                                                    ps_a4gi
                                                             of {
                                                               False ->
                                                                 GHC.Types.:
                                                                   @ Move
                                                                   ds3_X5Ok
                                                                   (go1_X2b9 ys1_X2gV);
                                                               True -> go1_X2b9 ys1_X2gV
                                                             }
                                                         }
                                                     }
                                                 }
                                             }; } in
                                     $sgo1_sauP Util.findKing2 z2_rcj5);
                                True ->
                                  letrec {
                                    $sgo1_sav2 [Occ=LoopBreaker] :: Int -> [Int] -> [Move]
                                    [LclId, Arity=2, Str=<L,U(U)><L,1*U>, Unf=OtherCon []]
                                    $sgo1_sav2
                                      = \ (sc_sav0 :: Int) (sc1_sav1 :: [Int]) ->
                                          case Util.$wisLShaped ww1_s8oM sc_sav0 of {
                                            False -> go1_X2b9 sc1_sav1;
                                            True ->
                                              let {
                                                ds2_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                [LclId, Unf=OtherCon []]
                                                ds2_X5Ok = (ww_s8oL, sc_sav0) } in
                                              case Util.$wisValidTarget
                                                     ww4_s8rm ww5_s8rn ds2_X5Ok ps_a4gi
                                              of {
                                                False -> go1_X2b9 sc1_sav1;
                                                True ->
                                                  case targetNotKing ww2_s8rk ds2_X5Ok ps_a4gi of {
                                                    False -> go1_X2b9 sc1_sav1;
                                                    True ->
                                                      case Util.$wwillKingBeInCheck
                                                             ww3_s8rl
                                                             ww4_s8rm
                                                             ww5_s8rn
                                                             ww6_s8ro
                                                             ww1_s8oM
                                                             sc_sav0
                                                             ps_a4gi
                                                      of {
                                                        False ->
                                                          GHC.Types.:
                                                            @ Move ds2_X5Ok (go1_X2b9 sc1_sav1);
                                                        True -> go1_X2b9 sc1_sav1
                                                      }
                                                  }
                                              }
                                          };
                                    go1_X2b9 [Occ=LoopBreaker] :: [Int] -> [Move]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                    go1_X2b9
                                      = \ (ds2_X2bb :: [Int]) ->
                                          case ds2_X2bb of {
                                            [] -> z4_X2b6;
                                            : y1_X2gS ys1_X2gV ->
                                              case Util.$wisLShaped ww1_s8oM y1_X2gS of {
                                                False -> go1_X2b9 ys1_X2gV;
                                                True ->
                                                  let {
                                                    ds3_X5Ok [Dmd=<L,U(U(U),U(U))>] :: (Int, Int)
                                                    [LclId, Unf=OtherCon []]
                                                    ds3_X5Ok = (ww_s8oL, y1_X2gS) } in
                                                  case Util.$wisValidTarget
                                                         ww4_s8rm ww5_s8rn ds3_X5Ok ps_a4gi
                                                  of {
                                                    False -> go1_X2b9 ys1_X2gV;
                                                    True ->
                                                      case targetNotKing ww2_s8rk ds3_X5Ok ps_a4gi
                                                      of {
                                                        False -> go1_X2b9 ys1_X2gV;
                                                        True ->
                                                          case Util.$wwillKingBeInCheck
                                                                 ww3_s8rl
                                                                 ww4_s8rm
                                                                 ww5_s8rn
                                                                 ww6_s8ro
                                                                 ww1_s8oM
                                                                 y1_X2gS
                                                                 ps_a4gi
                                                          of {
                                                            False ->
                                                              GHC.Types.:
                                                                @ Move ds3_X5Ok (go1_X2b9 ys1_X2gV);
                                                            True -> go1_X2b9 ys1_X2gV
                                                          }
                                                      }
                                                  }
                                              }
                                          }; } in
                                  $sgo1_sav2 Util.findKing2 z2_rcj5
                              }
                          }
                      }
                      }
                  }
                  }
              }; } in
      $sgo_savf -2# z3_rcj6

Rec {
-- RHS size: {terms: 116, types: 44, coercions: 0, joins: 0/0}
Util.legalRookMoves_$s$wlegalRookMovesLine1 [Occ=LoopBreaker]
  :: Int
     -> GHC.Prim.Int#
     -> [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> [Move]
[GblId,
 Arity=7,
 Str=<L,U(U)><L,U><S,U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=OtherCon []]
Util.legalRookMoves_$s$wlegalRookMovesLine1
  = \ (sc_satr :: Int)
      (sc1_satq :: GHC.Prim.Int#)
      (sc2_satp :: [(PieceType, Colour, (Int, Int), Int)])
      (sc3_satl :: PieceType)
      (sc4_satm :: Colour)
      (sc5_satn :: (Int, Int))
      (sc6_sato :: Int) ->
      case targetNotKing
             (sc3_satl, sc4_satm, sc5_satn, sc6_sato)
             (GHC.Types.I# sc1_satq, sc_satr)
             sc2_satp
      of {
        False -> GHC.Types.[] @ Move;
        True ->
          case Util.$wisRookValidMove
                 (sc3_satl, sc4_satm, sc5_satn, sc6_sato) sc1_satq sc_satr sc2_satp
          of {
            False -> GHC.Types.[] @ Move;
            True ->
              case Util.$wwillKingBeInCheck
                     sc3_satl sc4_satm sc5_satn sc6_sato sc1_satq sc_satr sc2_satp
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (GHC.Types.I# sc1_satq, sc_satr)
                    (case sc1_satq of wild3_X8A {
                       __DEFAULT ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine2
                           sc_satr
                           (case GHC.Prim.<# wild3_X8A 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># wild3_X8A 0# of {
                                  __DEFAULT -> GHC.Types.I# wild3_X8A;
                                  1# -> GHC.Types.I# (GHC.Prim.+# wild3_X8A 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# wild3_X8A 1#)
                            })
                           sc2_satp
                           sc3_satl
                           sc4_satm
                           sc5_satn
                           sc6_sato;
                       0# ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine1
                           (case sc_satr of wild4_a5k8 { GHC.Types.I# x_a5k9 ->
                            case GHC.Prim.<# x_a5k9 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># x_a5k9 0# of {
                                  __DEFAULT -> wild4_a5k8;
                                  1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                            }
                            })
                           0#
                           sc2_satp
                           sc3_satl
                           sc4_satm
                           sc5_satn
                           sc6_sato
                     });
                True -> GHC.Types.[] @ Move
              }
          }
      }

-- RHS size: {terms: 116, types: 46, coercions: 0, joins: 0/0}
Util.legalRookMoves_$s$wlegalRookMovesLine2 [Occ=LoopBreaker]
  :: Int
     -> Int
     -> [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> [Move]
[GblId,
 Arity=7,
 Str=<L,U(U)><L,U(U)><S,U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=OtherCon []]
Util.legalRookMoves_$s$wlegalRookMovesLine2
  = \ (sc_satk :: Int)
      (sc1_satj :: Int)
      (sc2_sati :: [(PieceType, Colour, (Int, Int), Int)])
      (sc3_sate :: PieceType)
      (sc4_satf :: Colour)
      (sc5_satg :: (Int, Int))
      (sc6_sath :: Int) ->
      case targetNotKing
             (sc3_sate, sc4_satf, sc5_satg, sc6_sath)
             (sc1_satj, sc_satk)
             sc2_sati
      of {
        False -> GHC.Types.[] @ Move;
        True ->
          case sc1_satj of ww_s8rP { GHC.Types.I# ww1_s8rQ ->
          case Util.$wisRookValidMove
                 (sc3_sate, sc4_satf, sc5_satg, sc6_sath) ww1_s8rQ sc_satk sc2_sati
          of {
            False -> GHC.Types.[] @ Move;
            True ->
              case Util.$wwillKingBeInCheck
                     sc3_sate sc4_satf sc5_satg sc6_sath ww1_s8rQ sc_satk sc2_sati
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (ww_s8rP, sc_satk)
                    (case ww1_s8rQ of wild3_X8A {
                       __DEFAULT ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine2
                           sc_satk
                           (case GHC.Prim.<# wild3_X8A 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># wild3_X8A 0# of {
                                  __DEFAULT -> ww_s8rP;
                                  1# -> GHC.Types.I# (GHC.Prim.+# wild3_X8A 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# wild3_X8A 1#)
                            })
                           sc2_sati
                           sc3_sate
                           sc4_satf
                           sc5_satg
                           sc6_sath;
                       0# ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine1
                           (case sc_satk of wild4_a5k8 { GHC.Types.I# x_a5k9 ->
                            case GHC.Prim.<# x_a5k9 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># x_a5k9 0# of {
                                  __DEFAULT -> wild4_a5k8;
                                  1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                            }
                            })
                           0#
                           sc2_sati
                           sc3_sate
                           sc4_satf
                           sc5_satg
                           sc6_sath
                     });
                True -> GHC.Types.[] @ Move
              }
          }
          }
      }
end Rec }

-- RHS size: {terms: 108, types: 42, coercions: 0, joins: 0/0}
Util.legalRookMoves_$s$wlegalRookMovesLine
  :: Int
     -> GHC.Prim.Int#
     -> [(PieceType, Colour, (Int, Int), Int)]
     -> (PieceType, Colour, (Int, Int), Int)
     -> [Move]
[GblId,
 Arity=4,
 Str=<L,U(U)><L,U><S,U><L,U(U,U,U(U(U),U(U)),U(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 184 0 20] 618 60}]
Util.legalRookMoves_$s$wlegalRookMovesLine
  = \ (sc_sasW :: Int)
      (sc1_sasV :: GHC.Prim.Int#)
      (sc2_sasU :: [(PieceType, Colour, (Int, Int), Int)])
      (sc3_sasT :: (PieceType, Colour, (Int, Int), Int)) ->
      case targetNotKing
             sc3_sasT (GHC.Types.I# sc1_sasV, sc_sasW) sc2_sasU
      of {
        False -> GHC.Types.[] @ Move;
        True ->
          case Util.$wisRookValidMove sc3_sasT sc1_sasV sc_sasW sc2_sasU of {
            False -> GHC.Types.[] @ Move;
            True ->
              case sc3_sasT of { (ww1_s8uc, ww2_s8ud, ww3_s8ue, ww4_s8uf) ->
              case Util.$wwillKingBeInCheck
                     ww1_s8uc ww2_s8ud ww3_s8ue ww4_s8uf sc1_sasV sc_sasW sc2_sasU
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (GHC.Types.I# sc1_sasV, sc_sasW)
                    (case sc1_sasV of wild3_X8A {
                       __DEFAULT ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine2
                           sc_sasW
                           (case GHC.Prim.<# wild3_X8A 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># wild3_X8A 0# of {
                                  __DEFAULT -> GHC.Types.I# wild3_X8A;
                                  1# -> GHC.Types.I# (GHC.Prim.+# wild3_X8A 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# wild3_X8A 1#)
                            })
                           sc2_sasU
                           ww1_s8uc
                           ww2_s8ud
                           ww3_s8ue
                           ww4_s8uf;
                       0# ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine1
                           (case sc_sasW of wild4_a5k8 { GHC.Types.I# x_a5k9 ->
                            case GHC.Prim.<# x_a5k9 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># x_a5k9 0# of {
                                  __DEFAULT -> wild4_a5k8;
                                  1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                            }
                            })
                           0#
                           sc2_sasU
                           ww1_s8uc
                           ww2_s8ud
                           ww3_s8ue
                           ww4_s8uf
                     });
                True -> GHC.Types.[] @ Move
              }
              }
          }
      }

-- RHS size: {terms: 108, types: 31, coercions: 0, joins: 0/0}
Util.$wlegalRookMovesLine [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Int -> Int -> [Move]
[GblId,
 Arity=4,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U><L,U(U)><L,U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 20 20] 598 60}]
Util.$wlegalRookMovesLine
  = \ (w_s8uv :: Piece)
      (w1_s8uw :: AllPieces)
      (ww_s8uA :: Int)
      (ww1_s8uB :: Int) ->
      case targetNotKing w_s8uv (ww_s8uA, ww1_s8uB) w1_s8uw of {
        False -> GHC.Types.[] @ Move;
        True ->
          case ww_s8uA of ww2_s8rP { GHC.Types.I# ww3_s8rQ ->
          case Util.$wisRookValidMove w_s8uv ww3_s8rQ ww1_s8uB w1_s8uw of {
            False -> GHC.Types.[] @ Move;
            True ->
              case w_s8uv of { (ww5_s8uc, ww6_s8ud, ww7_s8ue, ww8_s8uf) ->
              case Util.$wwillKingBeInCheck
                     ww5_s8uc ww6_s8ud ww7_s8ue ww8_s8uf ww3_s8rQ ww1_s8uB w1_s8uw
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (ww2_s8rP, ww1_s8uB)
                    (case ww3_s8rQ of wild3_X8A {
                       __DEFAULT ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine2
                           ww1_s8uB
                           (case GHC.Prim.<# wild3_X8A 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># wild3_X8A 0# of {
                                  __DEFAULT -> ww2_s8rP;
                                  1# -> GHC.Types.I# (GHC.Prim.+# wild3_X8A 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# wild3_X8A 1#)
                            })
                           w1_s8uw
                           ww5_s8uc
                           ww6_s8ud
                           ww7_s8ue
                           ww8_s8uf;
                       0# ->
                         Util.legalRookMoves_$s$wlegalRookMovesLine1
                           (case ww1_s8uB of wild4_a5k8 { GHC.Types.I# x_a5k9 ->
                            case GHC.Prim.<# x_a5k9 0# of {
                              __DEFAULT ->
                                case GHC.Prim.># x_a5k9 0# of {
                                  __DEFAULT -> wild4_a5k8;
                                  1# -> GHC.Types.I# (GHC.Prim.+# x_a5k9 1#)
                                };
                              1# -> GHC.Types.I# (GHC.Prim.-# x_a5k9 1#)
                            }
                            })
                           0#
                           w1_s8uw
                           ww5_s8uc
                           ww6_s8ud
                           ww7_s8ue
                           ww8_s8uf
                     });
                True -> GHC.Types.[] @ Move
              }
              }
          }
          }
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
legalRookMovesLine [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Move -> [Move]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U><S,1*U(U(U),U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8uv [Occ=Once] :: Piece)
                 (w1_s8uw [Occ=Once] :: AllPieces)
                 (w2_s8ux [Occ=Once!] :: Move) ->
                 case w2_s8ux of { (ww1_s8uA [Occ=Once], ww2_s8uB [Occ=Once]) ->
                 Util.$wlegalRookMovesLine w_s8uv w1_s8uw ww1_s8uA ww2_s8uB
                 }}]
legalRookMovesLine
  = \ (w_s8uv :: Piece) (w1_s8uw :: AllPieces) (w2_s8ux :: Move) ->
      case w2_s8ux of { (ww1_s8uA, ww2_s8uB) ->
      Util.$wlegalRookMovesLine w_s8uv w1_s8uw ww1_s8uA ww2_s8uB
      }

-- RHS size: {terms: 25, types: 11, coercions: 0, joins: 0/0}
legalRookMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 290 0}]
legalRookMoves
  = \ (p_a4gt :: Piece) (ps_a4gu :: AllPieces) ->
      ++
        @ (Int, Int)
        (Util.legalRookMoves_$s$wlegalRookMovesLine
           Util.legalRookMoves1 0# ps_a4gu p_a4gt)
        (++
           @ (Int, Int)
           (Util.legalRookMoves_$s$wlegalRookMovesLine
              Util.allPiecesMoved1 1# ps_a4gu p_a4gt)
           (++
              @ (Int, Int)
              (Util.legalRookMoves_$s$wlegalRookMovesLine
                 Util.findKing2 0# ps_a4gu p_a4gt)
              (Util.legalRookMoves_$s$wlegalRookMovesLine
                 Util.allPiecesMoved1 -1# ps_a4gu p_a4gt)))

Rec {
-- RHS size: {terms: 120, types: 49, coercions: 0, joins: 1/3}
Util.legalBishopMoves_$s$wlegalBishopMovesLine [Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> [(PieceType, Colour, (Int, Int), Int)]
     -> PieceType
     -> Colour
     -> (Int, Int)
     -> Int
     -> [Move]
[GblId,
 Arity=7,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U(U(U),U(U))><L,U(U)>,
 Unf=OtherCon []]
Util.legalBishopMoves_$s$wlegalBishopMovesLine
  = \ (sc_sasf :: GHC.Prim.Int#)
      (sc1_sase :: GHC.Prim.Int#)
      (sc2_sasd :: [(PieceType, Colour, (Int, Int), Int)])
      (sc3_sas9 :: PieceType)
      (sc4_sasa :: Colour)
      (sc5_sasb :: (Int, Int))
      (sc6_sasc :: Int) ->
      case Util.$wisBishopValidMove
             (sc3_sas9, sc4_sasa, sc5_sasb, sc6_sasc) sc1_sase sc_sasf sc2_sasd
      of {
        False -> GHC.Types.[] @ Move;
        True ->
          let {
            n_a4gF [Dmd=<L,U(U)>] :: Int
            [LclId, Unf=OtherCon []]
            n_a4gF = GHC.Types.I# sc_sasf } in
          let {
            m_a4gE [Dmd=<L,U(U)>] :: Int
            [LclId, Unf=OtherCon []]
            m_a4gE = GHC.Types.I# sc1_sase } in
          case targetNotKing
                 (sc3_sas9, sc4_sasa, sc5_sasb, sc6_sasc) (m_a4gE, n_a4gF) sc2_sasd
          of {
            False -> GHC.Types.[] @ Move;
            True ->
              case Util.$wwillKingBeInCheck
                     sc3_sas9 sc4_sasa sc5_sasb sc6_sasc sc1_sase n_a4gF sc2_sasd
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (m_a4gE, n_a4gF)
                    (join {
                       $j_s90E [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [(Int, Int)]
                       [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                       $j_s90E (ww_X8D4 [OS=OneShot] :: GHC.Prim.Int#)
                         = case GHC.Prim.<# sc_sasf 0# of {
                             __DEFAULT ->
                               case GHC.Prim.># sc_sasf 0# of {
                                 __DEFAULT ->
                                   Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                     sc_sasf ww_X8D4 sc2_sasd sc3_sas9 sc4_sasa sc5_sasb sc6_sasc;
                                 1# ->
                                   Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                     (GHC.Prim.+# sc_sasf 1#)
                                     ww_X8D4
                                     sc2_sasd
                                     sc3_sas9
                                     sc4_sasa
                                     sc5_sasb
                                     sc6_sasc
                               };
                             1# ->
                               Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                 (GHC.Prim.-# sc_sasf 1#)
                                 ww_X8D4
                                 sc2_sasd
                                 sc3_sas9
                                 sc4_sasa
                                 sc5_sasb
                                 sc6_sasc
                           } } in
                     case GHC.Prim.<# sc1_sase 0# of {
                       __DEFAULT ->
                         case GHC.Prim.># sc1_sase 0# of {
                           __DEFAULT -> jump $j_s90E sc1_sase;
                           1# -> jump $j_s90E (GHC.Prim.+# sc1_sase 1#)
                         };
                       1# -> jump $j_s90E (GHC.Prim.-# sc1_sase 1#)
                     });
                True -> GHC.Types.[] @ Move
              }
          }
      }
end Rec }

-- RHS size: {terms: 112, types: 34, coercions: 0, joins: 1/3}
Util.$wlegalBishopMovesLine [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> GHC.Prim.Int# -> GHC.Prim.Int# -> [Move]
[GblId,
 Arity=4,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0 0] 650 60}]
Util.$wlegalBishopMovesLine
  = \ (w_s8uG :: Piece)
      (w1_s8uH :: AllPieces)
      (ww_s8uO :: GHC.Prim.Int#)
      (ww1_s8uT :: GHC.Prim.Int#) ->
      case Util.$wisBishopValidMove w_s8uG ww_s8uO ww1_s8uT w1_s8uH of {
        False -> GHC.Types.[] @ Move;
        True ->
          let {
            n_a4gF [Dmd=<L,U(U)>] :: Int
            [LclId, Unf=OtherCon []]
            n_a4gF = GHC.Types.I# ww1_s8uT } in
          let {
            m_a4gE [Dmd=<L,U(U)>] :: Int
            [LclId, Unf=OtherCon []]
            m_a4gE = GHC.Types.I# ww_s8uO } in
          case targetNotKing w_s8uG (m_a4gE, n_a4gF) w1_s8uH of {
            False -> GHC.Types.[] @ Move;
            True ->
              case w_s8uG of { (ww3_s8uc, ww4_s8ud, ww5_s8ue, ww6_s8uf) ->
              case Util.$wwillKingBeInCheck
                     ww3_s8uc ww4_s8ud ww5_s8ue ww6_s8uf ww_s8uO n_a4gF w1_s8uH
              of {
                False ->
                  GHC.Types.:
                    @ (Int, Int)
                    (m_a4gE, n_a4gF)
                    (join {
                       $j_s90E [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [(Int, Int)]
                       [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                       $j_s90E (ww7_X8D4 [OS=OneShot] :: GHC.Prim.Int#)
                         = case GHC.Prim.<# ww1_s8uT 0# of {
                             __DEFAULT ->
                               case GHC.Prim.># ww1_s8uT 0# of {
                                 __DEFAULT ->
                                   Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                     ww1_s8uT ww7_X8D4 w1_s8uH ww3_s8uc ww4_s8ud ww5_s8ue ww6_s8uf;
                                 1# ->
                                   Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                     (GHC.Prim.+# ww1_s8uT 1#)
                                     ww7_X8D4
                                     w1_s8uH
                                     ww3_s8uc
                                     ww4_s8ud
                                     ww5_s8ue
                                     ww6_s8uf
                               };
                             1# ->
                               Util.legalBishopMoves_$s$wlegalBishopMovesLine
                                 (GHC.Prim.-# ww1_s8uT 1#)
                                 ww7_X8D4
                                 w1_s8uH
                                 ww3_s8uc
                                 ww4_s8ud
                                 ww5_s8ue
                                 ww6_s8uf
                           } } in
                     case GHC.Prim.<# ww_s8uO 0# of {
                       __DEFAULT ->
                         case GHC.Prim.># ww_s8uO 0# of {
                           __DEFAULT -> jump $j_s90E ww_s8uO;
                           1# -> jump $j_s90E (GHC.Prim.+# ww_s8uO 1#)
                         };
                       1# -> jump $j_s90E (GHC.Prim.-# ww_s8uO 1#)
                     });
                True -> GHC.Types.[] @ Move
              }
              }
          }
      }

-- RHS size: {terms: 17, types: 10, coercions: 0, joins: 0/0}
legalBishopMovesLine [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Move -> [Move]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U><S(SS),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8uG [Occ=Once] :: Piece)
                 (w1_s8uH [Occ=Once] :: AllPieces)
                 (w2_s8uI [Occ=Once!] :: Move) ->
                 case w2_s8uI of { (ww1_s8uL [Occ=Once!], ww2_s8uQ [Occ=Once!]) ->
                 case ww1_s8uL of { GHC.Types.I# ww4_s8uO [Occ=Once] ->
                 case ww2_s8uQ of { GHC.Types.I# ww6_s8uT [Occ=Once] ->
                 Util.$wlegalBishopMovesLine w_s8uG w1_s8uH ww4_s8uO ww6_s8uT
                 }
                 }
                 }}]
legalBishopMovesLine
  = \ (w_s8uG :: Piece) (w1_s8uH :: AllPieces) (w2_s8uI :: Move) ->
      case w2_s8uI of { (ww1_s8uL, ww2_s8uQ) ->
      case ww1_s8uL of { GHC.Types.I# ww4_s8uO ->
      case ww2_s8uQ of { GHC.Types.I# ww6_s8uT ->
      Util.$wlegalBishopMovesLine w_s8uG w1_s8uH ww4_s8uO ww6_s8uT
      }
      }
      }

-- RHS size: {terms: 25, types: 11, coercions: 0, joins: 0/0}
legalBishopMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 290 0}]
legalBishopMoves
  = \ (p_a4gA :: Piece) (ps_a4gB :: AllPieces) ->
      ++
        @ (Int, Int)
        (Util.$wlegalBishopMovesLine p_a4gA ps_a4gB -1# -1#)
        (++
           @ (Int, Int)
           (Util.$wlegalBishopMovesLine p_a4gA ps_a4gB 1# 1#)
           (++
              @ (Int, Int)
              (Util.$wlegalBishopMovesLine p_a4gA ps_a4gB 1# -1#)
              (Util.$wlegalBishopMovesLine p_a4gA ps_a4gB -1# 1#)))

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
legalQueenMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4gG :: Piece) (ps_a4gH :: AllPieces) ->
                 GHC.Base.augment
                   @ (Int, Int)
                   (\ (@ b_a1X1)
                      (c_a1X2 [Occ=Once, OS=OneShot] :: (Int, Int) -> b_a1X1 -> b_a1X1)
                      (n_a1X3 [Occ=Once, OS=OneShot] :: b_a1X1) ->
                      GHC.Base.foldr
                        @ (Int, Int)
                        @ b_a1X1
                        c_a1X2
                        n_a1X3
                        (legalBishopMoves p_a4gG ps_a4gH))
                   (legalRookMoves p_a4gG ps_a4gH)}]
legalQueenMoves
  = \ (p_a4gG :: Piece) (ps_a4gH :: AllPieces) ->
      ++
        @ (Int, Int)
        (legalBishopMoves p_a4gG ps_a4gH)
        (legalRookMoves p_a4gG ps_a4gH)

-- RHS size: {terms: 249, types: 67, coercions: 0, joins: 1/9}
legalKingMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U>,
 Unf=OtherCon []]
legalKingMoves
  = \ (p_a4gM :: Piece) (ps_a4gN :: AllPieces) ->
      letrec {
        go_a3xy [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_a3xy
          = \ (x_a3xz :: GHC.Prim.Int#) ->
              let {
                ds_d584 [Dmd=<L,U(U)>] :: Int
                [LclId, Unf=OtherCon []]
                ds_d584 = GHC.Types.I# x_a3xz } in
              let {
                n_X3Eb :: [Move]
                [LclId]
                n_X3Eb
                  = case x_a3xz of wild_X6I {
                      __DEFAULT -> go_a3xy (GHC.Prim.+# wild_X6I 1#);
                      1# -> GHC.Types.[] @ Move
                    } } in
              joinrec {
                go1_X3Ej [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
                [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                go1_X3Ej (x1_X3El :: GHC.Prim.Int#)
                  = let {
                      ds1_d586 [Dmd=<L,U(U)>] :: Int
                      [LclId, Unf=OtherCon []]
                      ds1_d586 = GHC.Types.I# x1_X3El } in
                    case targetNotKing p_a4gM (ds_d584, ds1_d586) ps_a4gN of {
                      False ->
                        case x1_X3El of wild1_X6Q {
                          __DEFAULT -> jump go1_X3Ej (GHC.Prim.+# wild1_X6Q 1#);
                          2# -> n_X3Eb
                        };
                      True ->
                        case Util.$wvalidKingMove p_a4gM x_a3xz x1_X3El ps_a4gN of {
                          False ->
                            case x1_X3El of wild2_X6Q {
                              __DEFAULT -> jump go1_X3Ej (GHC.Prim.+# wild2_X6Q 1#);
                              2# -> n_X3Eb
                            };
                          True ->
                            case p_a4gM of ww_s8ub
                            { (ww1_s8uc, ww2_s8ud, ww3_s8ue, ww4_s8uf) ->
                            case Util.$wwillKingBeInCheck
                                   ww1_s8uc ww2_s8ud ww3_s8ue ww4_s8uf x_a3xz ds1_d586 ps_a4gN
                            of {
                              False ->
                                GHC.Types.:
                                  @ Move
                                  (ds_d584, ds1_d586)
                                  (case x1_X3El of wild3_X6Q {
                                     __DEFAULT ->
                                       letrec {
                                         go2_X3JM [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
                                         [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                         go2_X3JM
                                           = \ (x2_X3JP :: GHC.Prim.Int#) ->
                                               let {
                                                 ds2_X5dB [Dmd=<L,U(U)>] :: Int
                                                 [LclId, Unf=OtherCon []]
                                                 ds2_X5dB = GHC.Types.I# x2_X3JP } in
                                               case targetNotKing
                                                      ww_s8ub (ds_d584, ds2_X5dB) ps_a4gN
                                               of {
                                                 False ->
                                                   case x2_X3JP of wild5_Xcq {
                                                     __DEFAULT ->
                                                       go2_X3JM (GHC.Prim.+# wild5_Xcq 1#);
                                                     2# -> n_X3Eb
                                                   };
                                                 True ->
                                                   case Util.clearCastlePath_$s$wvalidKingMove
                                                          ps_a4gN
                                                          x2_X3JP
                                                          x_a3xz
                                                          ww1_s8uc
                                                          ww2_s8ud
                                                          ww3_s8ue
                                                          ww4_s8uf
                                                   of {
                                                     False ->
                                                       case x2_X3JP of wild6_Xct {
                                                         __DEFAULT ->
                                                           go2_X3JM (GHC.Prim.+# wild6_Xct 1#);
                                                         2# -> n_X3Eb
                                                       };
                                                     True ->
                                                       case Util.$wwillKingBeInCheck
                                                              ww1_s8uc
                                                              ww2_s8ud
                                                              ww3_s8ue
                                                              ww4_s8uf
                                                              x_a3xz
                                                              ds2_X5dB
                                                              ps_a4gN
                                                       of {
                                                         False ->
                                                           GHC.Types.:
                                                             @ Move
                                                             (ds_d584, ds2_X5dB)
                                                             (case x2_X3JP of wild7_XcE {
                                                                __DEFAULT ->
                                                                  go2_X3JM
                                                                    (GHC.Prim.+# wild7_XcE 1#);
                                                                2# -> n_X3Eb
                                                              });
                                                         True ->
                                                           case x2_X3JP of wild7_XcE {
                                                             __DEFAULT ->
                                                               go2_X3JM (GHC.Prim.+# wild7_XcE 1#);
                                                             2# -> n_X3Eb
                                                           }
                                                       }
                                                   }
                                               }; } in
                                       go2_X3JM (GHC.Prim.+# wild3_X6Q 1#);
                                     2# -> n_X3Eb
                                   });
                              True ->
                                case x1_X3El of wild3_X6Q {
                                  __DEFAULT ->
                                    letrec {
                                      go2_X3JM [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
                                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                      go2_X3JM
                                        = \ (x2_X3JP :: GHC.Prim.Int#) ->
                                            let {
                                              ds2_X5dB [Dmd=<L,U(U)>] :: Int
                                              [LclId, Unf=OtherCon []]
                                              ds2_X5dB = GHC.Types.I# x2_X3JP } in
                                            case targetNotKing ww_s8ub (ds_d584, ds2_X5dB) ps_a4gN
                                            of {
                                              False ->
                                                case x2_X3JP of wild5_Xcq {
                                                  __DEFAULT -> go2_X3JM (GHC.Prim.+# wild5_Xcq 1#);
                                                  2# -> n_X3Eb
                                                };
                                              True ->
                                                case Util.clearCastlePath_$s$wvalidKingMove
                                                       ps_a4gN
                                                       x2_X3JP
                                                       x_a3xz
                                                       ww1_s8uc
                                                       ww2_s8ud
                                                       ww3_s8ue
                                                       ww4_s8uf
                                                of {
                                                  False ->
                                                    case x2_X3JP of wild6_Xct {
                                                      __DEFAULT ->
                                                        go2_X3JM (GHC.Prim.+# wild6_Xct 1#);
                                                      2# -> n_X3Eb
                                                    };
                                                  True ->
                                                    case Util.$wwillKingBeInCheck
                                                           ww1_s8uc
                                                           ww2_s8ud
                                                           ww3_s8ue
                                                           ww4_s8uf
                                                           x_a3xz
                                                           ds2_X5dB
                                                           ps_a4gN
                                                    of {
                                                      False ->
                                                        GHC.Types.:
                                                          @ Move
                                                          (ds_d584, ds2_X5dB)
                                                          (case x2_X3JP of wild7_XcE {
                                                             __DEFAULT ->
                                                               go2_X3JM (GHC.Prim.+# wild7_XcE 1#);
                                                             2# -> n_X3Eb
                                                           });
                                                      True ->
                                                        case x2_X3JP of wild7_XcE {
                                                          __DEFAULT ->
                                                            go2_X3JM (GHC.Prim.+# wild7_XcE 1#);
                                                          2# -> n_X3Eb
                                                        }
                                                    }
                                                }
                                            }; } in
                                    go2_X3JM (GHC.Prim.+# wild3_X6Q 1#);
                                  2# -> n_X3Eb
                                }
                            }
                            }
                        }
                    }; } in
              jump go1_X3Ej -2#; } in
      go_a3xy -1#

-- RHS size: {terms: 33, types: 31, coercions: 0, joins: 0/0}
protectedBy :: Piece -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 0] 150 0}]
protectedBy
  = \ (p_a4ff :: Piece) (ps_a4fg :: AllPieces) ->
      threatenedBy
        (case p_a4ff of { (a_a40l, colour_a40m, pos_a40n, mc_a40o) ->
         (a_a40l,
          case colour_a40m of {
            Black -> TypeDefs.White;
            White -> TypeDefs.Black
          },
          pos_a40n, mc_a40o)
         })
        (GHC.Types.:
           @ Piece
           (case p_a4ff of { (a_a40l, colour_a40m, pos_a40n, mc_a40o) ->
            (a_a40l,
             case colour_a40m of {
               Black -> TypeDefs.White;
               White -> TypeDefs.Black
             },
             pos_a40n, mc_a40o)
            })
           (removePiece p_a4ff ps_a4fg))

-- RHS size: {terms: 43, types: 13, coercions: 0, joins: 0/0}
Util.$wmovePiece [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour -> Pos -> Movecount -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=6,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 20 0] 290 0}]
Util.$wmovePiece
  = \ (ww_s8va :: PieceType)
      (ww1_s8vb :: Colour)
      (ww2_s8vc :: Pos)
      (ww3_s8vd :: Movecount)
      (w_s8v6 :: Move)
      (w1_s8v7 :: AllPieces) ->
      case Util.$wisValidMove
             ww_s8va ww1_s8vb ww2_s8vc ww3_s8vd w_s8v6 w1_s8v7
      of {
        False -> w1_s8v7;
        True ->
          case w_s8v6 of { (ww5_s8uj, ww6_s8uo) ->
          case ww5_s8uj of { GHC.Types.I# ww8_s8um ->
          case Util.$wwillKingBeInCheck
                 ww_s8va ww1_s8vb ww2_s8vc ww3_s8vd ww8_s8um ww6_s8uo w1_s8v7
          of {
            False ->
              Util.$wexecuteMove
                ww_s8va ww1_s8vb ww2_s8vc ww3_s8vd ww8_s8um ww6_s8uo w1_s8v7;
            True -> w1_s8v7
          }
          }
          }
      }

-- RHS size: {terms: 13, types: 8, coercions: 0, joins: 0/0}
movePiece [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> AllPieces
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8v5 [Occ=Once!] :: Piece)
                 (w1_s8v6 [Occ=Once] :: Move)
                 (w2_s8v7 [Occ=Once] :: AllPieces) ->
                 case w_s8v5 of
                 { (ww1_s8va [Occ=Once], ww2_s8vb [Occ=Once], ww3_s8vc [Occ=Once],
                    ww4_s8vd [Occ=Once]) ->
                 Util.$wmovePiece
                   ww1_s8va ww2_s8vb ww3_s8vc ww4_s8vd w1_s8v6 w2_s8v7
                 }}]
movePiece
  = \ (w_s8v5 :: Piece) (w1_s8v6 :: Move) (w2_s8v7 :: AllPieces) ->
      case w_s8v5 of { (ww1_s8va, ww2_s8vb, ww3_s8vc, ww4_s8vd) ->
      Util.$wmovePiece
        ww1_s8va ww2_s8vb ww3_s8vc ww4_s8vd w1_s8v6 w2_s8v7
      }

-- RHS size: {terms: 92, types: 38, coercions: 0, joins: 1/7}
legalPawnMoves :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 596 0}]
legalPawnMoves
  = \ (p_a4gI :: Piece) (ps_a4gJ :: AllPieces) ->
      letrec {
        go_a3xy [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_a3xy
          = \ (x_a3xz :: GHC.Prim.Int#) ->
              let {
                ds_d57X [Dmd=<L,U(U)>] :: Int
                [LclId, Unf=OtherCon []]
                ds_d57X = GHC.Types.I# x_a3xz } in
              let {
                n_X3Ee :: [Move]
                [LclId]
                n_X3Ee
                  = case x_a3xz of wild_X6L {
                      __DEFAULT -> go_a3xy (GHC.Prim.+# wild_X6L 1#);
                      2# -> GHC.Types.[] @ Move
                    } } in
              letrec {
                go1_X3Em [Occ=LoopBreaker] :: GHC.Prim.Int# -> [Move]
                [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                go1_X3Em
                  = \ (x1_X3Eo :: GHC.Prim.Int#) ->
                      let {
                        ds1_d57Z [Dmd=<L,U(U)>] :: Int
                        [LclId, Unf=OtherCon []]
                        ds1_d57Z = GHC.Types.I# x1_X3Eo } in
                      let {
                        ds2_d57Y :: [Move]
                        [LclId]
                        ds2_d57Y
                          = case x1_X3Eo of wild_X6T {
                              __DEFAULT -> go1_X3Em (GHC.Prim.+# wild_X6T 1#);
                              1# -> n_X3Ee
                            } } in
                      case targetNotKing p_a4gI (ds_d57X, ds1_d57Z) ps_a4gJ of {
                        False -> ds2_d57Y;
                        True ->
                          case p_a4gI of { (ww1_s8s0, ww2_s8s1, ww3_s8s2, ww4_s8s3) ->
                          join {
                            $j_s5WF [Dmd=<L,1*U>] :: [Move]
                            [LclId[JoinId(0)]]
                            $j_s5WF
                              = case Util.$wwillKingBeInCheck
                                       ww1_s8s0 ww2_s8s1 ww3_s8s2 ww4_s8s3 x_a3xz ds1_d57Z ps_a4gJ
                                of {
                                  False -> GHC.Types.: @ Move (ds_d57X, ds1_d57Z) ds2_d57Y;
                                  True -> ds2_d57Y
                                } } in
                          case Util.$wisPawnValidMove
                                 ww2_s8s1 ww3_s8s2 (ds_d57X, ds1_d57Z) ps_a4gJ
                          of {
                            False ->
                              case Util.$wisValidEnPassant
                                     ww2_s8s1 ww3_s8s2 x_a3xz ds1_d57Z ps_a4gJ
                              of {
                                False -> case ww1_s8s0 of { __DEFAULT -> ds2_d57Y };
                                True -> jump $j_s5WF
                              };
                            True -> jump $j_s5WF
                          }
                          }
                      }; } in
              go1_X3Em -1#; } in
      go_a3xy -2#

-- RHS size: {terms: 61, types: 34, coercions: 0, joins: 0/1}
Util.$wlegalMoves [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> Pos -> Movecount -> AllPieces -> [Move]
[GblId,
 Arity=5,
 Str=<S,1*U><L,U><L,U(U(U),U(U))><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [270 0 0 0 0] 370 0}]
Util.$wlegalMoves
  = \ (ww_s8vo :: PieceType)
      (ww1_s8vp :: Colour)
      (ww2_s8vq :: Pos)
      (ww3_s8vr :: Movecount)
      (w_s8vl :: AllPieces) ->
      case ww_s8vo of {
        Pawn ->
          legalPawnMoves
            (TypeDefs.Pawn, ww1_s8vp, ww2_s8vq, ww3_s8vr) w_s8vl;
        Knight ->
          legalKnightMoves
            (TypeDefs.Knight, ww1_s8vp, ww2_s8vq, ww3_s8vr) w_s8vl;
        Bishop ->
          legalBishopMoves
            (TypeDefs.Bishop, ww1_s8vp, ww2_s8vq, ww3_s8vr) w_s8vl;
        Rook ->
          legalRookMoves
            (TypeDefs.Rook, ww1_s8vp, ww2_s8vq, ww3_s8vr) w_s8vl;
        Queen ->
          let {
            p_a4gG [Dmd=<L,U(U,U,U(U(U),U(U)),U(U))>] :: Piece
            [LclId, Unf=OtherCon []]
            p_a4gG = (TypeDefs.Queen, ww1_s8vp, ww2_s8vq, ww3_s8vr) } in
          ++
            @ (Int, Int)
            (legalBishopMoves p_a4gG w_s8vl)
            (legalRookMoves p_a4gG w_s8vl);
        King ->
          legalKingMoves (TypeDefs.King, ww1_s8vp, ww2_s8vq, ww3_s8vr) w_s8vl
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
legalMoves [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> [Move]
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8vk [Occ=Once!] :: Piece)
                 (w1_s8vl [Occ=Once] :: AllPieces) ->
                 case w_s8vk of
                 { (ww1_s8vo [Occ=Once], ww2_s8vp [Occ=Once], ww3_s8vq [Occ=Once],
                    ww4_s8vr [Occ=Once]) ->
                 Util.$wlegalMoves ww1_s8vo ww2_s8vp ww3_s8vq ww4_s8vr w1_s8vl
                 }}]
legalMoves
  = \ (w_s8vk :: Piece) (w1_s8vl :: AllPieces) ->
      case w_s8vk of { (ww1_s8vo, ww2_s8vp, ww3_s8vq, ww4_s8vr) ->
      Util.$wlegalMoves ww1_s8vo ww2_s8vp ww3_s8vq ww4_s8vr w1_s8vl
      }

-- RHS size: {terms: 109, types: 55, coercions: 0, joins: 0/5}
Util.$wprotecting [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> Pos -> Movecount -> AllPieces -> [Piece]
[GblId,
 Arity=5,
 Str=<S,1*U><L,U><L,U(U(U),U(U))><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 30 20 0 0] 750 0}]
Util.$wprotecting
  = \ (ww_s8vy :: PieceType)
      (ww1_s8vz :: Colour)
      (ww2_s8vA :: Pos)
      (ww3_s8vB :: Movecount)
      (w_s8vv :: AllPieces) ->
      case ww_s8vy of wild_X1u {
        __DEFAULT ->
          let {
            w1_s8LN :: [Piece]
            [LclId]
            w1_s8LN
              = removePiece (wild_X1u, ww1_s8vz, ww2_s8vA, ww3_s8vB) w_s8vv } in
          let {
            ww4_X8Dq :: Colour
            [LclId]
            ww4_X8Dq
              = case ww1_s8vz of {
                  Black -> TypeDefs.White;
                  White -> TypeDefs.Black
                } } in
          let {
            w2_s8LM :: (PieceType, Colour, Pos, Movecount)
            [LclId, Unf=OtherCon []]
            w2_s8LM = (wild_X1u, ww4_X8Dq, ww2_s8vA, ww3_s8vB) } in
          let {
            w3_s8vl :: AllPieces
            [LclId, Unf=OtherCon []]
            w3_s8vl = GHC.Types.: @ Piece w2_s8LM w1_s8LN } in
          case wild_X1u of {
            Pawn ->
              getPiecesFromMoves
                ww2_s8vA
                (legalPawnMoves
                   (TypeDefs.Pawn, ww4_X8Dq, ww2_s8vA, ww3_s8vB) w3_s8vl)
                w_s8vv;
            Knight ->
              getPiecesFromMoves
                ww2_s8vA
                (legalKnightMoves
                   (TypeDefs.Knight, ww4_X8Dq, ww2_s8vA, ww3_s8vB) w3_s8vl)
                w_s8vv;
            Bishop ->
              getPiecesFromMoves
                ww2_s8vA
                (legalBishopMoves
                   (TypeDefs.Bishop, ww4_X8Dq, ww2_s8vA, ww3_s8vB) w3_s8vl)
                w_s8vv;
            Rook ->
              getPiecesFromMoves
                ww2_s8vA
                (legalRookMoves
                   (TypeDefs.Rook, ww4_X8Dq, ww2_s8vA, ww3_s8vB) w3_s8vl)
                w_s8vv;
            Queen ->
              let {
                p_a4gG [Dmd=<L,U(U,U,U(U(U),U(U)),U(U))>] :: Piece
                [LclId, Unf=OtherCon []]
                p_a4gG = (TypeDefs.Queen, ww4_X8Dq, ww2_s8vA, ww3_s8vB) } in
              getPiecesFromMoves
                ww2_s8vA
                (++
                   @ (Int, Int)
                   (legalBishopMoves p_a4gG w3_s8vl)
                   (legalRookMoves p_a4gG w3_s8vl))
                w_s8vv
          };
        King ->
          case ww2_s8vA of { (ww5_s8no, ww6_s8nt) ->
          case ww5_s8no of { GHC.Types.I# ww8_s8nr ->
          surroundingPieces
            ww1_s8vz (Util.$wgetSurroundingPos ww8_s8nr ww6_s8nt) w_s8vv
          }
          }
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
protecting [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s8vu [Occ=Once!] :: Piece)
                 (w1_s8vv [Occ=Once] :: AllPieces) ->
                 case w_s8vu of
                 { (ww1_s8vy [Occ=Once], ww2_s8vz [Occ=Once], ww3_s8vA [Occ=Once],
                    ww4_s8vB [Occ=Once]) ->
                 Util.$wprotecting ww1_s8vy ww2_s8vz ww3_s8vA ww4_s8vB w1_s8vv
                 }}]
protecting
  = \ (w_s8vu :: Piece) (w1_s8vv :: AllPieces) ->
      case w_s8vu of { (ww1_s8vy, ww2_s8vz, ww3_s8vA, ww4_s8vB) ->
      Util.$wprotecting ww1_s8vy ww2_s8vz ww3_s8vA ww4_s8vB w1_s8vv
      }

-- RHS size: {terms: 14, types: 7, coercions: 0, joins: 0/0}
threatening :: Piece -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),U(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4fn :: Piece) (ps_a4fo :: AllPieces) ->
                 getPiecesFromMoves
                   (case p_a4fn of
                    { (_ [Occ=Dead], _ [Occ=Dead], pos_a3ZY [Occ=Once],
                       _ [Occ=Dead]) ->
                    pos_a3ZY
                    })
                   (legalMoves p_a4fn ps_a4fo)
                   ps_a4fo}]
threatening
  = \ (p_a4fn :: Piece) (ps_a4fo :: AllPieces) ->
      case p_a4fn of { (ww1_s8vo, ww2_s8vp, ww3_s8vq, ww4_s8vr) ->
      getPiecesFromMoves
        ww3_s8vq
        (Util.$wlegalMoves ww1_s8vo ww2_s8vp ww3_s8vq ww4_s8vr ps_a4fo)
        ps_a4fo
      }

-- RHS size: {terms: 144, types: 129, coercions: 0, joins: 0/4}
colourLegalMoves :: Colour -> AllPieces -> [[Move]]
[GblId, Arity=2, Str=<L,1*U><S,1*U>, Unf=OtherCon []]
colourLegalMoves
  = \ (c_a4hw :: Colour) (ps_a4hx :: AllPieces) ->
      case ps_a4hx of wild_a24v {
        [] -> GHC.Types.[] @ [Move];
        : y_a24x ys_a24y ->
          case y_a24x of { (ds_d529, colour_a3ZX, ds1_d52a, ds2_d52b) ->
          case colour_a3ZX of {
            Black ->
              case c_a4hw of {
                Black ->
                  GHC.Types.:
                    @ [Move]
                    (Util.$wlegalMoves
                       ds_d529 TypeDefs.Black ds1_d52a ds2_d52b wild_a24v)
                    (letrec {
                       go_a24t [Occ=LoopBreaker] :: [Piece] -> [[Move]]
                       [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                       go_a24t
                         = \ (ds3_a24u :: [Piece]) ->
                             case ds3_a24u of {
                               [] -> GHC.Types.[] @ [Move];
                               : y1_X2a6 ys1_X2a8 ->
                                 case y1_X2a6 of { (ds4_X57O, colour1_X45D, ds5_X57R, ds6_X57T) ->
                                 case colour1_X45D of {
                                   Black ->
                                     GHC.Types.:
                                       @ [Move]
                                       (Util.$wlegalMoves
                                          ds4_X57O TypeDefs.Black ds5_X57R ds6_X57T wild_a24v)
                                       (go_a24t ys1_X2a8);
                                   White -> go_a24t ys1_X2a8
                                 }
                                 }
                             }; } in
                     go_a24t ys_a24y);
                White ->
                  letrec {
                    go_a24t [Occ=LoopBreaker] :: [Piece] -> [[Move]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go_a24t
                      = \ (ds3_a24u :: [Piece]) ->
                          case ds3_a24u of {
                            [] -> GHC.Types.[] @ [Move];
                            : y1_X2a6 ys1_X2a8 ->
                              case y1_X2a6 of { (ds4_X57O, colour1_X45D, ds5_X57R, ds6_X57T) ->
                              case colour1_X45D of {
                                Black -> go_a24t ys1_X2a8;
                                White ->
                                  GHC.Types.:
                                    @ [Move]
                                    (Util.$wlegalMoves
                                       ds4_X57O TypeDefs.White ds5_X57R ds6_X57T wild_a24v)
                                    (go_a24t ys1_X2a8)
                              }
                              }
                          }; } in
                  go_a24t ys_a24y
              };
            White ->
              case c_a4hw of {
                Black ->
                  letrec {
                    go_a24t [Occ=LoopBreaker] :: [Piece] -> [[Move]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go_a24t
                      = \ (ds3_a24u :: [Piece]) ->
                          case ds3_a24u of {
                            [] -> GHC.Types.[] @ [Move];
                            : y1_X2a6 ys1_X2a8 ->
                              case y1_X2a6 of { (ds4_X57O, colour1_X45D, ds5_X57R, ds6_X57T) ->
                              case colour1_X45D of {
                                Black ->
                                  GHC.Types.:
                                    @ [Move]
                                    (Util.$wlegalMoves
                                       ds4_X57O TypeDefs.Black ds5_X57R ds6_X57T wild_a24v)
                                    (go_a24t ys1_X2a8);
                                White -> go_a24t ys1_X2a8
                              }
                              }
                          }; } in
                  go_a24t ys_a24y;
                White ->
                  GHC.Types.:
                    @ [Move]
                    (Util.$wlegalMoves
                       ds_d529 TypeDefs.White ds1_d52a ds2_d52b wild_a24v)
                    (letrec {
                       go_a24t [Occ=LoopBreaker] :: [Piece] -> [[Move]]
                       [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                       go_a24t
                         = \ (ds3_a24u :: [Piece]) ->
                             case ds3_a24u of {
                               [] -> GHC.Types.[] @ [Move];
                               : y1_X2a6 ys1_X2a8 ->
                                 case y1_X2a6 of { (ds4_X57O, colour1_X45D, ds5_X57R, ds6_X57T) ->
                                 case colour1_X45D of {
                                   Black -> go_a24t ys1_X2a8;
                                   White ->
                                     GHC.Types.:
                                       @ [Move]
                                       (Util.$wlegalMoves
                                          ds4_X57O TypeDefs.White ds5_X57R ds6_X57T wild_a24v)
                                       (go_a24t ys1_X2a8)
                                 }
                                 }
                             }; } in
                     go_a24t ys_a24y)
              }
          }
          }
      }

-- RHS size: {terms: 115, types: 98, coercions: 0, joins: 5/5}
isEitherCheckmate :: AllPieces -> Bool
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 662 0}]
isEitherCheckmate
  = \ (ps_a4hz :: AllPieces) ->
      join {
        $j_s5Xa :: Bool
        [LclId[JoinId(0)]]
        $j_s5Xa
          = join {
              $j1_s7Xb :: Bool
              [LclId[JoinId(0)]]
              $j1_s7Xb
                = case findPiece (findKing TypeDefs.Black ps_a4hz) ps_a4hz of {
                    [] -> case GHC.List.badHead of wild1_00 { };
                    : x_a4SP ds1_a4SQ ->
                      case x_a4SP of { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
                      Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT ps_a4hz
                      }
                  } } in
            joinrec {
              go_X2bd [Occ=LoopBreaker] :: [Piece] -> Bool
              [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
              go_X2bd (ds_a24u :: [Piece])
                = case ds_a24u of {
                    [] -> jump $j1_s7Xb;
                    : y_a24x ys_a24y ->
                      case y_a24x of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                      case colour_a3ZX of {
                        Black ->
                          case Util.$wlegalMoves
                                 ds1_d529 TypeDefs.Black ds2_d52a ds3_d52b ps_a4hz
                          of {
                            [] -> jump go_X2bd ys_a24y;
                            : ds4_a5jz ds5_a5jA -> GHC.Types.False
                          };
                        White -> jump go_X2bd ys_a24y
                      }
                      }
                  }; } in
            jump go_X2bd ps_a4hz } in
      join {
        $j1_s7Xj :: Bool
        [LclId[JoinId(0)]]
        $j1_s7Xj
          = case findPiece (findKing TypeDefs.White ps_a4hz) ps_a4hz of {
              [] -> case GHC.List.badHead of wild1_00 { };
              : x_a4SP ds1_a4SQ ->
                case x_a4SP of wild1_X2A
                { (pt_a4fw, colour_a4fx, pos_a4fy, mc_a4fz) ->
                case Util.clearCastlePath_$sthreatenedBy
                       (GHC.Types.:
                          @ (PieceType, Colour, Pos, Movecount)
                          (TypeDefs.Pawn, colour_a4fx, pos_a4fy, mc_a4fz)
                          (removePiece wild1_X2A ps_a4hz))
                       TypeDefs.Pawn
                       colour_a4fx
                       pos_a4fy
                       mc_a4fz
                of {
                  [] -> jump $j_s5Xa;
                  : ds2_a5jz ds3_a5jA -> GHC.Types.True
                }
                }
            } } in
      joinrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t (ds_a24u :: [Piece])
          = case ds_a24u of {
              [] -> jump $j1_s7Xj;
              : y_a24x ys_a24y ->
                case y_a24x of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                case colour_a3ZX of {
                  Black -> jump go_a24t ys_a24y;
                  White ->
                    case Util.$wlegalMoves
                           ds1_d529 TypeDefs.White ds2_d52a ds3_d52b ps_a4hz
                    of {
                      [] -> jump go_a24t ys_a24y;
                      : ds4_a5jz ds5_a5jA -> jump $j_s5Xa
                    }
                }
                }
            }; } in
      jump go_a24t ps_a4hz


------ Local rules for imported ids --------
"SC:surroundingPieces0"
    forall (sc_saFk :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saFj :: [(Int, Int)]).
      surroundingPieces TypeDefs.Black sc1_saFj sc_saFk
      = Util.surroundingPieces_$ssurroundingPieces1 sc_saFk sc1_saFj
"SC:surroundingPieces1"
    forall (sc_saFo :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saFn :: [(Int, Int)]).
      surroundingPieces TypeDefs.White sc1_saFn sc_saFo
      = Util.surroundingPieces_$ssurroundingPieces sc_saFo sc1_saFn
"SC:$wisStraightMovePathEmpty0" [2]
    forall (sc_saCW :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saCV :: GHC.Prim.Int#)
           (sc2_saCU :: GHC.Prim.Int#)
           (sc3_saCS :: GHC.Prim.Int#)
           (sc4_saCT :: Int).
      Util.$wisStraightMovePathEmpty (GHC.Types.I# sc3_saCS, sc4_saCT)
                                     sc2_saCU
                                     sc1_saCV
                                     sc_saCW
      = Util.clearCastlePath_$s$wisStraightMovePathEmpty
          sc_saCW sc1_saCV sc2_saCU sc3_saCS sc4_saCT
"SC:$wvalidKingMove0" [2]
    forall (sc_sayI :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_sayH :: GHC.Prim.Int#)
           (sc2_sayG :: GHC.Prim.Int#)
           (sc3_sayC :: PieceType)
           (sc4_sayD :: Colour)
           (sc5_sayE :: (Int, Int))
           (sc6_sayF :: Int).
      Util.$wvalidKingMove (sc3_sayC, sc4_sayD, sc5_sayE, sc6_sayF)
                           sc2_sayG
                           sc1_sayH
                           sc_sayI
      = Util.clearCastlePath_$s$wvalidKingMove
          sc_sayI sc1_sayH sc2_sayG sc3_sayC sc4_sayD sc5_sayE sc6_sayF
"SC:clearCastlePath2"
    forall (sc_saBD :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saBz :: PieceType)
           (sc2_saBA :: Colour)
           (sc3_saBB :: (Int, Int))
           (sc4_saBC :: Int).
      clearCastlePath (sc1_saBz, sc2_saBA, sc3_saBB, sc4_saBC)
                      sc_saBD
                      GHC.Types.False
      = Util.clearCastlePath_$sclearCastlePath2
          sc_saBD sc1_saBz sc2_saBA sc3_saBB sc4_saBC
"SC:clearCastlePath0"
    forall (sc_saA0 :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_sazZ :: (PieceType, Colour, (Int, Int), Int)).
      clearCastlePath sc1_sazZ sc_saA0 GHC.Types.False
      = Util.clearCastlePath_$sclearCastlePath1 sc_saA0 sc1_sazZ
"SC:clearCastlePath1"
    forall (sc_saA2 :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saA1 :: (PieceType, Colour, (Int, Int), Int)).
      clearCastlePath sc1_saA1 sc_saA2 GHC.Types.True
      = Util.clearCastlePath_$sclearCastlePath sc_saA2 sc1_saA1
"SC:threatenedBy0"
    forall (sc_sazu :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_sazq :: PieceType)
           (sc2_sazr :: Colour)
           (sc3_sazs :: (Int, Int))
           (sc4_sazt :: Int).
      threatenedBy (sc1_sazq, sc2_sazr, sc3_sazs, sc4_sazt) sc_sazu
      = Util.clearCastlePath_$sthreatenedBy
          sc_sazu sc1_sazq sc2_sazr sc3_sazs sc4_sazt
"SC:threatenedBy1"
    forall (sc_sazE :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_sazA :: PieceType)
           (sc2_sazB :: Colour)
           (sc3_sazC :: Int)
           (sc4_sazD :: Int).
      threatenedBy (sc1_sazA, sc2_sazB, (sc3_sazC, sc4_sazD),
                    Util.allPiecesMoved1)
                   sc_sazE
      = Util.clearCastlePath_$sthreatenedBy1
          sc_sazE sc1_sazA sc2_sazB sc3_sazC sc4_sazD
"SC:$wisValidMove0" [2]
    forall (sc_sazc :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saza :: Int)
           (sc2_sazb :: Int)
           (sc3_saz9 :: Int)
           (sc4_saz8 :: (Int, Int))
           (sc5_saz7 :: Colour)
           (sc6_saz6 :: PieceType).
      Util.$wisValidMove sc6_saz6
                         sc5_saz7
                         sc4_saz8
                         sc3_saz9
                         (sc1_saza, sc2_sazb)
                         sc_sazc
      = Util.clearCastlePath_$s$wisValidMove
          sc_sazc sc1_saza sc2_sazb sc3_saz9 sc4_saz8 sc5_saz7 sc6_saz6
"SC:$wvalidCastle0" [2]
    forall (sc_saAq :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saAp :: GHC.Prim.Int#)
           (sc2_saAo :: GHC.Prim.Int#)
           (sc3_saAn :: (PieceType, Colour, (Int, Int), Int)).
      Util.$wvalidCastle sc3_saAn
                         sc2_saAo
                         (GHC.Types.I# sc1_saAp)
                         sc_saAq
      = Util.validCastle_$s$wvalidCastle1
          sc_saAq sc1_saAp sc2_saAo sc3_saAn
"SC:$wvalidCastle1" [2]
    forall (sc_saAB :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saAA :: Int)
           (sc2_saAz :: GHC.Prim.Int#)
           (sc3_saAv :: PieceType)
           (sc4_saAw :: Colour)
           (sc5_saAx :: (Int, Int))
           (sc6_saAy :: Int).
      Util.$wvalidCastle (sc3_saAv, sc4_saAw, sc5_saAx, sc6_saAy)
                         sc2_saAz
                         sc1_saAA
                         sc_saAB
      = Util.validCastle_$s$wvalidCastle
          sc_saAB sc1_saAA sc2_saAz sc3_saAv sc4_saAw sc5_saAx sc6_saAy
"SC:$wvalidCastle2" [2]
    forall (sc_saAI :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saAH :: GHC.Prim.Int#)
           (sc2_saAG :: GHC.Prim.Int#)
           (sc3_saAC :: PieceType)
           (sc4_saAD :: Colour)
           (sc5_saAE :: (Int, Int))
           (sc6_saAF :: Int).
      Util.$wvalidCastle (sc3_saAC, sc4_saAD, sc5_saAE, sc6_saAF)
                         sc2_saAG
                         (GHC.Types.I# sc1_saAH)
                         sc_saAI
      = Util.clearCastlePath_$s$wvalidCastle
          sc_saAI sc1_saAH sc2_saAG sc3_saAC sc4_saAD sc5_saAE sc6_saAF
"SC:$wexecuteCastle1" [2]
    forall (sc_saxy :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saxx :: GHC.Prim.Int#)
           (sc2_saxw :: GHC.Prim.Int#)
           (sc3_saxs :: PieceType)
           (sc4_saxt :: Colour)
           (sc5_saxu :: (Int, Int))
           (sc6_saxv :: Int).
      Util.$wexecuteCastle (sc3_saxs, sc4_saxt, sc5_saxu, sc6_saxv)
                           sc2_saxw
                           (GHC.Types.I# sc1_saxx)
                           sc_saxy
      = Util.executeCastle_$s$wexecuteCastle1
          sc_saxy sc1_saxx sc2_saxw sc3_saxs sc4_saxt sc5_saxu sc6_saxv
"SC:$wexecuteCastle0" [2]
    forall (sc_sawX :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_sawW :: Int)
           (sc2_sawV :: GHC.Prim.Int#)
           (sc3_sawR :: PieceType)
           (sc4_sawS :: Colour)
           (sc5_sawT :: (Int, Int))
           (sc6_sawU :: Int).
      Util.$wexecuteCastle (sc3_sawR, sc4_sawS, sc5_sawT, sc6_sawU)
                           sc2_sawV
                           sc1_sawW
                           sc_sawX
      = Util.executeCastle_$s$wexecuteCastle
          sc_sawX sc1_sawW sc2_sawV sc3_sawR sc4_sawS sc5_sawT sc6_sawU
"SC:$wcaptureEnPassant0" [2]
    forall (sc_saxG :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saxF :: GHC.Prim.Int#)
           (sc2_saxE :: GHC.Prim.Int#)
           (sc3_saxD :: Int)
           (sc4_saxC :: (Int, Int))
           (sc5_saxB :: Colour)
           (sc6_saxA :: PieceType).
      Util.$wcaptureEnPassant sc6_saxA
                              sc5_saxB
                              sc4_saxC
                              sc3_saxD
                              sc2_saxE
                              (GHC.Types.I# sc1_saxF)
                              sc_saxG
      = Util.captureEnPassant_$s$wcaptureEnPassant
          sc_saxG sc1_saxF sc2_saxE sc3_saxD sc4_saxC sc5_saxB sc6_saxA
"SC:$wexecuteMove0" [2]
    forall (sc_saxc :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_saxb :: GHC.Prim.Int#)
           (sc2_saxa :: GHC.Prim.Int#)
           (sc3_sax9 :: Int)
           (sc4_sax8 :: (Int, Int))
           (sc5_sax7 :: Colour)
           (sc6_sax6 :: PieceType).
      Util.$wexecuteMove sc6_sax6
                         sc5_sax7
                         sc4_sax8
                         sc3_sax9
                         sc2_saxa
                         (GHC.Types.I# sc1_saxb)
                         sc_saxc
      = Util.captureEnPassant_$s$wexecuteMove
          sc_saxc sc1_saxb sc2_saxa sc3_sax9 sc4_sax8 sc5_sax7 sc6_sax6
"SC:$wlegalRookMovesLine1" [2]
    forall (sc_satk :: Int)
           (sc1_satj :: Int)
           (sc2_sati :: [(PieceType, Colour, (Int, Int), Int)])
           (sc3_sate :: PieceType)
           (sc4_satf :: Colour)
           (sc5_satg :: (Int, Int))
           (sc6_sath :: Int).
      Util.$wlegalRookMovesLine (sc3_sate, sc4_satf, sc5_satg, sc6_sath)
                                sc2_sati
                                sc1_satj
                                sc_satk
      = Util.legalRookMoves_$s$wlegalRookMovesLine2
          sc_satk sc1_satj sc2_sati sc3_sate sc4_satf sc5_satg sc6_sath
"SC:$wlegalRookMovesLine2" [2]
    forall (sc_satr :: Int)
           (sc1_satq :: GHC.Prim.Int#)
           (sc2_satp :: [(PieceType, Colour, (Int, Int), Int)])
           (sc3_satl :: PieceType)
           (sc4_satm :: Colour)
           (sc5_satn :: (Int, Int))
           (sc6_sato :: Int).
      Util.$wlegalRookMovesLine (sc3_satl, sc4_satm, sc5_satn, sc6_sato)
                                sc2_satp
                                (GHC.Types.I# sc1_satq)
                                sc_satr
      = Util.legalRookMoves_$s$wlegalRookMovesLine1
          sc_satr sc1_satq sc2_satp sc3_satl sc4_satm sc5_satn sc6_sato
"SC:$wlegalRookMovesLine0" [2]
    forall (sc_sasW :: Int)
           (sc1_sasV :: GHC.Prim.Int#)
           (sc2_sasU :: [(PieceType, Colour, (Int, Int), Int)])
           (sc3_sasT :: (PieceType, Colour, (Int, Int), Int)).
      Util.$wlegalRookMovesLine sc3_sasT
                                sc2_sasU
                                (GHC.Types.I# sc1_sasV)
                                sc_sasW
      = Util.legalRookMoves_$s$wlegalRookMovesLine
          sc_sasW sc1_sasV sc2_sasU sc3_sasT
"SC:$wlegalBishopMovesLine0" [2]
    forall (sc_sasf :: GHC.Prim.Int#)
           (sc1_sase :: GHC.Prim.Int#)
           (sc2_sasd :: [(PieceType, Colour, (Int, Int), Int)])
           (sc3_sas9 :: PieceType)
           (sc4_sasa :: Colour)
           (sc5_sasb :: (Int, Int))
           (sc6_sasc :: Int).
      Util.$wlegalBishopMovesLine (sc3_sas9, sc4_sasa, sc5_sasb,
                                   sc6_sasc)
                                  sc2_sasd
                                  sc1_sase
                                  sc_sasf
      = Util.legalBishopMoves_$s$wlegalBishopMovesLine
          sc_sasf sc1_sase sc2_sasd sc3_sas9 sc4_sasa sc5_sasb sc6_sasc
"SPEC/Util $fEq(,,,)_$c/= @ PieceType @ Colour @ (Int, Int) @ Int"
    forall ($dEq_s5JN :: Eq PieceType)
           ($dEq1_s5JO :: Eq Colour)
           ($dEq2_s5JP :: Eq (Int, Int))
           ($dEq3_s5JQ :: Eq Int).
      GHC.Classes.$fEq(,,,)_$c/= @ PieceType
                                 @ Colour
                                 @ (Int, Int)
                                 @ Int
                                 $dEq_s5JN
                                 $dEq1_s5JO
                                 $dEq2_s5JP
                                 $dEq3_s5JQ
      = Util.$s$fEq(,,,)_$s$fEq(,,,)_$c/=
"SPEC/Util $fEq(,,,) @ PieceType @ Colour @ (Int, Int) @ Int"
    forall (v_s5JJ :: Eq PieceType)
           (v1_s5JK :: Eq Colour)
           (v2_s5JL :: Eq (Int, Int))
           (v3_s5JM :: Eq Int).
      GHC.Classes.$fEq(,,,) @ PieceType
                            @ Colour
                            @ (Int, Int)
                            @ Int
                            v_s5JJ
                            v1_s5JK
                            v2_s5JL
                            v3_s5JM
      = Util.$s$fEq(,,,)


[ 4 of 14] Compiling UI               ( UI.hs, UI.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 515, types: 545, coercions: 32, joins: 3/5}

-- RHS size: {terms: 46, types: 9, coercions: 0, joins: 0/0}
UI.$wpieceChar [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> GHC.Prim.Char#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [170 180] 180 0}]
UI.$wpieceChar
  = \ (ww_sjJc :: PieceType) (ww1_sjJd :: Colour) ->
      case ww_sjJc of {
        Pawn ->
          case ww1_sjJd of {
            Black -> '\9817'#;
            White -> '\9823'#
          };
        Knight ->
          case ww1_sjJd of {
            Black -> '\9816'#;
            White -> '\9822'#
          };
        Bishop ->
          case ww1_sjJd of {
            Black -> '\9815'#;
            White -> '\9821'#
          };
        Rook ->
          case ww1_sjJd of {
            Black -> '\9814'#;
            White -> '\9820'#
          };
        Queen ->
          case ww1_sjJd of {
            Black -> '\9813'#;
            White -> '\9819'#
          };
        King ->
          case ww1_sjJd of {
            Black -> '\9812'#;
            White -> '\9818'#
          }
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
pieceChar [InlPrag=NOUSERINLINE[2]] :: Piece -> Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SSLL),1*U(1*U,1*U,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sjJ9 [Occ=Once!] :: Piece) ->
                 case w_sjJ9 of
                 { (ww1_sjJc [Occ=Once], ww2_sjJd [Occ=Once], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.C# ww5_sjJj
                 }
                 }}]
pieceChar
  = \ (w_sjJ9 :: Piece) ->
      case w_sjJ9 of { (ww1_sjJc, ww2_sjJd, ww3_sjJe, ww4_sjJf) ->
      case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj { __DEFAULT ->
      GHC.Types.C# ww5_sjJj
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
UI.printCols2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
UI.printCols2 = "  0 1 2 3 4 5 6 7\n"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
UI.printCols1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
UI.printCols1 = GHC.CString.unpackCString# UI.printCols2

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
printCols :: IO ()
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= GHC.IO.Handle.Text.hPutStr'
                 GHC.IO.Handle.FD.stdout UI.printCols1 GHC.Types.False}]
printCols
  = GHC.IO.Handle.Text.hPutStr'
      GHC.IO.Handle.FD.stdout UI.printCols1 GHC.Types.False

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
UI.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
UI.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
UI.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
UI.$trModule3 = GHC.Types.TrNameS UI.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
UI.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
UI.$trModule2 = "UI"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
UI.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
UI.$trModule1 = GHC.Types.TrNameS UI.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
UI.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
UI.$trModule = GHC.Types.Module UI.$trModule3 UI.$trModule1

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
calcPos :: Int -> Pos
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aiFj :: Int) ->
                 (case a_aiFj of { GHC.Types.I# ww1_aj4s [Occ=Once] ->
                  GHC.Types.I# (GHC.Prim.uncheckedIShiftRA# ww1_aj4s 3#)
                  },
                  case a_aiFj of { GHC.Types.I# x_aj4F [Occ=Once] ->
                  GHC.Types.I# (GHC.Prim.andI# x_aj4F 7#)
                  })}]
calcPos
  = \ (a_aiFj :: Int) ->
      (case a_aiFj of { GHC.Types.I# ww1_aj4s ->
       GHC.Types.I# (GHC.Prim.uncheckedIShiftRA# ww1_aj4s 3#)
       },
       case a_aiFj of { GHC.Types.I# x_aj4F ->
       GHC.Types.I# (GHC.Prim.andI# x_aj4F 7#)
       })

Rec {
-- RHS size: {terms: 55, types: 78, coercions: 0, joins: 0/0}
UI.printCapturedPieces_$sprintPieceList [Occ=LoopBreaker]
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (PieceType, Colour, (Int, Int), Int)
     -> [(PieceType, Colour, (Int, Int), Int)]
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Str=<L,U><S(SSLL),1*U(1*U,1*U,A,A)><S,1*U>,
 Unf=OtherCon []]
UI.printCapturedPieces_$sprintPieceList
  = \ (sc_sjOV :: GHC.Prim.State# GHC.Prim.RealWorld)
      (sc1_sjOT :: (PieceType, Colour, (Int, Int), Int))
      (sc2_sjOU :: [(PieceType, Colour, (Int, Int), Int)]) ->
      case sc2_sjOU of {
        [] ->
          case sc1_sjOT of { (ww1_sjJc, ww2_sjJd, ww3_sjJe, ww4_sjJf) ->
          case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj { __DEFAULT ->
          case GHC.IO.Handle.Text.$whPutChar
                 GHC.IO.Handle.FD.stdout ww5_sjJj sc_sjOV
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          case GHC.IO.Handle.Text.$whPutChar
                 GHC.IO.Handle.FD.stdout ' '# ipv_aj55
          of
          { (# ipv2_Xj5I, ipv3_Xj5K #) ->
          GHC.IO.Handle.Text.$whPutChar
            GHC.IO.Handle.FD.stdout '\n'# ipv2_Xj5I
          }
          }
          }
          };
        : ipv_sj4Y ipv1_sj5h ->
          case sc1_sjOT of { (ww1_sjJc, ww2_sjJd, ww3_sjJe, ww4_sjJf) ->
          case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj { __DEFAULT ->
          case GHC.IO.Handle.Text.$whPutChar
                 GHC.IO.Handle.FD.stdout ww5_sjJj sc_sjOV
          of
          { (# ipv2_aj55, ipv3_aj56 #) ->
          case GHC.IO.Handle.Text.$whPutChar
                 GHC.IO.Handle.FD.stdout ' '# ipv2_aj55
          of
          { (# ipv4_Xj5K, ipv5_Xj5M #) ->
          UI.printCapturedPieces_$sprintPieceList
            ipv4_Xj5K ipv_sj4Y ipv1_sj5h
          }
          }
          }
          }
      }
end Rec }

-- RHS size: {terms: 61, types: 77, coercions: 0, joins: 0/0}
UI.printCapturedPieces2
  :: [Piece]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 360 30}]
UI.printCapturedPieces2
  = \ (ds_dj3m :: [Piece])
      (eta_B1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case ds_dj3m of {
        [] -> (# eta_B1, GHC.Tuple.() #);
        : x_aiOJ ds1_dj3J ->
          case ds1_dj3J of {
            [] ->
              case x_aiOJ of { (ww1_sjJc, ww2_sjJd, ww3_sjJe, ww4_sjJf) ->
              case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj { __DEFAULT ->
              case GHC.IO.Handle.Text.$whPutChar
                     GHC.IO.Handle.FD.stdout ww5_sjJj eta_B1
              of
              { (# ipv_aj55, ipv1_aj56 #) ->
              case GHC.IO.Handle.Text.$whPutChar
                     GHC.IO.Handle.FD.stdout ' '# ipv_aj55
              of
              { (# ipv2_Xj5I, ipv3_Xj5K #) ->
              GHC.IO.Handle.Text.$whPutChar
                GHC.IO.Handle.FD.stdout '\n'# ipv2_Xj5I
              }
              }
              }
              };
            : ipv_sj4Y ipv1_sj5h ->
              case x_aiOJ of { (ww1_sjJc, ww2_sjJd, ww3_sjJe, ww4_sjJf) ->
              case UI.$wpieceChar ww1_sjJc ww2_sjJd of ww5_sjJj { __DEFAULT ->
              case GHC.IO.Handle.Text.$whPutChar
                     GHC.IO.Handle.FD.stdout ww5_sjJj eta_B1
              of
              { (# ipv2_aj55, ipv3_aj56 #) ->
              case GHC.IO.Handle.Text.$whPutChar
                     GHC.IO.Handle.FD.stdout ' '# ipv2_aj55
              of
              { (# ipv4_Xj5K, ipv5_Xj5M #) ->
              UI.printCapturedPieces_$sprintPieceList
                ipv4_Xj5K ipv_sj4Y ipv1_sj5h
              }
              }
              }
              }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 6, joins: 0/0}
printPieceList :: [Piece] -> IO ()
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= UI.printCapturedPieces2
               `cast` (<[Piece]>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ([Piece]
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                          ~R# ([Piece] -> IO ()))}]
printPieceList
  = UI.printCapturedPieces2
    `cast` (<[Piece]>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: ([Piece]
                -> GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# ([Piece] -> IO ()))

-- RHS size: {terms: 56, types: 42, coercions: 0, joins: 1/3}
getCapturedPieces :: Colour -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 244 0}]
getCapturedPieces
  = \ (c_aiOM :: Colour) (ps_aiON :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Piece]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Piece;
                : y_a24x ys_a24y ->
                  case y_a24x of wild1_X1x
                  { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                  let {
                    ds4_diSE :: [Piece]
                    [LclId]
                    ds4_diSE = go_a24t ys_a24y } in
                  join {
                    $j_sjAZ [Dmd=<L,1*U>] :: [Piece]
                    [LclId[JoinId(0)]]
                    $j_sjAZ
                      = case ds2_d52a of { (ww4_a5iu, ww5_a5iv) ->
                        case ww4_a5iu of { GHC.Types.I# x_a5hr ->
                        case x_a5hr of {
                          __DEFAULT -> ds4_diSE;
                          -1# ->
                            case ww5_a5iv of { GHC.Types.I# x1_X5j1 ->
                            case x1_X5j1 of {
                              __DEFAULT -> ds4_diSE;
                              -1# -> GHC.Types.: @ Piece wild1_X1x ds4_diSE
                            }
                            }
                        }
                        }
                        } } in
                  case colour_a3ZX of {
                    Black ->
                      case c_aiOM of {
                        Black -> jump $j_sjAZ;
                        White -> ds4_diSE
                      };
                    White ->
                      case c_aiOM of {
                        Black -> ds4_diSE;
                        White -> jump $j_sjAZ
                      }
                  }
                  }
              }; } in
      go_a24t ps_aiON

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
UI.printCapturedPieces4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
UI.printCapturedPieces4 = " ================\n"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
UI.printCapturedPieces3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
UI.printCapturedPieces3
  = GHC.CString.unpackCString# UI.printCapturedPieces4

-- RHS size: {terms: 31, types: 27, coercions: 4, joins: 0/0}
UI.printCapturedPieces1
  :: Colour
     -> AllPieces
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Str=<S,1*U><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [130 0 0] 220 0}]
UI.printCapturedPieces1
  = \ (ds_dj3M :: Colour)
      (ps_aiOH :: AllPieces)
      (eta_B1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case ds_dj3M of {
        Black ->
          case ((GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout UI.printCapturedPieces3 GHC.Types.False)
                `cast` (GHC.Types.N:IO[0] <()>_R
                        :: IO ()
                           ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
                 eta_B1
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          UI.printCapturedPieces2
            (getCapturedPieces TypeDefs.Black ps_aiOH) ipv_aj55
          };
        White ->
          case UI.printCapturedPieces2
                 (getCapturedPieces TypeDefs.White ps_aiOH) eta_B1
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          ((GHC.IO.Handle.Text.hPutStr'
              GHC.IO.Handle.FD.stdout UI.printCapturedPieces3 GHC.Types.False)
           `cast` (GHC.Types.N:IO[0] <()>_R
                   :: IO ()
                      ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
            ipv_aj55
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
printCapturedPieces :: Colour -> AllPieces -> IO ()
[GblId,
 Arity=3,
 Str=<S,1*U><L,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= UI.printCapturedPieces1
               `cast` (<Colour>_R
                       ->_R <AllPieces>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Colour
                           -> AllPieces
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                          ~R# (Colour -> AllPieces -> IO ()))}]
printCapturedPieces
  = UI.printCapturedPieces1
    `cast` (<Colour>_R
            ->_R <AllPieces>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Colour
                -> AllPieces
                -> GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# (Colour -> AllPieces -> IO ()))

Rec {
-- RHS size: {terms: 174, types: 177, coercions: 8, joins: 2/2}
UI.$wprintBoard [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
  :: GHC.Prim.Int#
     -> AllPieces
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=3, Str=<S,1*U><L,U><L,U>, Unf=OtherCon []]
UI.$wprintBoard
  = \ (ww_sjJE :: GHC.Prim.Int#)
      (w_sjJA :: AllPieces)
      (w1_sjJB :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case ww_sjJE of ds_Xj4k {
        __DEFAULT ->
          join {
            $w$j_sjJy [InlPrag=NOUSERINLINE[2], Dmd=<L,1*C1(U(U,U))>]
              :: GHC.Prim.State# GHC.Prim.RealWorld
                 -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
            [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
            $w$j_sjJy (w2_sjJw [OS=OneShot]
                         :: GHC.Prim.State# GHC.Prim.RealWorld)
              = join {
                  $w$j1_sjJv [InlPrag=NOUSERINLINE[2], Dmd=<L,1*C1(U(U,U))>]
                    :: GHC.Prim.State# GHC.Prim.RealWorld
                       -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                  [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                  $w$j1_sjJv (w3_sjJt [OS=OneShot]
                                :: GHC.Prim.State# GHC.Prim.RealWorld)
                    = case GHC.Prim.andI# ds_Xj4k 7# of {
                        __DEFAULT ->
                          case GHC.IO.Handle.Text.$whPutChar
                                 GHC.IO.Handle.FD.stdout ' '# w3_sjJt
                          of
                          { (# ipv_Xj5R, ipv1_Xj5T #) ->
                          UI.$wprintBoard (GHC.Prim.+# ds_Xj4k 1#) w_sjJA ipv_Xj5R
                          };
                        7# ->
                          case GHC.IO.Handle.Text.$whPutChar
                                 GHC.IO.Handle.FD.stdout '\n'# w3_sjJt
                          of
                          { (# ipv_Xj5R, ipv1_Xj5T #) ->
                          UI.$wprintBoard (GHC.Prim.+# ds_Xj4k 1#) w_sjJA ipv_Xj5R
                          }
                      } } in
                case GHC.Classes.$fEq[]_$c==
                       @ (PieceType, Colour, Pos, Movecount)
                       Util.$s$fEq(,,,)
                       (findPiece
                          (GHC.Types.I# (GHC.Prim.uncheckedIShiftRA# ds_Xj4k 3#),
                           GHC.Types.I# (GHC.Prim.andI# ds_Xj4k 7#))
                          w_sjJA)
                       (GHC.Types.[] @ Piece)
                of {
                  False ->
                    case findPiece
                           (GHC.Types.I# (GHC.Prim.uncheckedIShiftRA# ds_Xj4k 3#),
                            GHC.Types.I# (GHC.Prim.andI# ds_Xj4k 7#))
                           w_sjJA
                    of {
                      [] -> case GHC.List.badHead of wild2_00 { };
                      : x_a4SP ds1_a4SQ ->
                        case x_a4SP of { (ww2_sjJc, ww3_sjJd, ww4_sjJe, ww5_sjJf) ->
                        case UI.$wpieceChar ww2_sjJc ww3_sjJd of ww6_sjJj { __DEFAULT ->
                        case GHC.IO.Handle.Text.$whPutChar
                               GHC.IO.Handle.FD.stdout ww6_sjJj w2_sjJw
                        of
                        { (# ipv_Xj5M, ipv1_Xj5O #) ->
                        jump $w$j1_sjJv ipv_Xj5M
                        }
                        }
                        }
                    };
                  True ->
                    case GHC.IO.Handle.Text.$whPutChar
                           GHC.IO.Handle.FD.stdout '-'# w2_sjJw
                    of
                    { (# ipv_Xj5M, ipv1_Xj5O #) ->
                    jump $w$j1_sjJv ipv_Xj5M
                    }
                } } in
          case GHC.Prim.andI# ds_Xj4k 7# of {
            __DEFAULT -> jump $w$j_sjJy w1_sjJB;
            0# ->
              case ((GHC.IO.Handle.Text.hPutStr'
                       GHC.IO.Handle.FD.stdout
                       (case GHC.Show.$wshowSignedInt
                               0# (GHC.Prim.uncheckedIShiftRA# ds_Xj4k 3#) (GHC.Types.[] @ Char)
                        of
                        { (# ww5_aj5K, ww6_aj5L #) ->
                        GHC.Types.: @ Char ww5_aj5K ww6_aj5L
                        })
                       GHC.Types.False)
                    `cast` (GHC.Types.N:IO[0] <()>_R
                            :: IO ()
                               ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
                     w1_sjJB
              of
              { (# ipv_aj55, ipv1_aj56 #) ->
              case GHC.IO.Handle.Text.$whPutChar
                     GHC.IO.Handle.FD.stdout ' '# ipv_aj55
              of
              { (# ipv2_Xj7z, ipv3_Xj7B #) ->
              jump $w$j_sjJy ipv2_Xj7z
              }
              }
          };
        -1# ->
          case UI.printCapturedPieces2
                 (getCapturedPieces TypeDefs.White w_sjJA) w1_sjJB
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          case ((GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout UI.printCapturedPieces3 GHC.Types.False)
                `cast` (GHC.Types.N:IO[0] <()>_R
                        :: IO ()
                           ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
                 ipv_aj55
          of
          { (# ipv2_Xj7r, ipv3_Xj7t #) ->
          UI.$wprintBoard 0# w_sjJA ipv2_Xj7r
          }
          };
        64# ->
          case ((GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout UI.printCols1 GHC.Types.False)
                `cast` (GHC.Types.N:IO[0] <()>_R
                        :: IO ()
                           ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
                 w1_sjJB
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          UI.$wprintBoard 65# w_sjJA ipv_aj55
          };
        65# ->
          case ((GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout UI.printCapturedPieces3 GHC.Types.False)
                `cast` (GHC.Types.N:IO[0] <()>_R
                        :: IO ()
                           ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
                 w1_sjJB
          of
          { (# ipv_aj55, ipv1_aj56 #) ->
          UI.printCapturedPieces2
            (getCapturedPieces TypeDefs.Black w_sjJA) ipv_aj55
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
UI.printBoard1 [InlPrag=NOUSERINLINE[2]]
  :: Int
     -> AllPieces
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sjJz [Occ=Once!] :: Int)
                 (w1_sjJA [Occ=Once] :: AllPieces)
                 (w2_sjJB [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w_sjJz of { GHC.Types.I# ww1_sjJE [Occ=Once] ->
                 UI.$wprintBoard ww1_sjJE w1_sjJA w2_sjJB
                 }}]
UI.printBoard1
  = \ (w_sjJz :: Int)
      (w1_sjJA :: AllPieces)
      (w2_sjJB :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case w_sjJz of { GHC.Types.I# ww1_sjJE ->
      UI.$wprintBoard ww1_sjJE w1_sjJA w2_sjJB
      }

-- RHS size: {terms: 1, types: 0, coercions: 7, joins: 0/0}
printBoard :: Int -> AllPieces -> IO ()
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= UI.printBoard1
               `cast` (<Int>_R
                       ->_R <AllPieces>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Int
                           -> AllPieces
                           -> GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                          ~R# (Int -> AllPieces -> IO ()))}]
printBoard
  = UI.printBoard1
    `cast` (<Int>_R
            ->_R <AllPieces>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Int
                -> AllPieces
                -> GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# (Int -> AllPieces -> IO ()))

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
colourCase :: Colour -> Char -> Char
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_aiJn [Occ=Once!] :: Colour)
                 (s_aiJo [Occ=Once*] :: Char) ->
                 case c_aiJn of {
                   Black -> toLower s_aiJo;
                   White -> toUpper s_aiJo
                 }}]
colourCase
  = \ (c_aiJn :: Colour) (s_aiJo :: Char) ->
      case c_aiJn of {
        Black -> toLower s_aiJo;
        White -> toUpper s_aiJo
      }


------ Local rules for imported ids --------
"SC:printPieceList0"
    forall (sc_sjOV :: GHC.Prim.State# GHC.Prim.RealWorld)
           (sc1_sjOT :: (PieceType, Colour, (Int, Int), Int))
           (sc2_sjOU :: [(PieceType, Colour, (Int, Int), Int)]).
      UI.printCapturedPieces2 (GHC.Types.: @ Piece sc1_sjOT sc2_sjOU)
                              sc_sjOV
      = UI.printCapturedPieces_$sprintPieceList sc_sjOV sc1_sjOT sc2_sjOU


[ 5 of 14] Compiling Debug            ( Debug.hs, Debug.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 808, types: 1,175, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addEnd1Kings4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addEnd1Kings4 = GHC.Types.I# 5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns11 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns11 = GHC.Types.I# 3#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces24 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces24
  = (Debug.addEnd1Kings4, Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestKings4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestKings4
  = (TypeDefs.King, TypeDefs.White, Debug.addEnd3Pieces24,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns14 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns14 = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestKings3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestKings3
  = (Debug.addBlackEnd1Pawns14, Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestKings2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestKings2
  = (TypeDefs.King, TypeDefs.Black, Debug.addTestKings3,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestKings1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestKings1
  = GHC.Types.: @ Piece Debug.addTestKings2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addTestKings :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestKings
  = GHC.Types.: @ Piece Debug.addTestKings4 Debug.addTestKings1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns6 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns6 = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns18 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns18 = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestPawns11 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns11
  = (Debug.addBlackEnd1Pawns6, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPawns10 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPawns10
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addTestPawns11,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns15 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns15 = GHC.Types.I# 2#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestPawns9 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns9
  = (Debug.addBlackEnd1Pawns15, Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPawns8 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPawns8
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addTestPawns9,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns7
  = (Debug.addBlackEnd1Pawns11, Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPawns7 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPawns7
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3BlackPawns7,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns8 = GHC.Types.I# 6#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns10 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns10
  = (Debug.addBlackEnd1Pawns18, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPawns6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPawns6
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3BlackPawns10,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces21 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces21
  = (Debug.addBlackEnd1Pawns8, Debug.addEnd1Kings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPawns5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPawns5
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3Pieces21,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestPawns4 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns4
  = GHC.Types.: @ Piece Debug.addTestPawns5 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addTestPawns3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns3
  = GHC.Types.: @ Piece Debug.addTestPawns6 Debug.addTestPawns4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addTestPawns2 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns2
  = GHC.Types.: @ Piece Debug.addTestPawns7 Debug.addTestPawns3

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addTestPawns1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPawns1
  = GHC.Types.: @ Piece Debug.addTestPawns8 Debug.addTestPawns2

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addTestPawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestPawns
  = GHC.Types.: @ Piece Debug.addTestPawns10 Debug.addTestPawns1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestKnights4 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestKnights4
  = (Debug.addBlackEnd1Pawns11, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestKnights3 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestKnights3
  = (TypeDefs.Knight, TypeDefs.White, Debug.addTestKnights4,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Bishops3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Bishops3
  = (Debug.addBlackEnd1Pawns18, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestKnights2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestKnights2
  = (TypeDefs.Knight, TypeDefs.Black, Debug.addEnd3Bishops3,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestKnights1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestKnights1
  = GHC.Types.: @ Piece Debug.addTestKnights2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addTestKnights :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestKnights
  = GHC.Types.: @ Piece Debug.addTestKnights3 Debug.addTestKnights1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns13 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns13
  = (Debug.addBlackEnd1Pawns15, Debug.addBlackEnd1Pawns14)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPieces4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPieces4
  = (TypeDefs.Queen, TypeDefs.White, Debug.addBlackEnd1Pawns13,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
addTestQueens :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestQueens
  = GHC.Types.: @ Piece Debug.addTestPieces4 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestPieces7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestPieces7
  = (Debug.addEnd1Kings4, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPieces6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestPieces6
  = (TypeDefs.Rook, TypeDefs.White, Debug.addTestPieces7,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
addTestRooks :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestRooks
  = GHC.Types.: @ Piece Debug.addTestPieces6 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Rooks3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Rooks3
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestBishops3 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestBishops3
  = (TypeDefs.Bishop, TypeDefs.Black, Debug.addEnd2Rooks3,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns21 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.addBlackEnd1Pawns21 = GHC.Types.I# 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Kings3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Kings3
  = (Debug.addBlackEnd1Pawns21, Debug.addEnd1Kings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addTestBishops2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addTestBishops2
  = (TypeDefs.Bishop, TypeDefs.White, Debug.addEnd3Kings3,
     Debug.addEnd1Kings4)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addTestBishops1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addTestBishops1
  = GHC.Types.: @ Piece Debug.addTestBishops2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addTestBishops :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addTestBishops
  = GHC.Types.: @ Piece Debug.addTestBishops3 Debug.addTestBishops1

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPieces5 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addTestPieces5
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addTestBishops
      Debug.addTestPieces6
      (GHC.Types.[] @ Piece)

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Debug.addTestPieces3 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addTestPieces3
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addTestPieces5
      Debug.addTestPieces4
      (GHC.Types.[] @ Piece)

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addTestPieces2 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addTestPieces2
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addTestPieces3
      Debug.addTestKnights3
      Debug.addTestKnights1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addTestPieces1 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addTestPieces1
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addTestPieces2
      Debug.addTestPawns10
      Debug.addTestPawns1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
addTestPieces :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
addTestPieces
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addTestPieces1
      Debug.addTestKings4
      Debug.addTestKings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Kings6 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Kings6
  = (Debug.addBlackEnd1Pawns6, Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Kings5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Kings5
  = (TypeDefs.King, TypeDefs.White, Debug.addEnd1Kings6,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Kings3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Kings3
  = (Debug.addBlackEnd1Pawns15, Debug.addEnd1Kings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Kings2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Kings2
  = (TypeDefs.King, TypeDefs.Black, Debug.addEnd1Kings3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Kings1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Kings1
  = GHC.Types.: @ Piece Debug.addEnd1Kings2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd1Kings :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd1Kings
  = GHC.Types.: @ Piece Debug.addEnd1Kings5 Debug.addEnd1Kings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns20 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns20
  = (Debug.addBlackEnd1Pawns15, Debug.addBlackEnd1Pawns21)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns19 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addBlackEnd1Pawns19
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addBlackEnd1Pawns20,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns17 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns17
  = (Debug.addBlackEnd1Pawns15, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns16 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addBlackEnd1Pawns16
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addBlackEnd1Pawns17,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns12 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addBlackEnd1Pawns12
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addBlackEnd1Pawns13,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns10 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns10
  = (Debug.addBlackEnd1Pawns11, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns9 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addBlackEnd1Pawns9
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addBlackEnd1Pawns10,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns7
  = (Debug.addBlackEnd1Pawns6, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addBlackEnd1Pawns5
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addBlackEnd1Pawns7,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns4 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns4
  = GHC.Types.:
      @ Piece Debug.addBlackEnd1Pawns5 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns3
  = GHC.Types.:
      @ Piece Debug.addBlackEnd1Pawns9 Debug.addBlackEnd1Pawns4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns2 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns2
  = GHC.Types.:
      @ Piece Debug.addBlackEnd1Pawns12 Debug.addBlackEnd1Pawns3

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addBlackEnd1Pawns1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addBlackEnd1Pawns1
  = GHC.Types.:
      @ Piece Debug.addBlackEnd1Pawns16 Debug.addBlackEnd1Pawns2

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addBlackEnd1Pawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addBlackEnd1Pawns
  = GHC.Types.:
      @ Piece Debug.addBlackEnd1Pawns19 Debug.addBlackEnd1Pawns1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces13 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces13
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns21)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces12 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Pieces12
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Pieces13,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces11 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces11
  = (Debug.addEnd1Kings4, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces10 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Pieces10
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Pieces11,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces9 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces9
  = (Debug.addBlackEnd1Pawns6, Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces8 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Pieces8
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Pieces9,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces7
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns14)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Pieces6
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Pieces7,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces5 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces5
  = GHC.Types.: @ Piece Debug.addEnd1Pieces6 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces4 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces4
  = GHC.Types.: @ Piece Debug.addEnd1Pieces8 Debug.addEnd1Pieces5

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Pieces3
  = GHC.Types.: @ Piece Debug.addEnd1Pieces10 Debug.addEnd1Pieces4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addWhiteEnd1Pawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addWhiteEnd1Pawns
  = GHC.Types.: @ Piece Debug.addEnd1Pieces12 Debug.addEnd1Pieces3

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Bishops5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Bishops5
  = (Debug.addBlackEnd1Pawns21, Debug.addBlackEnd1Pawns18)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Bishops4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Bishops4
  = (TypeDefs.Bishop, TypeDefs.White, Debug.addEnd1Bishops5,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Bishops3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Bishops3
  = (Debug.addBlackEnd1Pawns18, Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd1Bishops2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd1Bishops2
  = (TypeDefs.Bishop, TypeDefs.Black, Debug.addEnd1Bishops3,
     Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd1Bishops1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd1Bishops1
  = GHC.Types.: @ Piece Debug.addEnd1Bishops2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd1Bishops :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd1Bishops
  = GHC.Types.: @ Piece Debug.addEnd1Bishops4 Debug.addEnd1Bishops1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces2 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd1Pieces2
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addEnd1Bishops
      Debug.addEnd1Pieces12
      Debug.addEnd1Pieces3

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd1Pieces1 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd1Pieces1
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd1Pieces2
      Debug.addBlackEnd1Pawns19
      Debug.addBlackEnd1Pawns1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
addEnd1Pieces :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
addEnd1Pieces
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd1Pieces1
      Debug.addEnd1Kings5
      Debug.addEnd1Kings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Kings5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Kings5
  = (Debug.addBlackEnd1Pawns21, Debug.addBlackEnd1Pawns21)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Kings4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Kings4
  = (TypeDefs.King, TypeDefs.White, Debug.addEnd2Kings5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Kings3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Kings3
  = (Debug.addBlackEnd1Pawns14, Debug.addEnd1Kings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Kings2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Kings2
  = (TypeDefs.King, TypeDefs.Black, Debug.addEnd2Kings3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Kings1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Kings1
  = GHC.Types.: @ Piece Debug.addEnd2Kings2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd2Kings :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd2Kings
  = GHC.Types.: @ Piece Debug.addEnd2Kings4 Debug.addEnd2Kings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns7 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Pawns7
  = (Debug.addBlackEnd1Pawns18, Debug.addEnd1Kings4)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Pawns6
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd2Pawns7,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Pawns5
  = (Debug.addBlackEnd1Pawns18, Debug.addBlackEnd1Pawns14)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Pawns4
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd2Pawns5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns3 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Pawns3
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addBlackEnd1Pawns10,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns2 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Pawns2
  = GHC.Types.: @ Piece Debug.addEnd2Pawns3 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd2Pawns1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Pawns1
  = GHC.Types.: @ Piece Debug.addEnd2Pawns4 Debug.addEnd2Pawns2

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd2Pawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd2Pawns
  = GHC.Types.: @ Piece Debug.addEnd2Pawns6 Debug.addEnd2Pawns1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Rooks5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Rooks5
  = (Debug.addEnd1Kings4, Debug.addBlackEnd1Pawns14)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Rooks4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Rooks4
  = (TypeDefs.Rook, TypeDefs.White, Debug.addEnd2Rooks5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd2Rooks2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd2Rooks2
  = (TypeDefs.Rook, TypeDefs.White, Debug.addEnd2Rooks3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd2Rooks1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd2Rooks1
  = GHC.Types.: @ Piece Debug.addEnd2Rooks2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd2Rooks :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd2Rooks
  = GHC.Types.: @ Piece Debug.addEnd2Rooks4 Debug.addEnd2Rooks1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd2Pieces1 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd2Pieces1
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addEnd2Rooks
      Debug.addEnd2Pawns6
      Debug.addEnd2Pawns1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
addEnd2Pieces :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
addEnd2Pieces
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd2Pieces1
      Debug.addEnd2Kings4
      Debug.addEnd2Kings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Kings5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Kings5
  = (Debug.addBlackEnd1Pawns14, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Kings4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Kings4
  = (TypeDefs.King, TypeDefs.White, Debug.addEnd3Kings5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Kings2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Kings2
  = (TypeDefs.King, TypeDefs.Black, Debug.addEnd3Kings3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Kings1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Kings1
  = GHC.Types.: @ Piece Debug.addEnd3Kings2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd3Kings :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd3Kings
  = GHC.Types.: @ Piece Debug.addEnd3Kings4 Debug.addEnd3Kings1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Bishops5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Bishops5
  = (Debug.addBlackEnd1Pawns18, Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Bishops4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Bishops4
  = (TypeDefs.Bishop, TypeDefs.White, Debug.addEnd3Bishops5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Bishops2 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Bishops2
  = (TypeDefs.Bishop, TypeDefs.Black, Debug.addEnd3Bishops3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Bishops1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Bishops1
  = GHC.Types.: @ Piece Debug.addEnd3Bishops2 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd3Bishops :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd3Bishops
  = GHC.Types.: @ Piece Debug.addEnd3Bishops4 Debug.addEnd3Bishops1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces8 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces8
  = (Debug.addBlackEnd1Pawns14, Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces7 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces7
  = (TypeDefs.Rook, TypeDefs.White, Debug.addEnd3Pieces8,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces6
  = (TypeDefs.Rook, TypeDefs.White, Debug.addEnd2Kings3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces5 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces5
  = (TypeDefs.Rook, TypeDefs.Black, Debug.addBlackEnd1Pawns13,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces4 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces4
  = GHC.Types.: @ Piece Debug.addEnd3Pieces5 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces3
  = GHC.Types.: @ Piece Debug.addEnd3Pieces6 Debug.addEnd3Pieces4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd3Rooks :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd3Rooks
  = GHC.Types.: @ Piece Debug.addEnd3Pieces7 Debug.addEnd3Pieces3

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces28 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces28
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addBlackEnd1Pawns17,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces27 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces27
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd2Rooks3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces26 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces26
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns15)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces25 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces25
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd3Pieces26,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces23 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces23
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd3Pieces24,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces22 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces22
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Kings6,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces20 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces20
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd3Pieces21,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces19 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces19
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns8)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces18 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces18
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd3Pieces19,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces17 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3Pieces17
  = (TypeDefs.Pawn, TypeDefs.White, Debug.addEnd1Pieces7,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces16 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces16
  = GHC.Types.: @ Piece Debug.addEnd3Pieces17 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces15 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces15
  = GHC.Types.: @ Piece Debug.addEnd3Pieces18 Debug.addEnd3Pieces16

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces14 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces14
  = GHC.Types.: @ Piece Debug.addEnd3Pieces20 Debug.addEnd3Pieces15

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces13 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces13
  = GHC.Types.: @ Piece Debug.addEnd3Pieces22 Debug.addEnd3Pieces14

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces12 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces12
  = GHC.Types.: @ Piece Debug.addEnd3Pieces23 Debug.addEnd3Pieces13

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces11 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces11
  = GHC.Types.: @ Piece Debug.addEnd3Pieces25 Debug.addEnd3Pieces12

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces10 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3Pieces10
  = GHC.Types.: @ Piece Debug.addEnd3Pieces27 Debug.addEnd3Pieces11

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd3WhitePawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd3WhitePawns
  = GHC.Types.: @ Piece Debug.addEnd3Pieces28 Debug.addEnd3Pieces10

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns9 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3BlackPawns9
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3BlackPawns10,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns8 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3BlackPawns8
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd1Kings3,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns6 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3BlackPawns6
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3BlackPawns7,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns5 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns5
  = (Debug.addBlackEnd1Pawns6, Debug.addBlackEnd1Pawns14)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns4 :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
Debug.addEnd3BlackPawns4
  = (TypeDefs.Pawn, TypeDefs.Black, Debug.addEnd3BlackPawns5,
     Debug.addBlackEnd1Pawns11)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns3 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns3
  = GHC.Types.:
      @ Piece Debug.addEnd3BlackPawns4 (GHC.Types.[] @ Piece)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns2 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns2
  = GHC.Types.:
      @ Piece Debug.addEnd3BlackPawns6 Debug.addEnd3BlackPawns3

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Debug.addEnd3BlackPawns1 :: [Piece]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.addEnd3BlackPawns1
  = GHC.Types.:
      @ Piece Debug.addEnd3BlackPawns8 Debug.addEnd3BlackPawns2

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
addEnd3BlackPawns :: AllPieces
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
addEnd3BlackPawns
  = GHC.Types.:
      @ Piece Debug.addEnd3BlackPawns9 Debug.addEnd3BlackPawns1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces9 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd3Pieces9
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addEnd3BlackPawns
      Debug.addEnd3Pieces28
      Debug.addEnd3Pieces10

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces2 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd3Pieces2
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd3Pieces9
      Debug.addEnd3Pieces7
      Debug.addEnd3Pieces3

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Debug.addEnd3Pieces1 :: [(PieceType, Colour, Pos, Movecount)]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Debug.addEnd3Pieces1
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd3Pieces2
      Debug.addEnd3Bishops4
      Debug.addEnd3Bishops1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
addEnd3Pieces :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
addEnd3Pieces
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      Debug.addEnd3Pieces1
      Debug.addEnd3Kings4
      Debug.addEnd3Kings1

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
addCastleTest :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
addCastleTest
  = GHC.Base.++_$s++
      @ (PieceType, Colour, Pos, Movecount)
      addRooks
      Init.addKings5
      Init.addKings1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Debug.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Debug.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.$trModule3 = GHC.Types.TrNameS Debug.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Debug.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Debug.$trModule2 = "Debug"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Debug.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Debug.$trModule1 = GHC.Types.TrNameS Debug.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Debug.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.$trModule
  = GHC.Types.Module Debug.$trModule3 Debug.$trModule1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Debug.buggedPosition3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Debug.buggedPosition3
  = (Debug.addBlackEnd1Pawns8, Debug.addBlackEnd1Pawns6)

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Debug.buggedPosition2 :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 80 0}]
Debug.buggedPosition2
  = Util.captureEnPassant_$s$wexecuteMove
      addAllPieces
      0#
      -2#
      Debug.addBlackEnd1Pawns21
      Debug.buggedPosition3
      TypeDefs.White
      TypeDefs.Pawn

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Debug.buggedPosition1 :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 80 0}]
Debug.buggedPosition1
  = Util.captureEnPassant_$s$wexecuteMove
      Debug.buggedPosition2
      0#
      2#
      Debug.addBlackEnd1Pawns21
      Debug.addEnd1Bishops3
      TypeDefs.Black
      TypeDefs.Pawn

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
buggedPosition :: AllPieces
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 80 0}]
buggedPosition
  = Util.captureEnPassant_$s$wexecuteMove
      Debug.buggedPosition1
      4#
      -4#
      Debug.addBlackEnd1Pawns21
      Debug.addTestKings3
      TypeDefs.White
      TypeDefs.Queen



[ 6 of 14] Compiling EvalOpening      ( EvalOpening.hs, EvalOpening.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,622, types: 930, coercions: 0, joins: 41/43}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceMobMult4 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceMobMult4 = GHC.Types.F# 1.5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceMobMult3 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceMobMult3 = GHC.Types.F# 1.1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceMobMult2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceMobMult2 = GHC.Types.F# 1.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceMobMult1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceMobMult1 = GHC.Types.F# 0.0#

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
pieceMobMult :: Piece -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dkQm [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_dkQm of
                 { (ds1_dkRF [Occ=Once!], _ [Occ=Dead], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case ds1_dkRF of {
                   Pawn -> EvalOpening.pieceMobMult4;
                   Knight -> EvalOpening.pieceMobMult3;
                   Bishop -> EvalOpening.pieceMobMult2;
                   Rook -> EvalOpening.pieceMobMult2;
                   Queen -> EvalOpening.pieceMobMult1;
                   King -> EvalOpening.pieceMobMult1
                 }
                 }}]
pieceMobMult
  = \ (ds_dkQm :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_dkQm of { (ds1_dkRF, ds2_dkRG, ds3_dkRH, ds4_dkRI) ->
      case ds1_dkRF of {
        Pawn -> EvalOpening.pieceMobMult4;
        Knight -> EvalOpening.pieceMobMult3;
        Bishop -> EvalOpening.pieceMobMult2;
        Rook -> EvalOpening.pieceMobMult2;
        Queen -> EvalOpening.pieceMobMult1;
        King -> EvalOpening.pieceMobMult1
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceVal4 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceVal4 = GHC.Types.F# 3.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceVal3 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceVal3 = GHC.Types.F# 3.5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceVal2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceVal2 = GHC.Types.F# 5.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.pieceVal1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.pieceVal1 = GHC.Types.F# 9.0#

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
pieceVal :: Piece -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dkNY [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_dkNY of
                 { (ds1_dkPh [Occ=Once!], _ [Occ=Dead], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case ds1_dkPh of {
                   Pawn -> EvalOpening.pieceMobMult2;
                   Knight -> EvalOpening.pieceVal4;
                   Bishop -> EvalOpening.pieceVal3;
                   Rook -> EvalOpening.pieceVal2;
                   Queen -> EvalOpening.pieceVal1;
                   King -> EvalOpening.pieceMobMult1
                 }
                 }}]
pieceVal
  = \ (ds_dkNY :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_dkNY of { (ds1_dkPh, ds2_dkPi, ds3_dkPj, ds4_dkPk) ->
      case ds1_dkPh of {
        Pawn -> EvalOpening.pieceMobMult2;
        Knight -> EvalOpening.pieceVal4;
        Bishop -> EvalOpening.pieceVal3;
        Rook -> EvalOpening.pieceVal2;
        Queen -> EvalOpening.pieceVal1;
        King -> EvalOpening.pieceMobMult1
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalOpening.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
EvalOpening.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.$trModule3 = GHC.Types.TrNameS EvalOpening.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalOpening.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
EvalOpening.$trModule2 = "EvalOpening"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalOpening.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalOpening.$trModule1 = GHC.Types.TrNameS EvalOpening.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
EvalOpening.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EvalOpening.$trModule
  = GHC.Types.Module EvalOpening.$trModule3 EvalOpening.$trModule1

-- RHS size: {terms: 29, types: 14, coercions: 0, joins: 0/0}
EvalOpening.$wstaticKingMotive [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 120 0}]
EvalOpening.$wstaticKingMotive
  = \ (w_sljE :: Colour) (w1_sljF :: AllPieces) ->
      case findKing w_sljE w1_sljF of { (row_a3ZW, ds1_d52J) ->
      case w_sljE of {
        Black ->
          case row_a3ZW of { GHC.Types.I# x_akST ->
          case x_akST of {
            __DEFAULT -> -5.0#;
            0# -> 0.0#
          }
          };
        White ->
          case row_a3ZW of { GHC.Types.I# x_akST ->
          case x_akST of {
            __DEFAULT -> -5.0#;
            7# -> 0.0#
          }
          }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
staticKingMotive [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sljE [Occ=Once] :: Colour)
                 (w1_sljF [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wstaticKingMotive w_sljE w1_sljF
                 of ww_sljI [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_sljI
                 }}]
staticKingMotive
  = \ (w_sljE :: Colour) (w1_sljF :: AllPieces) ->
      case EvalOpening.$wstaticKingMotive w_sljE w1_sljF of ww_sljI
      { __DEFAULT ->
      GHC.Types.F# ww_sljI
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rkXt :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rkXt = GHC.Types.F# 10.0#

-- RHS size: {terms: 250, types: 193, coercions: 0, joins: 13/14}
getLowestVal :: [Piece] -> Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []]
getLowestVal
  = \ (ps_akIu :: [Piece]) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Float]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Float;
                : y_a24x ys_a24y ->
                  join {
                    exit_XL :: [Float]
                    [LclId[JoinId(0)]]
                    exit_XL
                      = GHC.Types.: @ Float (pieceVal y_a24x) (go_a24t ys_a24y) } in
                  join {
                    exit1_X11 :: [Float]
                    [LclId[JoinId(0)]]
                    exit1_X11 = go_a24t ys_a24y } in
                  join {
                    exit2_X12 :: [Float]
                    [LclId[JoinId(0)]]
                    exit2_X12 = go_a24t ys_a24y } in
                  join {
                    exit3_X13 :: [Float]
                    [LclId[JoinId(0)]]
                    exit3_X13 = go_a24t ys_a24y } in
                  join {
                    exit4_X14 :: [Float]
                    [LclId[JoinId(0)]]
                    exit4_X14 = go_a24t ys_a24y } in
                  join {
                    exit5_X15 :: [Float]
                    [LclId[JoinId(0)]]
                    exit5_X15 = go_a24t ys_a24y } in
                  case ps_akIu of {
                    [] -> jump exit_XL;
                    : y1_X260 ys1_X262 ->
                      case y1_X260 of { (ds1_dkPh, ds2_dkPi, ds3_dkPj, ds4_dkPk) ->
                      join {
                        $j_sl1H [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Float# -> [Float]
                        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                        $j_sl1H (x_akT9 [OS=OneShot] :: GHC.Prim.Float#)
                          = case y_a24x of { (ds5_XkR6, ds6_XkR8, ds7_XkRa, ds8_XkRc) ->
                            case ds5_XkR6 of {
                              Pawn ->
                                case GHC.Prim.geFloat# x_akT9 1.0# of {
                                  __DEFAULT -> jump exit1_X11;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of {
                                                __DEFAULT -> jump go1_X25S ys2_X27P;
                                                King -> jump exit1_X11
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                };
                              Knight ->
                                case GHC.Prim.geFloat# x_akT9 3.0# of {
                                  __DEFAULT -> jump exit2_X12;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of {
                                                __DEFAULT -> jump exit2_X12;
                                                Knight -> jump go1_X25S ys2_X27P;
                                                Bishop -> jump go1_X25S ys2_X27P;
                                                Rook -> jump go1_X25S ys2_X27P;
                                                Queen -> jump go1_X25S ys2_X27P
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                };
                              Bishop ->
                                case GHC.Prim.geFloat# x_akT9 3.5# of {
                                  __DEFAULT -> jump exit3_X13;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of {
                                                __DEFAULT -> jump exit3_X13;
                                                Bishop -> jump go1_X25S ys2_X27P;
                                                Rook -> jump go1_X25S ys2_X27P;
                                                Queen -> jump go1_X25S ys2_X27P
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                };
                              Rook ->
                                case GHC.Prim.geFloat# x_akT9 5.0# of {
                                  __DEFAULT -> jump exit4_X14;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of {
                                                __DEFAULT -> jump exit4_X14;
                                                Rook -> jump go1_X25S ys2_X27P;
                                                Queen -> jump go1_X25S ys2_X27P
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                };
                              Queen ->
                                case GHC.Prim.geFloat# x_akT9 9.0# of {
                                  __DEFAULT -> jump exit5_X15;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of {
                                                __DEFAULT -> jump exit5_X15;
                                                Queen -> jump go1_X25S ys2_X27P
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                };
                              King ->
                                case GHC.Prim.geFloat# x_akT9 0.0# of {
                                  __DEFAULT -> go_a24t ys_a24y;
                                  1# ->
                                    joinrec {
                                      go1_X25S [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25S (ds9_X25U :: [Piece])
                                        = case ds9_X25U of {
                                            [] -> jump exit_XL;
                                            : y2_X27M ys2_X27P ->
                                              case y2_X27M of
                                              { (ds10_XkR9, ds11_XkRb, ds12_XkRd, ds13_XkRf) ->
                                              case ds10_XkR9 of { __DEFAULT ->
                                              jump go1_X25S ys2_X27P
                                              }
                                              }
                                          }; } in
                                    jump go1_X25S ys1_X262
                                }
                            }
                            } } in
                      case ds1_dkPh of {
                        Pawn -> jump $j_sl1H 1.0#;
                        Knight -> jump $j_sl1H 3.0#;
                        Bishop -> jump $j_sl1H 3.5#;
                        Rook -> jump $j_sl1H 5.0#;
                        Queen -> jump $j_sl1H 9.0#;
                        King -> jump $j_sl1H 0.0#
                      }
                      }
                  }
              }; } in
      case go_a24t ps_akIu of {
        [] -> lvl_rkXt;
        : ds1_a5jz ds2_a5jA -> ds1_a5jz
      }

-- RHS size: {terms: 75, types: 34, coercions: 0, joins: 1/2}
EvalOpening.$wpieceMaterial [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 376 0}]
EvalOpening.$wpieceMaterial
  = \ (w_sljP :: Piece) (w1_sljQ :: AllPieces) ->
      let {
        t_sl0y [Dmd=<S,U>] :: [Piece]
        [LclId]
        t_sl0y = threatenedBy w_sljP w1_sljQ } in
      case GHC.List.$wlenAcc
             @ (PieceType, Colour, Pos, Movecount) t_sl0y 0#
      of ww2_al5S
      { __DEFAULT ->
      case GHC.List.$wlenAcc
             @ (PieceType, Colour, Pos, Movecount)
             (protectedBy w_sljP w1_sljQ)
             0#
      of ww1_Xl7C
      { __DEFAULT ->
      case GHC.Prim.># ww2_al5S ww1_Xl7C of {
        __DEFAULT ->
          case getLowestVal t_sl0y of { GHC.Types.F# x_akTs ->
          case w_sljP of { (ds_dkPh, ds1_dkPi, ds2_dkPj, ds3_dkPk) ->
          join {
            $j_sl1S [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
            [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
            $j_sl1S (y_akTv [OS=OneShot] :: GHC.Prim.Float#)
              = case GHC.Prim.ltFloat# x_akTs y_akTv of {
                  __DEFAULT ->
                    case ds_dkPh of {
                      Pawn -> 1.0#;
                      Knight -> 3.0#;
                      Bishop -> 3.5#;
                      Rook -> 5.0#;
                      Queen -> 9.0#;
                      King -> 0.0#
                    };
                  1# -> 0.0#
                } } in
          case ds_dkPh of {
            Pawn -> jump $j_sl1S 1.0#;
            Knight -> jump $j_sl1S 3.0#;
            Bishop -> jump $j_sl1S 3.5#;
            Rook -> jump $j_sl1S 5.0#;
            Queen -> jump $j_sl1S 9.0#;
            King -> jump $j_sl1S 0.0#
          }
          }
          };
        1# -> 0.0#
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
pieceMaterial [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U(U,U,U(U(U),U(U)),U(U))><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sljP [Occ=Once] :: Piece)
                 (w1_sljQ [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wpieceMaterial w_sljP w1_sljQ
                 of ww_sljT [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_sljT
                 }}]
pieceMaterial
  = \ (w_sljP :: Piece) (w1_sljQ :: AllPieces) ->
      case EvalOpening.$wpieceMaterial w_sljP w1_sljQ of ww_sljT
      { __DEFAULT ->
      GHC.Types.F# ww_sljT
      }

-- RHS size: {terms: 30, types: 14, coercions: 0, joins: 1/1}
EvalOpening.$wcastleMotive [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 0}]
EvalOpening.$wcastleMotive
  = \ (w_slk0 :: Colour) (w1_slk1 :: AllPieces) ->
      case findKing w_slk0 w1_slk1 of { (ds1_d52T, col_a3ZV) ->
      case col_a3ZV of { GHC.Types.I# ww1_sljX ->
      joinrec {
        go_a3xy [Occ=LoopBreaker] :: GHC.Prim.Int# -> GHC.Prim.Float#
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_a3xy (x_a3xz :: GHC.Prim.Int#)
          = case GHC.Prim.==# x_a3xz ww1_sljX of {
              __DEFAULT ->
                case x_a3xz of wild1_X1x {
                  __DEFAULT -> jump go_a3xy (GHC.Prim.+# wild1_X1x 1#);
                  5# -> 0.0#
                };
              1# -> -5.0#
            }; } in
      jump go_a3xy 3#
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
castleMotive [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slk0 [Occ=Once] :: Colour)
                 (w1_slk1 [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wcastleMotive w_slk0 w1_slk1
                 of ww_slk4 [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_slk4
                 }}]
castleMotive
  = \ (w_slk0 :: Colour) (w1_slk1 :: AllPieces) ->
      case EvalOpening.$wcastleMotive w_slk0 w1_slk1 of ww_slk4
      { __DEFAULT ->
      GHC.Types.F# ww_slk4
      }

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
kingSafety [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slk6 :: Colour) (w1_slk7 :: AllPieces) ->
                 case EvalOpening.$wcastleMotive w_slk6 w1_slk7
                 of ww_slk4 [Occ=Once]
                 { __DEFAULT ->
                 case EvalOpening.$wstaticKingMotive w_slk6 w1_slk7
                 of ww1_sljI [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# (GHC.Prim.plusFloat# ww_slk4 ww1_sljI)
                 }
                 }}]
kingSafety
  = \ (w_slk6 :: Colour) (w1_slk7 :: AllPieces) ->
      case EvalOpening.$wcastleMotive w_slk6 w1_slk7 of ww_slk4
      { __DEFAULT ->
      case EvalOpening.$wstaticKingMotive w_slk6 w1_slk7 of ww1_sljI
      { __DEFAULT ->
      GHC.Types.F# (GHC.Prim.plusFloat# ww_slk4 ww1_sljI)
      }
      }

-- RHS size: {terms: 546, types: 294, coercions: 0, joins: 19/19}
EvalOpening.$wtotalMaterial [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
EvalOpening.$wtotalMaterial
  = \ (w_slkr :: Colour) (w1_slks :: AllPieces) ->
      join {
        $j_slhm [Dmd=<C(S),C(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(1)], Arity=1, Str=<L,U>]
        $j_slhm (x_akU6 [OS=OneShot] :: GHC.Prim.Float#)
          = join {
              exit_XJ [Dmd=<C(S),C(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
              [LclId[JoinId(1)], Arity=1, Str=<L,U>]
              exit_XJ (ww_slkg [OS=OneShot] :: GHC.Prim.Float#)
                = GHC.Prim.timesFloat#
                    10.0# (GHC.Prim.minusFloat# x_akU6 ww_slkg) } in
            joinrec {
              $wgo_slki [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
              [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
              $wgo_slki (w2_slkc :: [Piece]) (ww_slkg :: GHC.Prim.Float#)
                = case w2_slkc of {
                    [] -> jump exit_XJ ww_slkg;
                    : y_a24x ys_a24y ->
                      case y_a24x of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                      case pos_a3ZY of { (a1_a5lR, a2_a5lS) ->
                      case a1_a5lR of { GHC.Types.I# x1_a5hr ->
                      join {
                        $j1_sl2j [Dmd=<L,1*U>] :: GHC.Prim.Float#
                        [LclId[JoinId(0)]]
                        $j1_sl2j
                          = join {
                              $j2_sl2f [Dmd=<L,1*U>] :: GHC.Prim.Float#
                              [LclId[JoinId(0)]]
                              $j2_sl2f
                                = case ds1_d4Xh of {
                                    Pawn ->
                                      jump $wgo_slki ys_a24y (GHC.Prim.plusFloat# ww_slkg 1.0#);
                                    Knight ->
                                      jump $wgo_slki ys_a24y (GHC.Prim.plusFloat# ww_slkg 3.0#);
                                    Bishop ->
                                      jump $wgo_slki ys_a24y (GHC.Prim.plusFloat# ww_slkg 3.5#);
                                    Rook ->
                                      jump $wgo_slki ys_a24y (GHC.Prim.plusFloat# ww_slkg 5.0#);
                                    Queen ->
                                      jump $wgo_slki ys_a24y (GHC.Prim.plusFloat# ww_slkg 9.0#);
                                    King -> jump $wgo_slki ys_a24y ww_slkg
                                  } } in
                            case ds2_d4Xi of {
                              Black ->
                                case w_slkr of {
                                  Black ->
                                    joinrec {
                                      $wgo1_XllX [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                        :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                      [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                      $wgo1_XllX (w3_XllS :: [Piece]) (ww1_XlnE :: GHC.Prim.Float#)
                                        = case w3_XllS of {
                                            [] -> jump exit_XJ ww1_XlnE;
                                            : y1_X26h ys1_X26j ->
                                              case y1_X26h of
                                              { (ds4_X4Z7, ds5_X4Z9, pos1_X41Q, ds6_X4Zc) ->
                                              case pos1_X41Q of { (a4_X5nP, a5_X5nR) ->
                                              case a4_X5nP of { GHC.Types.I# x2_X5jv ->
                                              join {
                                                $j3_Xl4q [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                                [LclId[JoinId(0)]]
                                                $j3_Xl4q
                                                  = case ds5_X4Z9 of {
                                                      Black -> jump $wgo1_XllX ys1_X26j ww1_XlnE;
                                                      White ->
                                                        case ds4_X4Z7 of {
                                                          Pawn ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 1.0#);
                                                          Knight ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 3.0#);
                                                          Bishop ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 3.5#);
                                                          Rook ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 5.0#);
                                                          Queen ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 9.0#);
                                                          King -> jump $wgo1_XllX ys1_X26j ww1_XlnE
                                                        }
                                                    } } in
                                              case x2_X5jv of {
                                                __DEFAULT -> jump $j3_Xl4q;
                                                -1# ->
                                                  case a5_X5nR of { GHC.Types.I# x3_X5jH ->
                                                  case x3_X5jH of {
                                                    __DEFAULT -> jump $j3_Xl4q;
                                                    -1# -> jump $wgo1_XllX ys1_X26j ww1_XlnE
                                                  }
                                                  }
                                              }
                                              }
                                              }
                                              }
                                          }; } in
                                    jump $wgo1_XllX ys_a24y ww_slkg;
                                  White -> jump $j2_sl2f
                                };
                              White ->
                                case w_slkr of {
                                  Black -> jump $j2_sl2f;
                                  White ->
                                    joinrec {
                                      $wgo1_XllX [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                        :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                      [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                      $wgo1_XllX (w3_XllS :: [Piece]) (ww1_XlnE :: GHC.Prim.Float#)
                                        = case w3_XllS of {
                                            [] -> jump exit_XJ ww1_XlnE;
                                            : y1_X26h ys1_X26j ->
                                              case y1_X26h of
                                              { (ds4_X4Z7, ds5_X4Z9, pos1_X41Q, ds6_X4Zc) ->
                                              case pos1_X41Q of { (a4_X5nP, a5_X5nR) ->
                                              case a4_X5nP of { GHC.Types.I# x2_X5jv ->
                                              join {
                                                $j3_Xl4q [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                                [LclId[JoinId(0)]]
                                                $j3_Xl4q
                                                  = case ds5_X4Z9 of {
                                                      Black ->
                                                        case ds4_X4Z7 of {
                                                          Pawn ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 1.0#);
                                                          Knight ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 3.0#);
                                                          Bishop ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 3.5#);
                                                          Rook ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 5.0#);
                                                          Queen ->
                                                            jump $wgo1_XllX
                                                              ys1_X26j
                                                              (GHC.Prim.plusFloat# ww1_XlnE 9.0#);
                                                          King -> jump $wgo1_XllX ys1_X26j ww1_XlnE
                                                        };
                                                      White -> jump $wgo1_XllX ys1_X26j ww1_XlnE
                                                    } } in
                                              case x2_X5jv of {
                                                __DEFAULT -> jump $j3_Xl4q;
                                                -1# ->
                                                  case a5_X5nR of { GHC.Types.I# x3_X5jH ->
                                                  case x3_X5jH of {
                                                    __DEFAULT -> jump $j3_Xl4q;
                                                    -1# -> jump $wgo1_XllX ys1_X26j ww1_XlnE
                                                  }
                                                  }
                                              }
                                              }
                                              }
                                              }
                                          }; } in
                                    jump $wgo1_XllX ys_a24y ww_slkg
                                }
                            } } in
                      case x1_a5hr of {
                        __DEFAULT -> jump $j1_sl2j;
                        -1# ->
                          case a2_a5lS of { GHC.Types.I# x2_X5jH ->
                          case x2_X5jH of {
                            __DEFAULT -> jump $j1_sl2j;
                            -1# -> jump $wgo_slki ys_a24y ww_slkg
                          }
                          }
                      }
                      }
                      }
                      }
                  }; } in
            jump $wgo_slki w1_slks 0.0# } in
      joinrec {
        $wgo_slkq [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
          :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        $wgo_slkq (w2_slkk :: [Piece]) (ww_slko :: GHC.Prim.Float#)
          = case w2_slkk of {
              [] -> jump $j_slhm ww_slko;
              : y_a24x ys_a24y ->
                case y_a24x of wild1_X1y
                { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                case pos_a3ZY of { (a1_a5lR, a2_a5lS) ->
                case a1_a5lR of { GHC.Types.I# x_a5hr ->
                join {
                  $j1_sl27 [Dmd=<L,1*U>] :: GHC.Prim.Float#
                  [LclId[JoinId(0)]]
                  $j1_sl27
                    = case ds2_d4Xi of {
                        Black ->
                          case w_slkr of {
                            Black ->
                              case EvalOpening.$wpieceMaterial wild1_X1y w1_slks of ww1_sljT
                              { __DEFAULT ->
                              joinrec {
                                $wgo1_Xlm5 [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_Xlm5 (w3_Xlm0 :: [Piece]) (ww2_XlnM :: GHC.Prim.Float#)
                                  = case w3_Xlm0 of {
                                      [] -> jump $j_slhm ww2_XlnM;
                                      : y1_X26h ys1_X26j ->
                                        case y1_X26h of wild7_X3m
                                        { (ds4_X4Z7, ds5_X4Z9, pos1_X41Q, ds6_X4Zc) ->
                                        case pos1_X41Q of { (a4_X5nQ, a5_X5nS) ->
                                        case a4_X5nQ of { GHC.Types.I# x1_X5jw ->
                                        join {
                                          $j2_Xl4f [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xl4f
                                            = case ds5_X4Z9 of {
                                                Black ->
                                                  case EvalOpening.$wpieceMaterial wild7_X3m w1_slks
                                                  of ww3_Xlm6
                                                  { __DEFAULT ->
                                                  jump $wgo1_Xlm5
                                                    ys1_X26j (GHC.Prim.plusFloat# ww2_XlnM ww3_Xlm6)
                                                  };
                                                White -> jump $wgo1_Xlm5 ys1_X26j ww2_XlnM
                                              } } in
                                        case x1_X5jw of {
                                          __DEFAULT -> jump $j2_Xl4f;
                                          -1# ->
                                            case a5_X5nS of { GHC.Types.I# x2_X5jD ->
                                            case x2_X5jD of {
                                              __DEFAULT -> jump $j2_Xl4f;
                                              -1# -> jump $wgo1_Xlm5 ys1_X26j ww2_XlnM
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_Xlm5 ys_a24y (GHC.Prim.plusFloat# ww_slko ww1_sljT)
                              };
                            White ->
                              joinrec {
                                $wgo1_XlnE [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XlnE (w3_XllX :: [Piece]) (ww1_XlnG :: GHC.Prim.Float#)
                                  = case w3_XllX of {
                                      [] -> jump $j_slhm ww1_XlnG;
                                      : y1_X26e ys1_X26g ->
                                        case y1_X26e of wild7_X3j
                                        { (ds4_X4Z4, ds5_X4Z6, pos1_X41N, ds6_X4Z9) ->
                                        case pos1_X41N of { (a4_X5nN, a5_X5nP) ->
                                        case a4_X5nN of { GHC.Types.I# x1_X5jt ->
                                        join {
                                          $j2_Xl4c [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xl4c
                                            = case ds5_X4Z6 of {
                                                Black -> jump $wgo1_XlnE ys1_X26g ww1_XlnG;
                                                White ->
                                                  case EvalOpening.$wpieceMaterial wild7_X3j w1_slks
                                                  of ww2_sljT
                                                  { __DEFAULT ->
                                                  jump $wgo1_XlnE
                                                    ys1_X26g (GHC.Prim.plusFloat# ww1_XlnG ww2_sljT)
                                                  }
                                              } } in
                                        case x1_X5jt of {
                                          __DEFAULT -> jump $j2_Xl4c;
                                          -1# ->
                                            case a5_X5nP of { GHC.Types.I# x2_X5jD ->
                                            case x2_X5jD of {
                                              __DEFAULT -> jump $j2_Xl4c;
                                              -1# -> jump $wgo1_XlnE ys1_X26g ww1_XlnG
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XlnE ys_a24y ww_slko
                          };
                        White ->
                          case w_slkr of {
                            Black ->
                              joinrec {
                                $wgo1_XlnE [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XlnE (w3_XllX :: [Piece]) (ww1_XlnG :: GHC.Prim.Float#)
                                  = case w3_XllX of {
                                      [] -> jump $j_slhm ww1_XlnG;
                                      : y1_X26e ys1_X26g ->
                                        case y1_X26e of wild7_X3j
                                        { (ds4_X4Z4, ds5_X4Z6, pos1_X41N, ds6_X4Z9) ->
                                        case pos1_X41N of { (a4_X5nN, a5_X5nP) ->
                                        case a4_X5nN of { GHC.Types.I# x1_X5jt ->
                                        join {
                                          $j2_Xl4c [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xl4c
                                            = case ds5_X4Z6 of {
                                                Black ->
                                                  case EvalOpening.$wpieceMaterial wild7_X3j w1_slks
                                                  of ww2_sljT
                                                  { __DEFAULT ->
                                                  jump $wgo1_XlnE
                                                    ys1_X26g (GHC.Prim.plusFloat# ww1_XlnG ww2_sljT)
                                                  };
                                                White -> jump $wgo1_XlnE ys1_X26g ww1_XlnG
                                              } } in
                                        case x1_X5jt of {
                                          __DEFAULT -> jump $j2_Xl4c;
                                          -1# ->
                                            case a5_X5nP of { GHC.Types.I# x2_X5jD ->
                                            case x2_X5jD of {
                                              __DEFAULT -> jump $j2_Xl4c;
                                              -1# -> jump $wgo1_XlnE ys1_X26g ww1_XlnG
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XlnE ys_a24y ww_slko;
                            White ->
                              case EvalOpening.$wpieceMaterial wild1_X1y w1_slks of ww1_sljT
                              { __DEFAULT ->
                              joinrec {
                                $wgo1_Xlm5 [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_Xlm5 (w3_Xlm0 :: [Piece]) (ww2_XlnM :: GHC.Prim.Float#)
                                  = case w3_Xlm0 of {
                                      [] -> jump $j_slhm ww2_XlnM;
                                      : y1_X26h ys1_X26j ->
                                        case y1_X26h of wild7_X3m
                                        { (ds4_X4Z7, ds5_X4Z9, pos1_X41Q, ds6_X4Zc) ->
                                        case pos1_X41Q of { (a4_X5nQ, a5_X5nS) ->
                                        case a4_X5nQ of { GHC.Types.I# x1_X5jw ->
                                        join {
                                          $j2_Xl4f [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xl4f
                                            = case ds5_X4Z9 of {
                                                Black -> jump $wgo1_Xlm5 ys1_X26j ww2_XlnM;
                                                White ->
                                                  case EvalOpening.$wpieceMaterial wild7_X3m w1_slks
                                                  of ww3_Xlm6
                                                  { __DEFAULT ->
                                                  jump $wgo1_Xlm5
                                                    ys1_X26j (GHC.Prim.plusFloat# ww2_XlnM ww3_Xlm6)
                                                  }
                                              } } in
                                        case x1_X5jw of {
                                          __DEFAULT -> jump $j2_Xl4f;
                                          -1# ->
                                            case a5_X5nS of { GHC.Types.I# x2_X5jD ->
                                            case x2_X5jD of {
                                              __DEFAULT -> jump $j2_Xl4f;
                                              -1# -> jump $wgo1_Xlm5 ys1_X26j ww2_XlnM
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_Xlm5 ys_a24y (GHC.Prim.plusFloat# ww_slko ww1_sljT)
                              }
                          }
                      } } in
                case x_a5hr of {
                  __DEFAULT -> jump $j1_sl27;
                  -1# ->
                    case a2_a5lS of { GHC.Types.I# x1_X5jD ->
                    case x1_X5jD of {
                      __DEFAULT -> jump $j1_sl27;
                      -1# -> jump $wgo_slkq ys_a24y ww_slko
                    }
                    }
                }
                }
                }
                }
            }; } in
      jump $wgo_slkq w1_slks 0.0#

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalMaterial [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slkr [Occ=Once] :: Colour)
                 (w1_slks [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wtotalMaterial w_slkr w1_slks
                 of ww_slkv [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_slkv
                 }}]
totalMaterial
  = \ (w_slkr :: Colour) (w1_slks :: AllPieces) ->
      case EvalOpening.$wtotalMaterial w_slkr w1_slks of ww_slkv
      { __DEFAULT ->
      GHC.Types.F# ww_slkv
      }

-- RHS size: {terms: 71, types: 38, coercions: 0, joins: 0/0}
EvalOpening.$wevalPiece [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour -> Pos -> Movecount -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=5,
 Str=<S,1*U><L,U><L,U(U(U),U(U))><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [314 0 0 0 0] 386 0}]
EvalOpening.$wevalPiece
  = \ (ww_slkC :: PieceType)
      (ww1_slkD :: Colour)
      (ww2_slkE :: Pos)
      (ww3_slkF :: Movecount)
      (w_slkz :: AllPieces) ->
      case ww_slkC of {
        Pawn ->
          case GHC.List.$wlenAcc
                 @ (Int, Int)
                 (legalPawnMoves
                    (TypeDefs.Pawn, ww1_slkD, ww2_slkE, ww3_slkF) w_slkz)
                 0#
          of ww4_al5S
          { __DEFAULT ->
          GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww4_al5S) 1.5#
          };
        Knight ->
          case GHC.List.$wlenAcc
                 @ (Int, Int)
                 (legalKnightMoves
                    (TypeDefs.Knight, ww1_slkD, ww2_slkE, ww3_slkF) w_slkz)
                 0#
          of ww4_al5S
          { __DEFAULT ->
          GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww4_al5S) 1.1#
          };
        Bishop ->
          case GHC.List.$wlenAcc
                 @ (Int, Int)
                 (legalBishopMoves
                    (TypeDefs.Bishop, ww1_slkD, ww2_slkE, ww3_slkF) w_slkz)
                 0#
          of ww4_al5S
          { __DEFAULT ->
          GHC.Prim.int2Float# ww4_al5S
          };
        Rook ->
          case GHC.List.$wlenAcc
                 @ (Int, Int)
                 (legalRookMoves
                    (TypeDefs.Rook, ww1_slkD, ww2_slkE, ww3_slkF) w_slkz)
                 0#
          of ww4_al5S
          { __DEFAULT ->
          GHC.Prim.int2Float# ww4_al5S
          };
        Queen -> 0.0#;
        King -> 0.0#
      }

-- RHS size: {terms: 15, types: 8, coercions: 0, joins: 0/0}
evalPiece [InlPrag=NOUSERINLINE[2]] :: Piece -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(1*U,U,U(U(U),U(U)),U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slky [Occ=Once!] :: Piece)
                 (w1_slkz [Occ=Once] :: AllPieces) ->
                 case w_slky of
                 { (ww1_slkC [Occ=Once], ww2_slkD [Occ=Once], ww3_slkE [Occ=Once],
                    ww4_slkF [Occ=Once]) ->
                 case EvalOpening.$wevalPiece
                        ww1_slkC ww2_slkD ww3_slkE ww4_slkF w1_slkz
                 of ww5_slkJ [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww5_slkJ
                 }
                 }}]
evalPiece
  = \ (w_slky :: Piece) (w1_slkz :: AllPieces) ->
      case w_slky of { (ww1_slkC, ww2_slkD, ww3_slkE, ww4_slkF) ->
      case EvalOpening.$wevalPiece
             ww1_slkC ww2_slkD ww3_slkE ww4_slkF w1_slkz
      of ww5_slkJ
      { __DEFAULT ->
      GHC.Types.F# ww5_slkJ
      }
      }

-- RHS size: {terms: 400, types: 206, coercions: 0, joins: 7/7}
EvalOpening.$wtotalMobility [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
EvalOpening.$wtotalMobility
  = \ (w_slkT :: Colour) (w1_slkU :: AllPieces) ->
      joinrec {
        $wgo_slkS [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
          :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        $wgo_slkS (w2_slkM :: [Piece]) (ww_slkQ :: GHC.Prim.Float#)
          = case w2_slkM of {
              [] -> ww_slkQ;
              : y_a24x ys_a24y ->
                case y_a24x of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                join {
                  $j_sl2A [Dmd=<L,1*U>] :: GHC.Prim.Float#
                  [LclId[JoinId(0)]]
                  $j_sl2A
                    = case ds2_d52a of wild2_a5lQ { (a1_a5lR, a2_a5lS) ->
                      case a1_a5lR of { GHC.Types.I# x_a5hr ->
                      join {
                        $j1_sl2x [Dmd=<L,1*U>] :: GHC.Prim.Float#
                        [LclId[JoinId(0)]]
                        $j1_sl2x
                          = case ds1_d529 of {
                              Pawn ->
                                case GHC.List.$wlenAcc
                                       @ (Int, Int)
                                       (legalPawnMoves
                                          (TypeDefs.Pawn, colour_a3ZX, wild2_a5lQ, ds3_d52b)
                                          w1_slkU)
                                       0#
                                of ww2_al5S
                                { __DEFAULT ->
                                jump $wgo_slkS
                                  ys_a24y
                                  (GHC.Prim.plusFloat#
                                     ww_slkQ
                                     (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.5#))
                                };
                              Knight ->
                                case GHC.List.$wlenAcc
                                       @ (Int, Int)
                                       (legalKnightMoves
                                          (TypeDefs.Knight, colour_a3ZX, wild2_a5lQ, ds3_d52b)
                                          w1_slkU)
                                       0#
                                of ww2_al5S
                                { __DEFAULT ->
                                jump $wgo_slkS
                                  ys_a24y
                                  (GHC.Prim.plusFloat#
                                     ww_slkQ
                                     (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.1#))
                                };
                              Bishop ->
                                case GHC.List.$wlenAcc
                                       @ (Int, Int)
                                       (legalBishopMoves
                                          (TypeDefs.Bishop, colour_a3ZX, wild2_a5lQ, ds3_d52b)
                                          w1_slkU)
                                       0#
                                of ww2_al5S
                                { __DEFAULT ->
                                jump $wgo_slkS
                                  ys_a24y
                                  (GHC.Prim.plusFloat# ww_slkQ (GHC.Prim.int2Float# ww2_al5S))
                                };
                              Rook ->
                                case GHC.List.$wlenAcc
                                       @ (Int, Int)
                                       (legalRookMoves
                                          (TypeDefs.Rook, colour_a3ZX, wild2_a5lQ, ds3_d52b)
                                          w1_slkU)
                                       0#
                                of ww2_al5S
                                { __DEFAULT ->
                                jump $wgo_slkS
                                  ys_a24y
                                  (GHC.Prim.plusFloat# ww_slkQ (GHC.Prim.int2Float# ww2_al5S))
                                };
                              Queen -> jump $wgo_slkS ys_a24y ww_slkQ;
                              King -> jump $wgo_slkS ys_a24y ww_slkQ
                            } } in
                      case x_a5hr of {
                        __DEFAULT -> jump $j1_sl2x;
                        -1# ->
                          case a2_a5lS of { GHC.Types.I# x1_X5jM ->
                          case x1_X5jM of {
                            __DEFAULT -> jump $j1_sl2x;
                            -1# -> jump $wgo_slkS ys_a24y ww_slkQ
                          }
                          }
                      }
                      }
                      } } in
                case colour_a3ZX of {
                  Black ->
                    case w_slkT of {
                      Black -> jump $j_sl2A;
                      White ->
                        joinrec {
                          $wgo1_XlnO [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                            :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                          $wgo1_XlnO (w3_Xlmg :: [Piece]) (ww1_XlnQ :: GHC.Prim.Float#)
                            = case w3_Xlmg of {
                                [] -> ww1_XlnQ;
                                : y1_X265 ys1_X267 ->
                                  case y1_X265 of { (ds4_X53N, colour1_X41C, ds5_X53Q, ds6_X53S) ->
                                  case colour1_X41C of {
                                    Black -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ;
                                    White ->
                                      case ds5_X53Q of wild7_a5lQ { (a1_a5lR, a2_a5lS) ->
                                      case a1_a5lR of { GHC.Types.I# x_a5hr ->
                                      join {
                                        $j1_sl2x [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                        [LclId[JoinId(0)]]
                                        $j1_sl2x
                                          = case ds4_X53N of {
                                              Pawn ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalPawnMoves
                                                          (TypeDefs.Pawn, TypeDefs.White,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ
                                                     (GHC.Prim.timesFloat#
                                                        (GHC.Prim.int2Float# ww2_al5S) 1.5#))
                                                };
                                              Knight ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalKnightMoves
                                                          (TypeDefs.Knight, TypeDefs.White,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ
                                                     (GHC.Prim.timesFloat#
                                                        (GHC.Prim.int2Float# ww2_al5S) 1.1#))
                                                };
                                              Bishop ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalBishopMoves
                                                          (TypeDefs.Bishop, TypeDefs.White,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ (GHC.Prim.int2Float# ww2_al5S))
                                                };
                                              Rook ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalRookMoves
                                                          (TypeDefs.Rook, TypeDefs.White,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ (GHC.Prim.int2Float# ww2_al5S))
                                                };
                                              Queen -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ;
                                              King -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ
                                            } } in
                                      case x_a5hr of {
                                        __DEFAULT -> jump $j1_sl2x;
                                        -1# ->
                                          case a2_a5lS of { GHC.Types.I# x1_X5jM ->
                                          case x1_X5jM of {
                                            __DEFAULT -> jump $j1_sl2x;
                                            -1# -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ
                                          }
                                          }
                                      }
                                      }
                                      }
                                  }
                                  }
                              }; } in
                        jump $wgo1_XlnO ys_a24y ww_slkQ
                    };
                  White ->
                    case w_slkT of {
                      Black ->
                        joinrec {
                          $wgo1_XlnO [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                            :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                          $wgo1_XlnO (w3_Xlmg :: [Piece]) (ww1_XlnQ :: GHC.Prim.Float#)
                            = case w3_Xlmg of {
                                [] -> ww1_XlnQ;
                                : y1_X265 ys1_X267 ->
                                  case y1_X265 of { (ds4_X53N, colour1_X41C, ds5_X53Q, ds6_X53S) ->
                                  case colour1_X41C of {
                                    Black ->
                                      case ds5_X53Q of wild7_a5lQ { (a1_a5lR, a2_a5lS) ->
                                      case a1_a5lR of { GHC.Types.I# x_a5hr ->
                                      join {
                                        $j1_sl2x [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                        [LclId[JoinId(0)]]
                                        $j1_sl2x
                                          = case ds4_X53N of {
                                              Pawn ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalPawnMoves
                                                          (TypeDefs.Pawn, TypeDefs.Black,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ
                                                     (GHC.Prim.timesFloat#
                                                        (GHC.Prim.int2Float# ww2_al5S) 1.5#))
                                                };
                                              Knight ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalKnightMoves
                                                          (TypeDefs.Knight, TypeDefs.Black,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ
                                                     (GHC.Prim.timesFloat#
                                                        (GHC.Prim.int2Float# ww2_al5S) 1.1#))
                                                };
                                              Bishop ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalBishopMoves
                                                          (TypeDefs.Bishop, TypeDefs.Black,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ (GHC.Prim.int2Float# ww2_al5S))
                                                };
                                              Rook ->
                                                case GHC.List.$wlenAcc
                                                       @ (Int, Int)
                                                       (legalRookMoves
                                                          (TypeDefs.Rook, TypeDefs.Black,
                                                           wild7_a5lQ, ds6_X53S)
                                                          w1_slkU)
                                                       0#
                                                of ww2_al5S
                                                { __DEFAULT ->
                                                jump $wgo1_XlnO
                                                  ys1_X267
                                                  (GHC.Prim.plusFloat#
                                                     ww1_XlnQ (GHC.Prim.int2Float# ww2_al5S))
                                                };
                                              Queen -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ;
                                              King -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ
                                            } } in
                                      case x_a5hr of {
                                        __DEFAULT -> jump $j1_sl2x;
                                        -1# ->
                                          case a2_a5lS of { GHC.Types.I# x1_X5jM ->
                                          case x1_X5jM of {
                                            __DEFAULT -> jump $j1_sl2x;
                                            -1# -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ
                                          }
                                          }
                                      }
                                      }
                                      };
                                    White -> jump $wgo1_XlnO ys1_X267 ww1_XlnQ
                                  }
                                  }
                              }; } in
                        jump $wgo1_XlnO ys_a24y ww_slkQ;
                      White -> jump $j_sl2A
                    }
                }
                }
            }; } in
      jump $wgo_slkS w1_slkU 0.0#

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalMobility [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slkT [Occ=Once] :: Colour)
                 (w1_slkU [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wtotalMobility w_slkT w1_slkU
                 of ww_slkX [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_slkX
                 }}]
totalMobility
  = \ (w_slkT :: Colour) (w1_slkU :: AllPieces) ->
      case EvalOpening.$wtotalMobility w_slkT w1_slkU of ww_slkX
      { __DEFAULT ->
      GHC.Types.F# ww_slkX
      }

-- RHS size: {terms: 41, types: 8, coercions: 0, joins: 0/0}
EvalOpening.$wtotalOpeningVal [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 224 0}]
EvalOpening.$wtotalOpeningVal
  = \ (w_slkZ :: Colour) (w1_sll0 :: AllPieces) ->
      case EvalOpening.$wtotalMobility w_slkZ w1_sll0 of ww_slkX
      { __DEFAULT ->
      case EvalOpening.$wtotalMobility
             (case w_slkZ of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             w1_sll0
      of ww1_XlmO
      { __DEFAULT ->
      case EvalOpening.$wtotalMaterial w_slkZ w1_sll0 of ww2_slkv
      { __DEFAULT ->
      case EvalOpening.$wcastleMotive w_slkZ w1_sll0 of ww3_slk4
      { __DEFAULT ->
      case EvalOpening.$wstaticKingMotive w_slkZ w1_sll0 of ww4_sljI
      { __DEFAULT ->
      GHC.Prim.plusFloat#
        (GHC.Prim.plusFloat#
           (GHC.Prim.minusFloat# ww_slkX ww1_XlmO) ww2_slkv)
        (GHC.Prim.plusFloat# ww3_slk4 ww4_sljI)
      }
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalOpeningVal [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_slkZ [Occ=Once] :: Colour)
                 (w1_sll0 [Occ=Once] :: AllPieces) ->
                 case EvalOpening.$wtotalOpeningVal w_slkZ w1_sll0
                 of ww_sll3 [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_sll3
                 }}]
totalOpeningVal
  = \ (w_slkZ :: Colour) (w1_sll0 :: AllPieces) ->
      case EvalOpening.$wtotalOpeningVal w_slkZ w1_sll0 of ww_sll3
      { __DEFAULT ->
      GHC.Types.F# ww_sll3
      }



[ 7 of 14] Compiling EvalMiddle       ( EvalMiddle.hs, EvalMiddle.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 21, types: 11, coercions: 0, joins: 0/0}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.totalMiddleVal1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalMiddle.totalMiddleVal1 = GHC.Types.F# 100.0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
totalMiddleVal :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> EvalMiddle.totalMiddleVal1}]
totalMiddleVal
  = \ _ [Occ=Dead] _ [Occ=Dead] -> EvalMiddle.totalMiddleVal1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
EvalMiddle.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalMiddle.$trModule3 = GHC.Types.TrNameS EvalMiddle.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
EvalMiddle.$trModule2 = "EvalMiddle"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalMiddle.$trModule1 = GHC.Types.TrNameS EvalMiddle.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
EvalMiddle.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EvalMiddle.$trModule
  = GHC.Types.Module EvalMiddle.$trModule3 EvalMiddle.$trModule1



[ 8 of 14] Compiling EvalEnd          ( EvalEnd.hs, EvalEnd.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 2,141, types: 1,143, coercions: 0, joins: 45/52}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.pieceVal5 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.pieceVal5 = GHC.Types.F# 2.5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.pieceVal4 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.pieceVal4 = GHC.Types.F# 3.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.pieceVal3 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.pieceVal3 = GHC.Types.F# 3.5#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.passPawnScore1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.passPawnScore1 = GHC.Types.F# 5.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.pieceVal2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.pieceVal2 = GHC.Types.F# 9.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.pieceVal1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.pieceVal1 = GHC.Types.F# 1.0#

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
pieceVal :: Piece -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),1*U(1*U,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dmVS [Occ=Once!]
                    :: (PieceType, Colour, Pos, Movecount)) ->
                 case ds_dmVS of
                 { (ds1_dmXb [Occ=Once!], _ [Occ=Dead], _ [Occ=Dead],
                    _ [Occ=Dead]) ->
                 case ds1_dmXb of {
                   Pawn -> EvalEnd.pieceVal5;
                   Knight -> EvalEnd.pieceVal4;
                   Bishop -> EvalEnd.pieceVal3;
                   Rook -> EvalEnd.passPawnScore1;
                   Queen -> EvalEnd.pieceVal2;
                   King -> EvalEnd.pieceVal1
                 }
                 }}]
pieceVal
  = \ (ds_dmVS :: (PieceType, Colour, Pos, Movecount)) ->
      case ds_dmVS of { (ds1_dmXb, ds2_dmXc, ds3_dmXd, ds4_dmXe) ->
      case ds1_dmXb of {
        Pawn -> EvalEnd.pieceVal5;
        Knight -> EvalEnd.pieceVal4;
        Bishop -> EvalEnd.pieceVal3;
        Rook -> EvalEnd.passPawnScore1;
        Queen -> EvalEnd.pieceVal2;
        King -> EvalEnd.pieceVal1
      }
      }

-- RHS size: {terms: 51, types: 32, coercions: 0, joins: 0/0}
EvalEnd.$wisPieceAimedAtEnemyKing [InlPrag=NOUSERINLINE[2]]
  :: PieceType -> Colour -> Pos -> Movecount -> AllPieces -> Bool
[GblId,
 Arity=5,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 20 0 0] 232 0}]
EvalEnd.$wisPieceAimedAtEnemyKing
  = \ (ww_snEA :: PieceType)
      (ww1_snEB :: Colour)
      (ww2_snEC :: Pos)
      (ww3_snED :: Movecount)
      (w_snEx :: AllPieces) ->
      Util.$wisValidMove
        ww_snEA
        ww1_snEB
        ww2_snEC
        ww3_snED
        (case ww2_snEC of { (a_a403, b_a404) ->
         case findKing
                (case ww1_snEB of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 })
                w_snEx
         of
         { (c_a405, d_a406) ->
         (case c_a405 of { GHC.Types.I# x_a5lB ->
          case a_a403 of { GHC.Types.I# y_a5lE ->
          GHC.Types.I# (GHC.Prim.-# x_a5lB y_a5lE)
          }
          },
          case d_a406 of { GHC.Types.I# x_a5lB ->
          case b_a404 of { GHC.Types.I# y_a5lE ->
          GHC.Types.I# (GHC.Prim.-# x_a5lB y_a5lE)
          }
          })
         }
         })
        (GHC.Types.:
           @ Piece
           (ww_snEA, ww1_snEB, ww2_snEC, ww3_snED)
           (GHC.Types.[] @ Piece))

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
isPieceAimedAtEnemyKing [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snEw [Occ=Once!] :: Piece)
                 (w1_snEx [Occ=Once] :: AllPieces) ->
                 case w_snEw of
                 { (ww1_snEA [Occ=Once], ww2_snEB [Occ=Once], ww3_snEC [Occ=Once],
                    ww4_snED [Occ=Once]) ->
                 EvalEnd.$wisPieceAimedAtEnemyKing
                   ww1_snEA ww2_snEB ww3_snEC ww4_snED w1_snEx
                 }}]
isPieceAimedAtEnemyKing
  = \ (w_snEw :: Piece) (w1_snEx :: AllPieces) ->
      case w_snEw of { (ww1_snEA, ww2_snEB, ww3_snEC, ww4_snED) ->
      EvalEnd.$wisPieceAimedAtEnemyKing
        ww1_snEA ww2_snEB ww3_snEC ww4_snED w1_snEx
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.isKingSideCol2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.isKingSideCol2 = GHC.Types.F# 0.0#

-- RHS size: {terms: 16, types: 8, coercions: 0, joins: 0/0}
threatenKingBonus :: Piece -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><L,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_amLC [Occ=Once] :: Piece)
                 (ps_amLD [Occ=Once] :: AllPieces) ->
                 case isPieceAimedAtEnemyKing p_amLC ps_amLD of {
                   False -> EvalEnd.isKingSideCol2;
                   True -> EvalEnd.pieceVal5
                 }}]
threatenKingBonus
  = \ (p_amLC :: Piece) (ps_amLD :: AllPieces) ->
      case p_amLC of { (ww1_snEA, ww2_snEB, ww3_snEC, ww4_snED) ->
      case EvalEnd.$wisPieceAimedAtEnemyKing
             ww1_snEA ww2_snEB ww3_snEC ww4_snED ps_amLD
      of {
        False -> EvalEnd.isKingSideCol2;
        True -> EvalEnd.pieceVal5
      }
      }

-- RHS size: {terms: 39, types: 30, coercions: 0, joins: 0/0}
EvalEnd.$wisOpposingKingInCheck [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 240 0}]
EvalEnd.$wisOpposingKingInCheck
  = \ (w_snEG :: Colour) (w1_snEH :: AllPieces) ->
      case findPiece
             (findKing
                (case w_snEG of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 })
                w1_snEH)
             w1_snEH
      of {
        [] -> case GHC.List.badHead of wild1_00 { };
        : x_a4SP ds1_a4SQ ->
          case x_a4SP of ww_s8sP
          { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
          case Util.clearCastlePath_$sthreatenedBy
                 (GHC.Types.:
                    @ (PieceType, Colour, Pos, Movecount)
                    (TypeDefs.Pawn, ww2_s8sR, ww3_s8sS, ww4_s8sT)
                    (removePiece ww_s8sP w1_snEH))
                 TypeDefs.Pawn
                 ww2_s8sR
                 ww3_s8sS
                 ww4_s8sT
          of {
            [] -> 0.0#;
            : ds2_a5jz ds3_a5jA -> 3.0#
          }
          }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
isOpposingKingInCheck [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,1*U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snEG [Occ=Once] :: Colour)
                 (w1_snEH [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wisOpposingKingInCheck w_snEG w1_snEH
                 of ww_snEK [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snEK
                 }}]
isOpposingKingInCheck
  = \ (w_snEG :: Colour) (w1_snEH :: AllPieces) ->
      case EvalEnd.$wisOpposingKingInCheck w_snEG w1_snEH of ww_snEK
      { __DEFAULT ->
      GHC.Types.F# ww_snEK
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalEnd.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
EvalEnd.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.$trModule3 = GHC.Types.TrNameS EvalEnd.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EvalEnd.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
EvalEnd.$trModule2 = "EvalEnd"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.$trModule1 = GHC.Types.TrNameS EvalEnd.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
EvalEnd.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EvalEnd.$trModule
  = GHC.Types.Module EvalEnd.$trModule3 EvalEnd.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EvalEnd.isKingSideCol1 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EvalEnd.isKingSideCol1 = GHC.Types.F# 1.5#

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
isKingSideRow :: Pos -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(1*U),A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_amLI [Occ=Once!] :: Pos) ->
                 case p_amLI of { (row_a3ZW [Occ=Once!], _ [Occ=Dead]) ->
                 case row_a3ZW of { GHC.Types.I# x_a5hr [Occ=Once!] ->
                 case x_a5hr of {
                   __DEFAULT -> EvalEnd.isKingSideCol2;
                   0# -> EvalEnd.isKingSideCol1;
                   7# -> EvalEnd.isKingSideCol1
                 }
                 }
                 }}]
isKingSideRow
  = \ (p_amLI :: Pos) ->
      case p_amLI of { (row_a3ZW, ds1_d52J) ->
      case row_a3ZW of { GHC.Types.I# x_a5hr ->
      case x_a5hr of {
        __DEFAULT -> EvalEnd.isKingSideCol2;
        0# -> EvalEnd.isKingSideCol1;
        7# -> EvalEnd.isKingSideCol1
      }
      }
      }

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
isKingSideCol :: Pos -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS(S)),1*U(A,1*U(1*U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_amLH [Occ=Once!] :: Pos) ->
                 case p_amLH of { (_ [Occ=Dead], col_a3ZV [Occ=Once!]) ->
                 case col_a3ZV of { GHC.Types.I# x_a5hr [Occ=Once!] ->
                 case x_a5hr of {
                   __DEFAULT -> EvalEnd.isKingSideCol2;
                   0# -> EvalEnd.isKingSideCol1;
                   7# -> EvalEnd.isKingSideCol1
                 }
                 }
                 }}]
isKingSideCol
  = \ (p_amLH :: Pos) ->
      case p_amLH of { (ds1_d52T, col_a3ZV) ->
      case col_a3ZV of { GHC.Types.I# x_a5hr ->
      case x_a5hr of {
        __DEFAULT -> EvalEnd.isKingSideCol2;
        0# -> EvalEnd.isKingSideCol1;
        7# -> EvalEnd.isKingSideCol1
      }
      }
      }

-- RHS size: {terms: 53, types: 20, coercions: 0, joins: 0/0}
EvalEnd.$wisKingOnEdges [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 220 0}]
EvalEnd.$wisKingOnEdges
  = \ (w_snEM :: Colour) (w1_snEN :: AllPieces) ->
      case findKing
             (case w_snEM of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             w1_snEN
      of
      { (ds1_d52T, col_a3ZV) ->
      case col_a3ZV of { GHC.Types.I# x_a5hr ->
      case x_a5hr of {
        __DEFAULT ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT -> 0.0#;
            0# -> 1.5#;
            7# -> 1.5#
          }
          };
        0# ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT -> 1.5#;
            0# -> 3.0#;
            7# -> 3.0#
          }
          };
        7# ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT -> 1.5#;
            0# -> 3.0#;
            7# -> 3.0#
          }
          }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
isKingOnEdges [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snEM [Occ=Once] :: Colour)
                 (w1_snEN [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wisKingOnEdges w_snEM w1_snEN of ww_snEQ [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snEQ
                 }}]
isKingOnEdges
  = \ (w_snEM :: Colour) (w1_snEN :: AllPieces) ->
      case EvalEnd.$wisKingOnEdges w_snEM w1_snEN of ww_snEQ
      { __DEFAULT ->
      GHC.Types.F# ww_snEQ
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
totalColourBonus :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= isKingOnEdges}]
totalColourBonus = isKingOnEdges

-- RHS size: {terms: 193, types: 110, coercions: 0, joins: 7/7}
EvalEnd.$wperPieceBonus [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [64 0] 743 0}]
EvalEnd.$wperPieceBonus
  = \ (w_snEZ :: Colour) (w1_snF0 :: AllPieces) ->
      joinrec {
        $wgo_snEY [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
          :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        $wgo_snEY (w2_snES :: [Piece]) (ww_snEW :: GHC.Prim.Float#)
          = case w2_snES of {
              [] -> ww_snEW;
              : y_a24x ys_a24y ->
                case y_a24x of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                case pos_a3ZY of wild2_a5lQ { (a1_a5lR, a2_a5lS) ->
                case a1_a5lR of { GHC.Types.I# x_a5hr ->
                join {
                  $j_sn79 [Dmd=<L,1*U>] :: GHC.Prim.Float#
                  [LclId[JoinId(0)]]
                  $j_sn79
                    = join {
                        $j1_sn75 [Dmd=<L,1*U>] :: GHC.Prim.Float#
                        [LclId[JoinId(0)]]
                        $j1_sn75
                          = case EvalEnd.$wisPieceAimedAtEnemyKing
                                   ds1_d4Xh ds2_d4Xi wild2_a5lQ ds3_d4Xj w1_snF0
                            of {
                              False -> jump $wgo_snEY ys_a24y ww_snEW;
                              True -> jump $wgo_snEY ys_a24y (GHC.Prim.plusFloat# ww_snEW 2.5#)
                            } } in
                      case ds2_d4Xi of {
                        Black ->
                          case w_snEZ of {
                            Black -> jump $j1_sn75;
                            White ->
                              joinrec {
                                $wgo1_XnIE [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnIE (w3_XnGJ :: [Piece]) (ww1_XnIG :: GHC.Prim.Float#)
                                  = case w3_XnGJ of {
                                      [] -> ww1_XnIG;
                                      : y1_X26s ys1_X26u ->
                                        case y1_X26s of
                                        { (ds4_X4Zi, ds5_X4Zk, pos1_X421, ds6_X4Zn) ->
                                        case pos1_X421 of wild8_X5nX { (a4_X5o0, a5_X5o2) ->
                                        case a4_X5o0 of { GHC.Types.I# x1_X5jG ->
                                        join {
                                          $j2_Xn9r [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xn9r
                                            = case ds5_X4Zk of {
                                                Black -> jump $wgo1_XnIE ys1_X26u ww1_XnIG;
                                                White ->
                                                  case EvalEnd.$wisPieceAimedAtEnemyKing
                                                         ds4_X4Zi
                                                         TypeDefs.White
                                                         wild8_X5nX
                                                         ds6_X4Zn
                                                         w1_snF0
                                                  of {
                                                    False -> jump $wgo1_XnIE ys1_X26u ww1_XnIG;
                                                    True ->
                                                      jump $wgo1_XnIE
                                                        ys1_X26u (GHC.Prim.plusFloat# ww1_XnIG 2.5#)
                                                  }
                                              } } in
                                        case x1_X5jG of {
                                          __DEFAULT -> jump $j2_Xn9r;
                                          -1# ->
                                            case a5_X5o2 of { GHC.Types.I# x2_X5js ->
                                            case x2_X5js of {
                                              __DEFAULT -> jump $j2_Xn9r;
                                              -1# -> jump $wgo1_XnIE ys1_X26u ww1_XnIG
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnIE ys_a24y ww_snEW
                          };
                        White ->
                          case w_snEZ of {
                            Black ->
                              joinrec {
                                $wgo1_XnIE [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnIE (w3_XnGJ :: [Piece]) (ww1_XnIG :: GHC.Prim.Float#)
                                  = case w3_XnGJ of {
                                      [] -> ww1_XnIG;
                                      : y1_X26s ys1_X26u ->
                                        case y1_X26s of
                                        { (ds4_X4Zi, ds5_X4Zk, pos1_X421, ds6_X4Zn) ->
                                        case pos1_X421 of wild8_X5nX { (a4_X5o0, a5_X5o2) ->
                                        case a4_X5o0 of { GHC.Types.I# x1_X5jG ->
                                        join {
                                          $j2_Xn9r [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xn9r
                                            = case ds5_X4Zk of {
                                                Black ->
                                                  case EvalEnd.$wisPieceAimedAtEnemyKing
                                                         ds4_X4Zi
                                                         TypeDefs.Black
                                                         wild8_X5nX
                                                         ds6_X4Zn
                                                         w1_snF0
                                                  of {
                                                    False -> jump $wgo1_XnIE ys1_X26u ww1_XnIG;
                                                    True ->
                                                      jump $wgo1_XnIE
                                                        ys1_X26u (GHC.Prim.plusFloat# ww1_XnIG 2.5#)
                                                  };
                                                White -> jump $wgo1_XnIE ys1_X26u ww1_XnIG
                                              } } in
                                        case x1_X5jG of {
                                          __DEFAULT -> jump $j2_Xn9r;
                                          -1# ->
                                            case a5_X5o2 of { GHC.Types.I# x2_X5js ->
                                            case x2_X5js of {
                                              __DEFAULT -> jump $j2_Xn9r;
                                              -1# -> jump $wgo1_XnIE ys1_X26u ww1_XnIG
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnIE ys_a24y ww_snEW;
                            White -> jump $j1_sn75
                          }
                      } } in
                case x_a5hr of {
                  __DEFAULT -> jump $j_sn79;
                  -1# ->
                    case a2_a5lS of { GHC.Types.I# x1_X5js ->
                    case x1_X5js of {
                      __DEFAULT -> jump $j_sn79;
                      -1# -> jump $wgo_snEY ys_a24y ww_snEW
                    }
                    }
                }
                }
                }
                }
            }; } in
      jump $wgo_snEY w1_snF0 0.0#

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
perPieceBonus [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snEZ [Occ=Once] :: Colour)
                 (w1_snF0 [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wperPieceBonus w_snEZ w1_snF0 of ww_snF3 [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snF3
                 }}]
perPieceBonus
  = \ (w_snEZ :: Colour) (w1_snF0 :: AllPieces) ->
      case EvalEnd.$wperPieceBonus w_snEZ w1_snF0 of ww_snF3
      { __DEFAULT ->
      GHC.Types.F# ww_snF3
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rmLe :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rmLe = GHC.Types.F# 10.0#

-- RHS size: {terms: 250, types: 193, coercions: 0, joins: 13/14}
getLowestVal :: [Piece] -> Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []]
getLowestVal
  = \ (ps_amLk :: [Piece]) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [Float]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ Float;
                : y_a24x ys_a24y ->
                  join {
                    exit_X10 :: [Float]
                    [LclId[JoinId(0)]]
                    exit_X10
                      = GHC.Types.: @ Float (pieceVal y_a24x) (go_a24t ys_a24y) } in
                  join {
                    exit1_X1g :: [Float]
                    [LclId[JoinId(0)]]
                    exit1_X1g = go_a24t ys_a24y } in
                  join {
                    exit2_X1h :: [Float]
                    [LclId[JoinId(0)]]
                    exit2_X1h = go_a24t ys_a24y } in
                  join {
                    exit3_X1i :: [Float]
                    [LclId[JoinId(0)]]
                    exit3_X1i = go_a24t ys_a24y } in
                  join {
                    exit4_X1j :: [Float]
                    [LclId[JoinId(0)]]
                    exit4_X1j = go_a24t ys_a24y } in
                  join {
                    exit5_X1k :: [Float]
                    [LclId[JoinId(0)]]
                    exit5_X1k = go_a24t ys_a24y } in
                  case ps_amLk of {
                    [] -> jump exit_X10;
                    : y1_X267 ys1_X269 ->
                      case y1_X267 of { (ds1_dmXb, ds2_dmXc, ds3_dmXd, ds4_dmXe) ->
                      join {
                        $j_sn7k [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Float# -> [Float]
                        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                        $j_sn7k (x_akT9 [OS=OneShot] :: GHC.Prim.Float#)
                          = case y_a24x of { (ds5_XmZl, ds6_XmZn, ds7_XmZp, ds8_XmZr) ->
                            case ds5_XmZl of {
                              Pawn ->
                                case GHC.Prim.geFloat# x_akT9 2.5# of {
                                  __DEFAULT -> jump exit1_X1g;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of {
                                                __DEFAULT -> jump go1_X25Z ys2_X28k;
                                                King -> jump exit1_X1g
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                };
                              Knight ->
                                case GHC.Prim.geFloat# x_akT9 3.0# of {
                                  __DEFAULT -> jump exit2_X1h;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of {
                                                __DEFAULT -> jump exit2_X1h;
                                                Knight -> jump go1_X25Z ys2_X28k;
                                                Bishop -> jump go1_X25Z ys2_X28k;
                                                Rook -> jump go1_X25Z ys2_X28k;
                                                Queen -> jump go1_X25Z ys2_X28k
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                };
                              Bishop ->
                                case GHC.Prim.geFloat# x_akT9 3.5# of {
                                  __DEFAULT -> jump exit3_X1i;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of {
                                                __DEFAULT -> jump exit3_X1i;
                                                Bishop -> jump go1_X25Z ys2_X28k;
                                                Rook -> jump go1_X25Z ys2_X28k;
                                                Queen -> jump go1_X25Z ys2_X28k
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                };
                              Rook ->
                                case GHC.Prim.geFloat# x_akT9 5.0# of {
                                  __DEFAULT -> jump exit4_X1j;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of {
                                                __DEFAULT -> jump exit4_X1j;
                                                Rook -> jump go1_X25Z ys2_X28k;
                                                Queen -> jump go1_X25Z ys2_X28k
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                };
                              Queen ->
                                case GHC.Prim.geFloat# x_akT9 9.0# of {
                                  __DEFAULT -> jump exit5_X1k;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of {
                                                __DEFAULT -> jump exit5_X1k;
                                                Queen -> jump go1_X25Z ys2_X28k
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                };
                              King ->
                                case GHC.Prim.geFloat# x_akT9 1.0# of {
                                  __DEFAULT -> go_a24t ys_a24y;
                                  1# ->
                                    joinrec {
                                      go1_X25Z [Occ=LoopBreaker] :: [Piece] -> [Float]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X25Z (ds9_X261 :: [Piece])
                                        = case ds9_X261 of {
                                            [] -> jump exit_X10;
                                            : y2_X28h ys2_X28k ->
                                              case y2_X28h of
                                              { (ds10_Xn1H, ds11_XmZt, ds12_XmZv, ds13_XmZx) ->
                                              case ds10_Xn1H of { __DEFAULT ->
                                              jump go1_X25Z ys2_X28k
                                              }
                                              }
                                          }; } in
                                    jump go1_X25Z ys1_X269
                                }
                            }
                            } } in
                      case ds1_dmXb of {
                        Pawn -> jump $j_sn7k 2.5#;
                        Knight -> jump $j_sn7k 3.0#;
                        Bishop -> jump $j_sn7k 3.5#;
                        Rook -> jump $j_sn7k 5.0#;
                        Queen -> jump $j_sn7k 9.0#;
                        King -> jump $j_sn7k 1.0#
                      }
                      }
                  }
              }; } in
      case go_a24t ps_amLk of {
        [] -> lvl_rmLe;
        : ds1_a5jz ds2_a5jA -> ds1_a5jz
      }

-- RHS size: {terms: 132, types: 39, coercions: 0, joins: 1/1}
EvalEnd.$wpieceMaterial [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour -> Pos -> Movecount -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=5,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [300 60 0 0 0] 696 0}]
EvalEnd.$wpieceMaterial
  = \ (ww_snFe :: PieceType)
      (ww1_snFf :: Colour)
      (ww2_snFg :: Pos)
      (ww3_snFh :: Movecount)
      (w_snFb :: AllPieces) ->
      case GHC.List.$wlenAcc
             @ (PieceType, Colour, Pos, Movecount)
             (Util.clearCastlePath_$sthreatenedBy
                w_snFb ww_snFe ww1_snFf ww2_snFg ww3_snFh)
             0#
      of ww4_al5S
      { __DEFAULT ->
      case GHC.List.$wlenAcc
             @ (PieceType, Colour, Pos, Movecount)
             (Util.clearCastlePath_$sthreatenedBy
                (GHC.Types.:
                   @ Piece
                   (ww_snFe,
                    case ww1_snFf of {
                      Black -> TypeDefs.White;
                      White -> TypeDefs.Black
                    },
                    ww2_snFg, ww3_snFh)
                   (removePiece (ww_snFe, ww1_snFf, ww2_snFg, ww3_snFh) w_snFb))
                ww_snFe
                (case ww1_snFf of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 })
                ww2_snFg
                ww3_snFh)
             0#
      of ww5_Xl7F
      { __DEFAULT ->
      case GHC.Prim.># ww4_al5S ww5_Xl7F of {
        __DEFAULT ->
          case getLowestVal
                 (Util.clearCastlePath_$sthreatenedBy
                    w_snFb ww_snFe ww1_snFf ww2_snFg ww3_snFh)
          of
          { GHC.Types.F# x_akTs ->
          join {
            $j_sn7v [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
            [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
            $j_sn7v (y_akTv [OS=OneShot] :: GHC.Prim.Float#)
              = case GHC.Prim.ltFloat# x_akTs y_akTv of {
                  __DEFAULT ->
                    case ww_snFe of {
                      Pawn -> 2.5#;
                      Knight -> 3.0#;
                      Bishop -> 3.5#;
                      Rook -> 5.0#;
                      Queen -> 9.0#;
                      King -> 1.0#
                    };
                  1# ->
                    case ww_snFe of {
                      Pawn -> -2.5#;
                      Knight -> -3.0#;
                      Bishop -> -3.5#;
                      Rook -> -5.0#;
                      Queen -> -9.0#;
                      King -> -1.0#
                    }
                } } in
          case ww_snFe of {
            Pawn -> jump $j_sn7v 2.5#;
            Knight -> jump $j_sn7v 3.0#;
            Bishop -> jump $j_sn7v 3.5#;
            Rook -> jump $j_sn7v 5.0#;
            Queen -> jump $j_sn7v 9.0#;
            King -> jump $j_sn7v 1.0#
          }
          };
        1# ->
          case ww_snFe of {
            Pawn -> -2.5#;
            Knight -> -3.0#;
            Bishop -> -3.5#;
            Rook -> -5.0#;
            Queen -> -9.0#;
            King -> -1.0#
          }
      }
      }
      }

-- RHS size: {terms: 15, types: 8, coercions: 0, joins: 0/0}
pieceMaterial [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snFa [Occ=Once!] :: Piece)
                 (w1_snFb [Occ=Once] :: AllPieces) ->
                 case w_snFa of
                 { (ww1_snFe [Occ=Once], ww2_snFf [Occ=Once], ww3_snFg [Occ=Once],
                    ww4_snFh [Occ=Once]) ->
                 case EvalEnd.$wpieceMaterial
                        ww1_snFe ww2_snFf ww3_snFg ww4_snFh w1_snFb
                 of ww5_snFl [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww5_snFl
                 }
                 }}]
pieceMaterial
  = \ (w_snFa :: Piece) (w1_snFb :: AllPieces) ->
      case w_snFa of { (ww1_snFe, ww2_snFf, ww3_snFg, ww4_snFh) ->
      case EvalEnd.$wpieceMaterial
             ww1_snFe ww2_snFf ww3_snFg ww4_snFh w1_snFb
      of ww5_snFl
      { __DEFAULT ->
      GHC.Types.F# ww5_snFl
      }
      }

-- RHS size: {terms: 187, types: 110, coercions: 0, joins: 7/7}
EvalEnd.$wtotalMaterial [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [64 0] 698 0}]
EvalEnd.$wtotalMaterial
  = \ (w_snFu :: Colour) (w1_snFv :: AllPieces) ->
      joinrec {
        $wgo_snFt [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
          :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        $wgo_snFt (w2_snFn :: [Piece]) (ww_snFr :: GHC.Prim.Float#)
          = case w2_snFn of {
              [] -> GHC.Prim.plusFloat# ww_snFr ww_snFr;
              : y_a24x ys_a24y ->
                case y_a24x of { (ds1_d4Xh, ds2_d4Xi, pos_a3ZY, ds3_d4Xj) ->
                case pos_a3ZY of wild2_a5lQ { (a1_a5lR, a2_a5lS) ->
                case a1_a5lR of { GHC.Types.I# x_a5hr ->
                join {
                  $j_sn7H [Dmd=<L,1*U>] :: GHC.Prim.Float#
                  [LclId[JoinId(0)]]
                  $j_sn7H
                    = join {
                        $j1_sn7D [Dmd=<L,1*U>] :: GHC.Prim.Float#
                        [LclId[JoinId(0)]]
                        $j1_sn7D
                          = case EvalEnd.$wpieceMaterial
                                   ds1_d4Xh ds2_d4Xi wild2_a5lQ ds3_d4Xj w1_snFv
                            of ww1_snFl
                            { __DEFAULT ->
                            jump $wgo_snFt ys_a24y (GHC.Prim.plusFloat# ww_snFr ww1_snFl)
                            } } in
                      case ds2_d4Xi of {
                        Black ->
                          case w_snFu of {
                            Black -> jump $j1_sn7D;
                            White ->
                              joinrec {
                                $wgo1_XnJl [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnJl (w3_XnHk :: [Piece]) (ww1_XnJn :: GHC.Prim.Float#)
                                  = case w3_XnHk of {
                                      [] -> GHC.Prim.plusFloat# ww1_XnJn ww1_XnJn;
                                      : y1_X26y ys1_X26A ->
                                        case y1_X26y of
                                        { (ds4_X4Zo, ds5_X4Zq, pos1_X427, ds6_X4Zt) ->
                                        case pos1_X427 of wild8_X5o3 { (a4_X5o6, a5_X5o8) ->
                                        case a4_X5o6 of { GHC.Types.I# x1_X5jM ->
                                        join {
                                          $j2_Xna5 [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xna5
                                            = case ds5_X4Zq of {
                                                Black -> jump $wgo1_XnJl ys1_X26A ww1_XnJn;
                                                White ->
                                                  case EvalEnd.$wpieceMaterial
                                                         ds4_X4Zo
                                                         TypeDefs.White
                                                         wild8_X5o3
                                                         ds6_X4Zt
                                                         w1_snFv
                                                  of ww2_snFl
                                                  { __DEFAULT ->
                                                  jump $wgo1_XnJl
                                                    ys1_X26A (GHC.Prim.plusFloat# ww1_XnJn ww2_snFl)
                                                  }
                                              } } in
                                        case x1_X5jM of {
                                          __DEFAULT -> jump $j2_Xna5;
                                          -1# ->
                                            case a5_X5o8 of { GHC.Types.I# x2_X5jB ->
                                            case x2_X5jB of {
                                              __DEFAULT -> jump $j2_Xna5;
                                              -1# -> jump $wgo1_XnJl ys1_X26A ww1_XnJn
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnJl ys_a24y ww_snFr
                          };
                        White ->
                          case w_snFu of {
                            Black ->
                              joinrec {
                                $wgo1_XnJl [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnJl (w3_XnHk :: [Piece]) (ww1_XnJn :: GHC.Prim.Float#)
                                  = case w3_XnHk of {
                                      [] -> GHC.Prim.plusFloat# ww1_XnJn ww1_XnJn;
                                      : y1_X26y ys1_X26A ->
                                        case y1_X26y of
                                        { (ds4_X4Zo, ds5_X4Zq, pos1_X427, ds6_X4Zt) ->
                                        case pos1_X427 of wild8_X5o3 { (a4_X5o6, a5_X5o8) ->
                                        case a4_X5o6 of { GHC.Types.I# x1_X5jM ->
                                        join {
                                          $j2_Xna5 [Dmd=<L,1*U>] :: GHC.Prim.Float#
                                          [LclId[JoinId(0)]]
                                          $j2_Xna5
                                            = case ds5_X4Zq of {
                                                Black ->
                                                  case EvalEnd.$wpieceMaterial
                                                         ds4_X4Zo
                                                         TypeDefs.Black
                                                         wild8_X5o3
                                                         ds6_X4Zt
                                                         w1_snFv
                                                  of ww2_snFl
                                                  { __DEFAULT ->
                                                  jump $wgo1_XnJl
                                                    ys1_X26A (GHC.Prim.plusFloat# ww1_XnJn ww2_snFl)
                                                  };
                                                White -> jump $wgo1_XnJl ys1_X26A ww1_XnJn
                                              } } in
                                        case x1_X5jM of {
                                          __DEFAULT -> jump $j2_Xna5;
                                          -1# ->
                                            case a5_X5o8 of { GHC.Types.I# x2_X5jB ->
                                            case x2_X5jB of {
                                              __DEFAULT -> jump $j2_Xna5;
                                              -1# -> jump $wgo1_XnJl ys1_X26A ww1_XnJn
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnJl ys_a24y ww_snFr;
                            White -> jump $j1_sn7D
                          }
                      } } in
                case x_a5hr of {
                  __DEFAULT -> jump $j_sn7H;
                  -1# ->
                    case a2_a5lS of { GHC.Types.I# x1_X5jB ->
                    case x1_X5jB of {
                      __DEFAULT -> jump $j_sn7H;
                      -1# -> jump $wgo_snFt ys_a24y ww_snFr
                    }
                    }
                }
                }
                }
                }
            }; } in
      jump $wgo_snFt w1_snFv 0.0#

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalMaterial [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snFu [Occ=Once] :: Colour)
                 (w1_snFv [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wtotalMaterial w_snFu w1_snFv of ww_snFy [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snFy
                 }}]
totalMaterial
  = \ (w_snFu :: Colour) (w1_snFv :: AllPieces) ->
      case EvalEnd.$wtotalMaterial w_snFu w1_snFv of ww_snFy
      { __DEFAULT ->
      GHC.Types.F# ww_snFy
      }

-- RHS size: {terms: 37, types: 27, coercions: 0, joins: 0/0}
EvalEnd.$wisNotEnemyPawn [InlPrag=NOUSERINLINE[2]]
  :: Pos -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 210 70}]
EvalEnd.$wisNotEnemyPawn
  = \ (w_snFB :: Pos) (w1_snFC :: AllPieces) ->
      case GHC.Classes.$fEq[]_$c==
             @ (PieceType, Colour, Pos, Movecount)
             Util.$s$fEq(,,,)
             (findPiece w_snFB w1_snFC)
             (GHC.Types.[] @ Piece)
      of {
        False ->
          case findPiece w_snFB w1_snFC of {
            [] -> case GHC.List.badHead of wild2_00 { };
            : x_a4SP ds1_a4SQ ->
              case x_a4SP of { (x1_a3ZZ, ds2_d4WW, ds3_d4WX, ds4_d4WY) ->
              case x1_a3ZZ of {
                Pawn -> GHC.Types.False;
                Knight -> GHC.Types.True;
                Bishop -> GHC.Types.True;
                Rook -> GHC.Types.True;
                Queen -> GHC.Types.True;
                King -> GHC.Types.True
              }
              }
          };
        True -> GHC.Types.True
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
isNotEnemyPawn [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,A><L,U(U(U),U(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_snFB [Occ=Once] :: Pos)
                 (w2_snFC [Occ=Once] :: AllPieces) ->
                 EvalEnd.$wisNotEnemyPawn w1_snFB w2_snFC}]
isNotEnemyPawn
  = \ _ [Occ=Dead] (w1_snFB :: Pos) (w2_snFC :: AllPieces) ->
      EvalEnd.$wisNotEnemyPawn w1_snFB w2_snFC

-- RHS size: {terms: 48, types: 17, coercions: 0, joins: 1/2}
EvalEnd.$wpawnClearAhead [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Int -> Int -> AllPieces -> Bool
[GblId,
 Arity=4,
 Str=<L,1*U><L,1*U(U)><L,U(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [41 20 20 0] 172 0}]
EvalEnd.$wpawnClearAhead
  = \ (w_snFF :: Colour)
      (ww_snFK :: Int)
      (ww1_snFL :: Int)
      (w1_snFH :: AllPieces) ->
      let {
        lvl1_sn6m [Dmd=<L,U(U)>] :: Int
        [LclId]
        lvl1_sn6m
          = case ww_snFK of { GHC.Types.I# x_a5kQ ->
            case w_snFF of {
              Black -> GHC.Types.I# (GHC.Prim.+# x_a5kQ 1#);
              White -> GHC.Types.I# (GHC.Prim.+# x_a5kQ -1#)
            }
            } } in
      joinrec {
        go_a3xy [Occ=LoopBreaker] :: GHC.Prim.Int# -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_a3xy (x_a3xz :: GHC.Prim.Int#)
          = case EvalEnd.$wisNotEnemyPawn
                   (lvl1_sn6m,
                    case ww1_snFL of { GHC.Types.I# x1_a5kQ ->
                    GHC.Types.I# (GHC.Prim.+# x1_a5kQ x_a3xz)
                    })
                   w1_snFH
            of {
              False -> GHC.Types.False;
              True ->
                case x_a3xz of wild1_X1H {
                  __DEFAULT -> jump go_a3xy (GHC.Prim.+# wild1_X1H 1#);
                  1# -> GHC.Types.True
                }
            }; } in
      jump go_a3xy -1#

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
pawnClearAhead [InlPrag=NOUSERINLINE[2]]
  :: Colour -> Pos -> AllPieces -> Bool
[GblId,
 Arity=3,
 Str=<L,1*U><S,1*U(1*U(U),U(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snFF [Occ=Once] :: Colour)
                 (w1_snFG [Occ=Once!] :: Pos)
                 (w2_snFH [Occ=Once] :: AllPieces) ->
                 case w1_snFG of { (ww1_snFK [Occ=Once], ww2_snFL [Occ=Once]) ->
                 EvalEnd.$wpawnClearAhead w_snFF ww1_snFK ww2_snFL w2_snFH
                 }}]
pawnClearAhead
  = \ (w_snFF :: Colour) (w1_snFG :: Pos) (w2_snFH :: AllPieces) ->
      case w1_snFG of { (ww1_snFK, ww2_snFL) ->
      EvalEnd.$wpawnClearAhead w_snFF ww1_snFK ww2_snFL w2_snFH
      }

-- RHS size: {terms: 176, types: 40, coercions: 0, joins: 6/11}
EvalEnd.$wisPassedPawn [InlPrag=NOUSERINLINE[2]]
  :: Colour -> GHC.Prim.Int# -> Int -> AllPieces -> Bool
[GblId, Arity=4, Str=<S,U><L,U><L,U(U)><L,U>, Unf=OtherCon []]
EvalEnd.$wisPassedPawn
  = \ (ww_snFX :: Colour)
      (ww1_snG4 :: GHC.Prim.Int#)
      (ww2_snG6 :: Int)
      (w_snFT :: AllPieces) ->
      join {
        $j_sn83 [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> Bool
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        $j_sn83 (y_a5kT [OS=OneShot] :: GHC.Prim.Int#)
          = join {
              $j1_sn81 [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> Bool
              [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
              $j1_sn81 (y1_an01 [OS=OneShot] :: GHC.Prim.Int#)
                = let {
                    x2_an0g :: GHC.Prim.Int#
                    [LclId]
                    x2_an0g = GHC.Prim.+# ww1_snG4 y_a5kT } in
                  case GHC.Prim.>=# x2_an0g ww1_snG4 of {
                    __DEFAULT ->
                      case GHC.Prim.># y1_an01 x2_an0g of {
                        __DEFAULT ->
                          case EvalEnd.$wpawnClearAhead
                                 ww_snFX (GHC.Types.I# ww1_snG4) ww2_snG6 w_snFT
                          of {
                            False -> GHC.Types.False;
                            True ->
                              let {
                                delta_ann9 :: GHC.Prim.Int#
                                [LclId]
                                delta_ann9 = GHC.Prim.-# x2_an0g ww1_snG4 } in
                              let {
                                y'_anna :: GHC.Prim.Int#
                                [LclId]
                                y'_anna = GHC.Prim.-# y1_an01 delta_ann9 } in
                              join {
                                exit_X16 [Dmd=<L,C(U)>] :: GHC.Prim.Int# -> Bool
                                [LclId[JoinId(1)], Arity=1, Str=<L,U>]
                                exit_X16 (x_annc [OS=OneShot] :: GHC.Prim.Int#)
                                  = EvalEnd.$wpawnClearAhead
                                      ww_snFX (GHC.Types.I# x_annc) ww2_snG6 w_snFT } in
                              joinrec {
                                go_dn_annb [Occ=LoopBreaker] :: GHC.Prim.Int# -> Bool
                                [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                                go_dn_annb (x_annc :: GHC.Prim.Int#)
                                  = case GHC.Prim.<# x_annc y'_anna of {
                                      __DEFAULT ->
                                        case EvalEnd.$wpawnClearAhead
                                               ww_snFX (GHC.Types.I# x_annc) ww2_snG6 w_snFT
                                        of {
                                          False -> GHC.Types.False;
                                          True -> jump go_dn_annb (GHC.Prim.+# x_annc delta_ann9)
                                        };
                                      1# -> jump exit_X16 x_annc
                                    }; } in
                              jump go_dn_annb x2_an0g
                          };
                        1# ->
                          case GHC.Prim.># y1_an01 ww1_snG4 of {
                            __DEFAULT ->
                              EvalEnd.$wpawnClearAhead
                                ww_snFX (GHC.Types.I# ww1_snG4) ww2_snG6 w_snFT;
                            1# -> GHC.Types.True
                          }
                      };
                    1# ->
                      case GHC.Prim.<# y1_an01 x2_an0g of {
                        __DEFAULT ->
                          case EvalEnd.$wpawnClearAhead
                                 ww_snFX (GHC.Types.I# ww1_snG4) ww2_snG6 w_snFT
                          of {
                            False -> GHC.Types.False;
                            True ->
                              let {
                                delta_annt :: GHC.Prim.Int#
                                [LclId]
                                delta_annt = GHC.Prim.-# x2_an0g ww1_snG4 } in
                              let {
                                y'_annu :: GHC.Prim.Int#
                                [LclId]
                                y'_annu = GHC.Prim.-# y1_an01 delta_annt } in
                              join {
                                exit_X16 [Dmd=<L,C(U)>] :: GHC.Prim.Int# -> Bool
                                [LclId[JoinId(1)], Arity=1, Str=<L,U>]
                                exit_X16 (x_annw [OS=OneShot] :: GHC.Prim.Int#)
                                  = EvalEnd.$wpawnClearAhead
                                      ww_snFX (GHC.Types.I# x_annw) ww2_snG6 w_snFT } in
                              joinrec {
                                go_up_annv [Occ=LoopBreaker] :: GHC.Prim.Int# -> Bool
                                [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
                                go_up_annv (x_annw :: GHC.Prim.Int#)
                                  = case GHC.Prim.># x_annw y'_annu of {
                                      __DEFAULT ->
                                        case EvalEnd.$wpawnClearAhead
                                               ww_snFX (GHC.Types.I# x_annw) ww2_snG6 w_snFT
                                        of {
                                          False -> GHC.Types.False;
                                          True -> jump go_up_annv (GHC.Prim.+# x_annw delta_annt)
                                        };
                                      1# -> jump exit_X16 x_annw
                                    }; } in
                              jump go_up_annv x2_an0g
                          };
                        1# ->
                          case GHC.Prim.<# y1_an01 ww1_snG4 of {
                            __DEFAULT ->
                              EvalEnd.$wpawnClearAhead
                                ww_snFX (GHC.Types.I# ww1_snG4) ww2_snG6 w_snFT;
                            1# -> GHC.Types.True
                          }
                      }
                  } } in
            case ww_snFX of {
              Black -> jump $j1_sn81 6#;
              White -> jump $j1_sn81 1#
            } } in
      case ww_snFX of {
        Black -> jump $j_sn83 1#;
        White -> jump $j_sn83 -1#
      }

-- RHS size: {terms: 16, types: 12, coercions: 0, joins: 0/0}
isPassedPawn [InlPrag=NOUSERINLINE[2]]
  :: Piece -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<S(LSS(SL)L),1*U(A,U,1*U(1*U(U),U(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snFS [Occ=Once!] :: Piece)
                 (w1_snFT [Occ=Once] :: AllPieces) ->
                 case w_snFS of
                 { (_ [Occ=Dead], ww2_snFX [Occ=Once], ww3_snFY [Occ=Once!],
                    _ [Occ=Dead]) ->
                 case ww3_snFY of { (ww6_snG1 [Occ=Once!], ww7_snG6 [Occ=Once]) ->
                 case ww6_snG1 of { GHC.Types.I# ww9_snG4 [Occ=Once] ->
                 EvalEnd.$wisPassedPawn ww2_snFX ww9_snG4 ww7_snG6 w1_snFT
                 }
                 }
                 }}]
isPassedPawn
  = \ (w_snFS :: Piece) (w1_snFT :: AllPieces) ->
      case w_snFS of { (ww1_snFW, ww2_snFX, ww3_snFY, ww4_snG8) ->
      case ww3_snFY of { (ww6_snG1, ww7_snG6) ->
      case ww6_snG1 of { GHC.Types.I# ww9_snG4 ->
      EvalEnd.$wisPassedPawn ww2_snFX ww9_snG4 ww7_snG6 w1_snFT
      }
      }
      }

-- RHS size: {terms: 21, types: 13, coercions: 0, joins: 0/0}
passPawnScore :: Piece -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<S(LSS(SL)L),1*U(A,U,1*U(1*U(U),U(U)),A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_amLP [Occ=Once] :: Piece)
                 (ps_amLQ [Occ=Once] :: AllPieces) ->
                 case isPassedPawn a_amLP ps_amLQ of {
                   False -> EvalEnd.isKingSideCol2;
                   True -> EvalEnd.passPawnScore1
                 }}]
passPawnScore
  = \ (a_amLP :: Piece) (ps_amLQ :: AllPieces) ->
      case a_amLP of { (ww1_snFW, ww2_snFX, ww3_snFY, ww4_snG8) ->
      case ww3_snFY of { (ww6_snG1, ww7_snG6) ->
      case ww6_snG1 of { GHC.Types.I# ww9_snG4 ->
      case EvalEnd.$wisPassedPawn ww2_snFX ww9_snG4 ww7_snG6 ps_amLQ of {
        False -> EvalEnd.isKingSideCol2;
        True -> EvalEnd.passPawnScore1
      }
      }
      }
      }

Rec {
-- RHS size: {terms: 49, types: 28, coercions: 0, joins: 0/0}
EvalEnd.getPawnPromotion_go1 [Occ=LoopBreaker]
  :: [Piece] -> [Piece]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
EvalEnd.getPawnPromotion_go1
  = \ (ds_a24u :: [Piece]) ->
      case ds_a24u of {
        [] -> GHC.Types.[] @ Piece;
        : y_a24x ys_a24y ->
          case y_a24x of wild1_X1x
          { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
          case colour_a3ZX of {
            Black ->
              case ds2_d52a of { (row_a3ZW, ds4_d52J) ->
              case row_a3ZW of { GHC.Types.I# x_a5hr ->
              case x_a5hr of {
                __DEFAULT -> EvalEnd.getPawnPromotion_go1 ys_a24y;
                6# ->
                  case ds1_d529 of {
                    Pawn ->
                      GHC.Types.:
                        @ Piece wild1_X1x (EvalEnd.getPawnPromotion_go1 ys_a24y);
                    Knight -> EvalEnd.getPawnPromotion_go1 ys_a24y;
                    Bishop -> EvalEnd.getPawnPromotion_go1 ys_a24y;
                    Rook -> EvalEnd.getPawnPromotion_go1 ys_a24y;
                    Queen -> EvalEnd.getPawnPromotion_go1 ys_a24y;
                    King -> EvalEnd.getPawnPromotion_go1 ys_a24y
                  }
              }
              }
              };
            White -> EvalEnd.getPawnPromotion_go1 ys_a24y
          }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 49, types: 28, coercions: 0, joins: 0/0}
EvalEnd.getPawnPromotion_go [Occ=LoopBreaker] :: [Piece] -> [Piece]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
EvalEnd.getPawnPromotion_go
  = \ (ds_a24u :: [Piece]) ->
      case ds_a24u of {
        [] -> GHC.Types.[] @ Piece;
        : y_a24x ys_a24y ->
          case y_a24x of wild1_X1x
          { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
          case colour_a3ZX of {
            Black -> EvalEnd.getPawnPromotion_go ys_a24y;
            White ->
              case ds2_d52a of { (row_a3ZW, ds4_d52J) ->
              case row_a3ZW of { GHC.Types.I# x_a5hr ->
              case x_a5hr of {
                __DEFAULT -> EvalEnd.getPawnPromotion_go ys_a24y;
                1# ->
                  case ds1_d529 of {
                    Pawn ->
                      GHC.Types.:
                        @ Piece wild1_X1x (EvalEnd.getPawnPromotion_go ys_a24y);
                    Knight -> EvalEnd.getPawnPromotion_go ys_a24y;
                    Bishop -> EvalEnd.getPawnPromotion_go ys_a24y;
                    Rook -> EvalEnd.getPawnPromotion_go ys_a24y;
                    Queen -> EvalEnd.getPawnPromotion_go ys_a24y;
                    King -> EvalEnd.getPawnPromotion_go ys_a24y
                  }
              }
              }
              }
          }
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
pawnsNearEnd :: Colour -> AllPieces -> [Piece]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [50 0] 60 0}]
pawnsNearEnd
  = \ (ds_dmVb :: Colour) (ps_amLJ :: AllPieces) ->
      case ds_dmVb of {
        Black -> EvalEnd.getPawnPromotion_go1 ps_amLJ;
        White -> EvalEnd.getPawnPromotion_go ps_amLJ
      }

-- RHS size: {terms: 28, types: 15, coercions: 0, joins: 0/0}
getPawnPromotion :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_amLN [Occ=Once!] :: Colour)
                 (ps_amLO [Occ=Once*] :: AllPieces) ->
                 case c_amLN of {
                   Black ->
                     case GHC.List.$wlenAcc
                            @ (PieceType, Colour, Pos, Movecount)
                            (EvalEnd.getPawnPromotion_go1 ps_amLO)
                            0#
                     of ww2_al5S [Occ=Once]
                     { __DEFAULT ->
                     GHC.Types.F#
                       (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.5#)
                     };
                   White ->
                     case GHC.List.$wlenAcc
                            @ (PieceType, Colour, Pos, Movecount)
                            (EvalEnd.getPawnPromotion_go ps_amLO)
                            0#
                     of ww2_al5S [Occ=Once]
                     { __DEFAULT ->
                     GHC.Types.F#
                       (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.5#)
                     }
                 }}]
getPawnPromotion
  = \ (c_amLN :: Colour) (ps_amLO :: AllPieces) ->
      case c_amLN of {
        Black ->
          case GHC.List.$wlenAcc
                 @ (PieceType, Colour, Pos, Movecount)
                 (EvalEnd.getPawnPromotion_go1 ps_amLO)
                 0#
          of ww2_al5S
          { __DEFAULT ->
          GHC.Types.F#
            (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.5#)
          };
        White ->
          case GHC.List.$wlenAcc
                 @ (PieceType, Colour, Pos, Movecount)
                 (EvalEnd.getPawnPromotion_go ps_amLO)
                 0#
          of ww2_al5S
          { __DEFAULT ->
          GHC.Types.F#
            (GHC.Prim.timesFloat# (GHC.Prim.int2Float# ww2_al5S) 1.5#)
          }
      }

-- RHS size: {terms: 429, types: 188, coercions: 0, joins: 10/10}
EvalEnd.$wallPawns [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
EvalEnd.$wallPawns
  = \ (w_snGu :: Colour) (w1_snGv :: AllPieces) ->
      join {
        $j_snyO [Dmd=<C(S),C(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(1)], Arity=1, Str=<L,U>]
        $j_snyO (x_akU6 [OS=OneShot] :: GHC.Prim.Float#)
          = join {
              exit_XY [Dmd=<C(S),C(U)>] :: GHC.Prim.Float# -> GHC.Prim.Float#
              [LclId[JoinId(1)], Arity=1, Str=<L,U>]
              exit_XY (ww_snGj [OS=OneShot] :: GHC.Prim.Float#)
                = GHC.Prim.minusFloat#
                    x_akU6 (GHC.Prim.plusFloat# ww_snGj ww_snGj) } in
            joinrec {
              $wgo_snGl [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
              [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
              $wgo_snGl (w2_snGf :: [Piece]) (ww_snGj :: GHC.Prim.Float#)
                = case w2_snGf of {
                    [] -> jump exit_XY ww_snGj;
                    : y_a24x ys_a24y ->
                      case y_a24x of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                      join {
                        $j1_sn8z [Dmd=<L,1*U>] :: GHC.Prim.Float#
                        [LclId[JoinId(0)]]
                        $j1_sn8z
                          = case ds1_d529 of {
                              Pawn ->
                                case ds2_d52a of { (ww2_snG1, ww3_snG6) ->
                                case ww2_snG1 of { GHC.Types.I# ww5_snG4 ->
                                case EvalEnd.$wisPassedPawn colour_a3ZX ww5_snG4 ww3_snG6 w1_snGv
                                of {
                                  False -> jump $wgo_snGl ys_a24y ww_snGj;
                                  True -> jump $wgo_snGl ys_a24y (GHC.Prim.plusFloat# ww_snGj 5.0#)
                                }
                                }
                                };
                              Knight -> jump $wgo_snGl ys_a24y ww_snGj;
                              Bishop -> jump $wgo_snGl ys_a24y ww_snGj;
                              Rook -> jump $wgo_snGl ys_a24y ww_snGj;
                              Queen -> jump $wgo_snGl ys_a24y ww_snGj;
                              King -> jump $wgo_snGl ys_a24y ww_snGj
                            } } in
                      case colour_a3ZX of {
                        Black ->
                          case w_snGu of {
                            Black ->
                              joinrec {
                                $wgo1_XnIm [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnIm (w3_XnIh :: [Piece]) (ww1_XnKp :: GHC.Prim.Float#)
                                  = case w3_XnIh of {
                                      [] -> jump exit_XY ww1_XnKp;
                                      : y1_X26D ys1_X26F ->
                                        case y1_X26D of
                                        { (ds4_X54l, colour1_X42a, ds5_X54o, ds6_X54q) ->
                                        case colour1_X42a of {
                                          Black -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                          White ->
                                            case ds4_X54l of {
                                              Pawn ->
                                                case ds5_X54o of { (ww3_snG1, ww4_snG6) ->
                                                case ww3_snG1 of { GHC.Types.I# ww6_snG4 ->
                                                case EvalEnd.$wisPassedPawn
                                                       TypeDefs.White ww6_snG4 ww4_snG6 w1_snGv
                                                of {
                                                  False -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                                  True ->
                                                    jump $wgo1_XnIm
                                                      ys1_X26F (GHC.Prim.plusFloat# ww1_XnKp 5.0#)
                                                }
                                                }
                                                };
                                              Knight -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Bishop -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Rook -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Queen -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              King -> jump $wgo1_XnIm ys1_X26F ww1_XnKp
                                            }
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnIm ys_a24y ww_snGj;
                            White -> jump $j1_sn8z
                          };
                        White ->
                          case w_snGu of {
                            Black -> jump $j1_sn8z;
                            White ->
                              joinrec {
                                $wgo1_XnIm [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                                  :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                                $wgo1_XnIm (w3_XnIh :: [Piece]) (ww1_XnKp :: GHC.Prim.Float#)
                                  = case w3_XnIh of {
                                      [] -> jump exit_XY ww1_XnKp;
                                      : y1_X26D ys1_X26F ->
                                        case y1_X26D of
                                        { (ds4_X54l, colour1_X42a, ds5_X54o, ds6_X54q) ->
                                        case colour1_X42a of {
                                          Black ->
                                            case ds4_X54l of {
                                              Pawn ->
                                                case ds5_X54o of { (ww3_snG1, ww4_snG6) ->
                                                case ww3_snG1 of { GHC.Types.I# ww6_snG4 ->
                                                case EvalEnd.$wisPassedPawn
                                                       TypeDefs.Black ww6_snG4 ww4_snG6 w1_snGv
                                                of {
                                                  False -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                                  True ->
                                                    jump $wgo1_XnIm
                                                      ys1_X26F (GHC.Prim.plusFloat# ww1_XnKp 5.0#)
                                                }
                                                }
                                                };
                                              Knight -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Bishop -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Rook -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              Queen -> jump $wgo1_XnIm ys1_X26F ww1_XnKp;
                                              King -> jump $wgo1_XnIm ys1_X26F ww1_XnKp
                                            };
                                          White -> jump $wgo1_XnIm ys1_X26F ww1_XnKp
                                        }
                                        }
                                    }; } in
                              jump $wgo1_XnIm ys_a24y ww_snGj
                          }
                      }
                      }
                  }; } in
            jump $wgo_snGl w1_snGv 0.0# } in
      joinrec {
        $wgo_snGt [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
          :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        $wgo_snGt (w2_snGn :: [Piece]) (ww_snGr :: GHC.Prim.Float#)
          = case w2_snGn of {
              [] -> jump $j_snyO ww_snGr;
              : y_a24x ys_a24y ->
                case y_a24x of { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                join {
                  $j1_sn8p [Dmd=<L,1*U>] :: GHC.Prim.Float#
                  [LclId[JoinId(0)]]
                  $j1_sn8p
                    = case ds1_d529 of {
                        Pawn ->
                          case ds2_d52a of { (ww2_snG1, ww3_snG6) ->
                          case ww2_snG1 of { GHC.Types.I# ww5_snG4 ->
                          case EvalEnd.$wisPassedPawn colour_a3ZX ww5_snG4 ww3_snG6 w1_snGv
                          of {
                            False -> jump $wgo_snGt ys_a24y ww_snGr;
                            True -> jump $wgo_snGt ys_a24y (GHC.Prim.plusFloat# ww_snGr 5.0#)
                          }
                          }
                          };
                        Knight -> jump $wgo_snGt ys_a24y ww_snGr;
                        Bishop -> jump $wgo_snGt ys_a24y ww_snGr;
                        Rook -> jump $wgo_snGt ys_a24y ww_snGr;
                        Queen -> jump $wgo_snGt ys_a24y ww_snGr;
                        King -> jump $wgo_snGt ys_a24y ww_snGr
                      } } in
                case colour_a3ZX of {
                  Black ->
                    case w_snGu of {
                      Black -> jump $j1_sn8p;
                      White ->
                        joinrec {
                          $wgo1_XnKr [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                            :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                          $wgo1_XnKr (w3_XnIn :: [Piece]) (ww1_XnKt :: GHC.Prim.Float#)
                            = case w3_XnIn of {
                                [] -> jump $j_snyO ww1_XnKt;
                                : y1_X26B ys1_X26D ->
                                  case y1_X26B of { (ds4_X54j, colour1_X428, ds5_X54m, ds6_X54o) ->
                                  case colour1_X428 of {
                                    Black -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                    White ->
                                      case ds4_X54j of {
                                        Pawn ->
                                          case ds5_X54m of { (ww3_snG1, ww4_snG6) ->
                                          case ww3_snG1 of { GHC.Types.I# ww6_snG4 ->
                                          case EvalEnd.$wisPassedPawn
                                                 TypeDefs.White ww6_snG4 ww4_snG6 w1_snGv
                                          of {
                                            False -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                            True ->
                                              jump $wgo1_XnKr
                                                ys1_X26D (GHC.Prim.plusFloat# ww1_XnKt 5.0#)
                                          }
                                          }
                                          };
                                        Knight -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Bishop -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Rook -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Queen -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        King -> jump $wgo1_XnKr ys1_X26D ww1_XnKt
                                      }
                                  }
                                  }
                              }; } in
                        jump $wgo1_XnKr ys_a24y ww_snGr
                    };
                  White ->
                    case w_snGu of {
                      Black ->
                        joinrec {
                          $wgo1_XnKr [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
                            :: [Piece] -> GHC.Prim.Float# -> GHC.Prim.Float#
                          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
                          $wgo1_XnKr (w3_XnIn :: [Piece]) (ww1_XnKt :: GHC.Prim.Float#)
                            = case w3_XnIn of {
                                [] -> jump $j_snyO ww1_XnKt;
                                : y1_X26B ys1_X26D ->
                                  case y1_X26B of { (ds4_X54j, colour1_X428, ds5_X54m, ds6_X54o) ->
                                  case colour1_X428 of {
                                    Black ->
                                      case ds4_X54j of {
                                        Pawn ->
                                          case ds5_X54m of { (ww3_snG1, ww4_snG6) ->
                                          case ww3_snG1 of { GHC.Types.I# ww6_snG4 ->
                                          case EvalEnd.$wisPassedPawn
                                                 TypeDefs.Black ww6_snG4 ww4_snG6 w1_snGv
                                          of {
                                            False -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                            True ->
                                              jump $wgo1_XnKr
                                                ys1_X26D (GHC.Prim.plusFloat# ww1_XnKt 5.0#)
                                          }
                                          }
                                          };
                                        Knight -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Bishop -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Rook -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        Queen -> jump $wgo1_XnKr ys1_X26D ww1_XnKt;
                                        King -> jump $wgo1_XnKr ys1_X26D ww1_XnKt
                                      };
                                    White -> jump $wgo1_XnKr ys1_X26D ww1_XnKt
                                  }
                                  }
                              }; } in
                        jump $wgo1_XnKr ys_a24y ww_snGr;
                      White -> jump $j1_sn8p
                    }
                }
                }
            }; } in
      jump $wgo_snGt w1_snGv 0.0#

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
allPawns [InlPrag=NOUSERINLINE[2]] :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snGu [Occ=Once] :: Colour)
                 (w1_snGv [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wallPawns w_snGu w1_snGv of ww_snGy [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snGy
                 }}]
allPawns
  = \ (w_snGu :: Colour) (w1_snGv :: AllPieces) ->
      case EvalEnd.$wallPawns w_snGu w1_snGv of ww_snGy { __DEFAULT ->
      GHC.Types.F# ww_snGy
      }

-- RHS size: {terms: 137, types: 30, coercions: 0, joins: 0/0}
EvalEnd.$wtotalEndVal [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 637 0}]
EvalEnd.$wtotalEndVal
  = \ (w_snGA :: Colour) (w1_snGB :: AllPieces) ->
      case EvalEnd.$wtotalMaterial w_snGA w1_snGB of ww_snFy
      { __DEFAULT ->
      case findKing
             (case w_snGA of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             w1_snGB
      of
      { (ds1_d52T, col_a3ZV) ->
      case col_a3ZV of { GHC.Types.I# x_a5hr ->
      case x_a5hr of {
        __DEFAULT ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# ww_snFy ww1_snGy
              };
            0# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 1.5#) ww1_snGy
              };
            7# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 1.5#) ww1_snGy
              }
          }
          };
        0# ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 1.5#) ww1_snGy
              };
            0# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 3.0#) ww1_snGy
              };
            7# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 3.0#) ww1_snGy
              }
          }
          };
        7# ->
          case ds1_d52T of { GHC.Types.I# x1_X5jf ->
          case x1_X5jf of {
            __DEFAULT ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 1.5#) ww1_snGy
              };
            0# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 3.0#) ww1_snGy
              };
            7# ->
              case EvalEnd.$wallPawns w_snGA w1_snGB of ww1_snGy { __DEFAULT ->
              GHC.Prim.plusFloat# (GHC.Prim.plusFloat# ww_snFy 3.0#) ww1_snGy
              }
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalEndVal [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_snGA [Occ=Once] :: Colour)
                 (w1_snGB [Occ=Once] :: AllPieces) ->
                 case EvalEnd.$wtotalEndVal w_snGA w1_snGB of ww_snGE [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_snGE
                 }}]
totalEndVal
  = \ (w_snGA :: Colour) (w1_snGB :: AllPieces) ->
      case EvalEnd.$wtotalEndVal w_snGA w1_snGB of ww_snGE { __DEFAULT ->
      GHC.Types.F# ww_snGE
      }



[ 9 of 14] Compiling Eval             ( Eval.hs, Eval.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 81, types: 27, coercions: 0, joins: 1/1}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Eval.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Eval.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Eval.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Eval.$trModule3 = GHC.Types.TrNameS Eval.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Eval.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Eval.$trModule2 = "Eval"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Eval.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Eval.$trModule1 = GHC.Types.TrNameS Eval.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Eval.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Eval.$trModule = GHC.Types.Module Eval.$trModule3 Eval.$trModule1

-- RHS size: {terms: 56, types: 13, coercions: 0, joins: 1/1}
Eval.$wtotalVal [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 328 0}]
Eval.$wtotalVal
  = \ (w_spER :: Colour) (w1_spES :: AllPieces) ->
      case Util.getGamePoint_go w1_spES Util.allPiecesMoved1 of
      { GHC.Types.I# x_a5ox ->
      join {
        $j_spEd [Dmd=<L,1*U>] :: GHC.Prim.Float#
        [LclId[JoinId(0)]]
        $j_spEd
          = case GHC.Prim.<=# x_a5ox 6# of {
              __DEFAULT ->
                case Util.allPiecesMoved_go w1_spES Util.allPiecesMoved1 of
                { GHC.Types.I# x1_a5nX ->
                case GHC.Prim.>=# x1_a5nX 16# of {
                  __DEFAULT -> EvalEnd.$wtotalEndVal w_spER w1_spES;
                  1# -> EvalOpening.$wtotalOpeningVal w_spER w1_spES
                }
                };
              1# -> EvalEnd.$wtotalEndVal w_spER w1_spES
            } } in
      case GHC.Prim.<=# x_a5ox 6# of {
        __DEFAULT ->
          case Util.allPiecesMoved_go w1_spES Util.allPiecesMoved1 of
          { GHC.Types.I# x1_a5nX ->
          case GHC.Prim.>=# x1_a5nX 16# of {
            __DEFAULT -> EvalOpening.$wtotalOpeningVal w_spER w1_spES;
            1# -> jump $j_spEd
          }
          };
        1# -> jump $j_spEd
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalVal [InlPrag=NOUSERINLINE[2]] :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_spER [Occ=Once] :: Colour)
                 (w1_spES [Occ=Once] :: AllPieces) ->
                 case Eval.$wtotalVal w_spER w1_spES of ww_spEV [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_spEV
                 }}]
totalVal
  = \ (w_spER :: Colour) (w1_spES :: AllPieces) ->
      case Eval.$wtotalVal w_spER w1_spES of ww_spEV { __DEFAULT ->
      GHC.Types.F# ww_spEV
      }



[10 of 14] Compiling OpeningSearch    ( OpeningSearch.hs, OpeningSearch.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,636, types: 1,903, coercions: 0, joins: 14/45}

Rec {
-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
$wunsafeDrop_rrLh :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []]
$wunsafeDrop_rrLh
  = \ (@ a1_sqX6) (ww_sqXb :: GHC.Prim.Int#) (w_sqX8 :: [a1_sqX6]) ->
      case w_sqX8 of {
        [] -> GHC.Types.[] @ a1_sqX6;
        : ipv1_apXm ipv2_apXn ->
          case ww_sqXb of ds3_apXp {
            __DEFAULT ->
              $wunsafeDrop_rrLh @ a1_sqX6 (GHC.Prim.-# ds3_apXp 1#) ipv2_apXn;
            1# -> ipv2_apXn
          }
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rrLi :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rrLi = GHC.Types.F# 0.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.findStrongestMoveFromAll2 = GHC.Types.F# -10000.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.findStrongestMoveFromAll4 = GHC.Types.I# 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
OpeningSearch.findStrongestMoveFromAll3
  = (OpeningSearch.findStrongestMoveFromAll4,
     OpeningSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.findStrongestMoveFromAll7 = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.findStrongestMoveFromAll8 = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll6 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
OpeningSearch.findStrongestMoveFromAll6
  = (OpeningSearch.findStrongestMoveFromAll8,
     OpeningSearch.findStrongestMoveFromAll7)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll5
  :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
OpeningSearch.findStrongestMoveFromAll5
  = (TypeDefs.King, TypeDefs.White,
     OpeningSearch.findStrongestMoveFromAll6,
     OpeningSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
OpeningSearch.findStrongestMoveFromAll1
  :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 40}]
OpeningSearch.findStrongestMoveFromAll1
  = (OpeningSearch.findStrongestMoveFromAll5,
     OpeningSearch.findStrongestMoveFromAll3,
     OpeningSearch.findStrongestMoveFromAll2)

-- RHS size: {terms: 111, types: 227, coercions: 0, joins: 6/6}
findStrongestMoveFromAll
  :: [(Piece, Move, Float)] -> (Piece, Move, Float)
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 322 0}]
findStrongestMoveFromAll
  = \ (xs_apIu :: [(Piece, Move, Float)]) ->
      case xs_apIu of {
        [] -> OpeningSearch.findStrongestMoveFromAll1;
        : ds1_a5jz ds2_a5jA ->
          joinrec {
            $sgo_srxo [Occ=LoopBreaker]
              :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
                 -> [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
                 -> (Piece, Move, Float)
            [LclId[JoinId(2)],
             Arity=2,
             Str=<S(LLS),1*U(U,U,U(U))><L,U>m,
             Unf=OtherCon []]
            $sgo_srxo (sc_srxm
                         :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float))
                      (sc1_srxn
                         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
              = join {
                  exit_X1d [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                  [LclId[JoinId(0)], Str=m]
                  exit_X1d = jump go_a24t sc1_srxn } in
                case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                case f_a3ZR of { GHC.Types.F# x_apYQ ->
                case sc_srxm of wild3_X3o { (ds6_X5hF, ds7_X5hH, f1_X41R) ->
                case f1_X41R of { GHC.Types.F# y_apYT ->
                case GHC.Prim.leFloat# x_apYQ y_apYT of {
                  __DEFAULT -> jump exit_X1d;
                  1# ->
                    joinrec {
                      go1_X25Q [Occ=LoopBreaker]
                        :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                      go1_X25Q (ds_X25S :: [(Piece, Move, Float)])
                        = case ds_X25S of {
                            [] -> wild3_X3o;
                            : y1_X27F ys_X27I ->
                              case y1_X27F of { (ds8_X5hu, ds9_X5hw, f2_X41G) ->
                              case f2_X41G of { GHC.Types.F# x1_Xq0K ->
                              case GHC.Prim.leFloat# x1_Xq0K y_apYT of {
                                __DEFAULT -> jump exit_X1d;
                                1# -> jump go1_X25Q ys_X27I
                              }
                              }
                              }
                          }; } in
                    jump go1_X25Q ds2_a5jA
                }
                }
                }
                }
                };
            go_a24t [Occ=LoopBreaker]
              :: [(Piece, Move, Float)] -> (Piece, Move, Float)
            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
            go_a24t (ds_a24u :: [(Piece, Move, Float)])
              = case ds_a24u of {
                  [] -> GHC.List.badHead @ (Piece, Move, Float);
                  : y_a24x ys_a24y ->
                    join {
                      exit_X1d [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                      [LclId[JoinId(0)], Str=m]
                      exit_X1d = jump go_a24t ys_a24y } in
                    case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                    case f_a3ZR of { GHC.Types.F# x_apYQ ->
                    case y_a24x of wild4_X3o { (ds6_X5hF, ds7_X5hH, f1_X41R) ->
                    case f1_X41R of { GHC.Types.F# y1_apYT ->
                    case GHC.Prim.leFloat# x_apYQ y1_apYT of {
                      __DEFAULT -> jump exit_X1d;
                      1# ->
                        joinrec {
                          go1_X25Q [Occ=LoopBreaker]
                            :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                          [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                          go1_X25Q (ds8_X25S :: [(Piece, Move, Float)])
                            = case ds8_X25S of {
                                [] -> wild4_X3o;
                                : y2_X27F ys1_X27I ->
                                  case y2_X27F of { (ds9_X5hu, ds10_X5hw, f2_X41G) ->
                                  case f2_X41G of { GHC.Types.F# x1_Xq0K ->
                                  case GHC.Prim.leFloat# x1_Xq0K y1_apYT of {
                                    __DEFAULT -> jump exit_X1d;
                                    1# -> jump go1_X25Q ys1_X27I
                                  }
                                  }
                                  }
                              }; } in
                        jump go1_X25Q ds2_a5jA
                    }
                    }
                    }
                    }
                    }
                }; } in
          jump $sgo_srxo ds1_a5jz ds2_a5jA
      }

-- RHS size: {terms: 415, types: 457, coercions: 0, joins: 5/8}
removeMove
  :: (Piece, Move, Float)
     -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))><S,U>,
 Unf=OtherCon []]
removeMove
  = \ (x_apIC :: (Piece, Move, Float))
      (ds_dpQF :: [(Piece, Move, Float)]) ->
      join {
        fail_sq3M [Dmd=<L,1*C1(U)>]
          :: GHC.Prim.Void# -> [(Piece, Move, Float)]
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sq3M _ [Occ=Dead, OS=OneShot]
          = case ds_dpQF of {
              [] -> GHC.Types.[] @ (Piece, Move, Float);
              : y_a24x ys_a24y ->
                case y_a24x of ww3_apYa { (ww4_apYb, ww5_apYc, ww6_apYd) ->
                case x_apIC of { (ww8_apYj, ww9_apYk, ww10_apYl) ->
                case ww4_apYb of { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
                case ww8_apYj of { (b1_a5i1, b2_a5i2, b3_a5i3, b4_a5i4) ->
                let {
                  ds2_dpQO :: [(Piece, Move, Float)]
                  [LclId]
                  ds2_dpQO
                    = letrec {
                        go_a24t [Occ=LoopBreaker]
                          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go_a24t
                          = \ (ds3_a24u :: [(Piece, Move, Float)]) ->
                              case ds3_a24u of {
                                [] -> GHC.Types.[] @ (Piece, Move, Float);
                                : y1_X267 ys1_X269 ->
                                  case y1_X267 of ww1_XpZO { (ww2_XpZR, ww13_XpZT, ww14_XpZV) ->
                                  case ww2_XpZR of { (a7_X5jP, a8_X5jR, a9_X5jT, a10_X5jV) ->
                                  let {
                                    ds4_XpSW :: [(Piece, Move, Float)]
                                    [LclId]
                                    ds4_XpSW = go_a24t ys1_X269 } in
                                  join {
                                    $j_sq6q [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                    [LclId[JoinId(0)]]
                                    $j_sq6q
                                      = join {
                                          $j1_sq6m [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                          [LclId[JoinId(0)]]
                                          $j1_sq6m
                                            = case a9_X5jT of { (ww16_a5iu, ww17_a5iv) ->
                                              case b3_a5i3 of { (ww19_a5iA, ww20_a5iB) ->
                                              case ww16_a5iu of { GHC.Types.I# x1_a5hr ->
                                              case ww19_a5iA of { GHC.Types.I# y2_a5hu ->
                                              case GHC.Prim.==# x1_a5hr y2_a5hu of {
                                                __DEFAULT ->
                                                  GHC.Types.:
                                                    @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                                1# ->
                                                  case ww17_a5iv of { GHC.Types.I# x2_X5jS ->
                                                  case ww20_a5iB of { GHC.Types.I# y3_X5mI ->
                                                  case GHC.Prim.==# x2_X5jS y3_X5mI of {
                                                    __DEFAULT ->
                                                      GHC.Types.:
                                                        @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                                    1# ->
                                                      case a10_X5jV of { GHC.Types.I# x3_X5mV ->
                                                      case b4_a5i4 of { GHC.Types.I# y4_X5kd ->
                                                      case GHC.Prim.==# x3_X5mV y4_X5kd of {
                                                        __DEFAULT ->
                                                          GHC.Types.:
                                                            @ (Piece, Move, Float)
                                                            ww1_XpZO
                                                            ds4_XpSW;
                                                        1# ->
                                                          case ww13_XpZT of
                                                          { (ww22_X5kT, ww23_X5kV) ->
                                                          case ww9_apYk of
                                                          { (ww25_X5l5, ww26_X5l7) ->
                                                          case ww22_X5kT of
                                                          { GHC.Types.I# x4_X5ku ->
                                                          case ww25_X5l5 of
                                                          { GHC.Types.I# y5_X5kC ->
                                                          case GHC.Prim.==# x4_X5ku y5_X5kC of {
                                                            __DEFAULT ->
                                                              GHC.Types.:
                                                                @ (Piece, Move, Float)
                                                                ww1_XpZO
                                                                ds4_XpSW;
                                                            1# ->
                                                              case ww23_X5kV of
                                                              { GHC.Types.I# x5_X5kH ->
                                                              case ww26_X5l7 of
                                                              { GHC.Types.I# y6_X5kP ->
                                                              case GHC.Prim.==# x5_X5kH y6_X5kP of {
                                                                __DEFAULT ->
                                                                  GHC.Types.:
                                                                    @ (Piece, Move, Float)
                                                                    ww1_XpZO
                                                                    ds4_XpSW;
                                                                1# ->
                                                                  case ww14_XpZV of
                                                                  { GHC.Types.F# x6_apZA ->
                                                                  case ww10_apYl of
                                                                  { GHC.Types.F# y7_apZD ->
                                                                  case GHC.Prim.eqFloat#
                                                                         x6_apZA y7_apZD
                                                                  of {
                                                                    __DEFAULT ->
                                                                      GHC.Types.:
                                                                        @ (Piece, Move, Float)
                                                                        ww1_XpZO
                                                                        ds4_XpSW;
                                                                    1# -> ds4_XpSW
                                                                  }
                                                                  }
                                                                  }
                                                              }
                                                              }
                                                              }
                                                          }
                                                          }
                                                          }
                                                          }
                                                          }
                                                      }
                                                      }
                                                      }
                                                  }
                                                  }
                                                  }
                                              }
                                              }
                                              }
                                              }
                                              } } in
                                        case a8_X5jR of {
                                          Black ->
                                            case b2_a5i2 of {
                                              Black -> jump $j1_sq6m;
                                              White ->
                                                GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW
                                            };
                                          White ->
                                            case b2_a5i2 of {
                                              Black ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                              White -> jump $j1_sq6m
                                            }
                                        } } in
                                  case a7_X5jP of {
                                    Pawn ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        Pawn -> jump $j_sq6q
                                      };
                                    Knight ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        Knight -> jump $j_sq6q
                                      };
                                    Bishop ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        Bishop -> jump $j_sq6q
                                      };
                                    Rook ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        Rook -> jump $j_sq6q
                                      };
                                    Queen ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        Queen -> jump $j_sq6q
                                      };
                                    King ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XpSW;
                                        King -> jump $j_sq6q
                                      }
                                  }
                                  }
                                  }
                              }; } in
                      go_a24t ys_a24y } in
                join {
                  $j_sq6q [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                  [LclId[JoinId(0)]]
                  $j_sq6q
                    = join {
                        $j1_sq6m [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                        [LclId[JoinId(0)]]
                        $j1_sq6m
                          = case a3_a5hX of { (ww2_a5iu, ww13_a5iv) ->
                            case b3_a5i3 of { (ww15_a5iA, ww16_a5iB) ->
                            case ww2_a5iu of { GHC.Types.I# x1_a5hr ->
                            case ww15_a5iA of { GHC.Types.I# y1_a5hu ->
                            case GHC.Prim.==# x1_a5hr y1_a5hu of {
                              __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                              1# ->
                                case ww13_a5iv of { GHC.Types.I# x2_X5jS ->
                                case ww16_a5iB of { GHC.Types.I# y2_X5k0 ->
                                case GHC.Prim.==# x2_X5jS y2_X5k0 of {
                                  __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                                  1# ->
                                    case a4_a5hY of { GHC.Types.I# x3_X5k5 ->
                                    case b4_a5i4 of { GHC.Types.I# y3_X5kd ->
                                    case GHC.Prim.==# x3_X5k5 y3_X5kd of {
                                      __DEFAULT ->
                                        GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                                      1# ->
                                        case ww5_apYc of { (ww18_X5kT, ww19_X5kV) ->
                                        case ww9_apYk of { (ww21_X5l5, ww22_X5l7) ->
                                        case ww18_X5kT of { GHC.Types.I# x4_X5ku ->
                                        case ww21_X5l5 of { GHC.Types.I# y4_X5kC ->
                                        case GHC.Prim.==# x4_X5ku y4_X5kC of {
                                          __DEFAULT ->
                                            GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                                          1# ->
                                            case ww19_X5kV of { GHC.Types.I# x5_X5kH ->
                                            case ww22_X5l7 of { GHC.Types.I# y5_X5kP ->
                                            case GHC.Prim.==# x5_X5kH y5_X5kP of {
                                              __DEFAULT ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                                              1# ->
                                                case ww6_apYd of { GHC.Types.F# x6_apZA ->
                                                case ww10_apYl of { GHC.Types.F# y6_apZD ->
                                                case GHC.Prim.eqFloat# x6_apZA y6_apZD of {
                                                  __DEFAULT ->
                                                    GHC.Types.:
                                                      @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                                                  1# -> ds2_dpQO
                                                }
                                                }
                                                }
                                            }
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                        }
                                    }
                                    }
                                    }
                                }
                                }
                                }
                            }
                            }
                            }
                            }
                            } } in
                      case a2_a5hW of {
                        Black ->
                          case b2_a5i2 of {
                            Black -> jump $j1_sq6m;
                            White -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO
                          };
                        White ->
                          case b2_a5i2 of {
                            Black -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                            White -> jump $j1_sq6m
                          }
                      } } in
                case a1_a5hV of {
                  Pawn ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      Pawn -> jump $j_sq6q
                    };
                  Knight ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      Knight -> jump $j_sq6q
                    };
                  Bishop ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      Bishop -> jump $j_sq6q
                    };
                  Rook ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      Rook -> jump $j_sq6q
                    };
                  Queen ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      Queen -> jump $j_sq6q
                    };
                  King ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dpQO;
                      King -> jump $j_sq6q
                    }
                }
                }
                }
                }
                }
            } } in
      case ds_dpQF of {
        [] -> jump fail_sq3M GHC.Prim.void#;
        : y_apID ds1_dpR1 ->
          case ds1_dpR1 of {
            [] -> GHC.Types.[] @ (Piece, Move, Float);
            : ipv_spYs ipv1_spYt -> jump fail_sq3M GHC.Prim.void#
          }
      }

Rec {
-- RHS size: {terms: 24, types: 45, coercions: 0, joins: 0/1}
OpeningSearch.takeTopMoves_$stakeTopMoves [Occ=LoopBreaker]
  :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
     -> GHC.Prim.Int# -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []]
OpeningSearch.takeTopMoves_$stakeTopMoves
  = \ (sc_srxc
         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
      (sc1_srxb :: GHC.Prim.Int#) ->
      case sc_srxc of wild_Xy {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_spZa ipv1_spZb ->
          case sc1_srxb of ds_XpRO {
            __DEFAULT ->
              let {
                m_sq3K [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_sq3K = findStrongestMoveFromAll wild_Xy } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_sq3K
                (OpeningSearch.takeTopMoves_$stakeTopMoves
                   (removeMove m_sq3K wild_Xy) (GHC.Prim.+# ds_XpRO 1#));
            99# -> GHC.Types.[] @ (Piece, Move, Float)
          }
      }
end Rec }

-- RHS size: {terms: 27, types: 39, coercions: 0, joins: 0/1}
takeTopMoves
  :: Int -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 151 50}]
takeTopMoves
  = \ (n_apIx :: Int) (ds_dpRh :: [(Piece, Move, Float)]) ->
      case ds_dpRh of wild_Xy {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_spZa ipv1_spZb ->
          case n_apIx of { GHC.Types.I# ds1_dpRw ->
          case ds1_dpRw of ds2_XpRO {
            __DEFAULT ->
              let {
                m_sq3K [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_sq3K = findStrongestMoveFromAll wild_Xy } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_sq3K
                (OpeningSearch.takeTopMoves_$stakeTopMoves
                   (removeMove m_sq3K wild_Xy) (GHC.Prim.+# ds2_XpRO 1#));
            99# -> GHC.Types.[] @ (Piece, Move, Float)
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
OpeningSearch.$trModule2 = "OpeningSearch"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.$trModule1
  = GHC.Types.TrNameS OpeningSearch.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
OpeningSearch.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
OpeningSearch.$trModule3
  = GHC.Types.TrNameS OpeningSearch.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
OpeningSearch.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
OpeningSearch.$trModule
  = GHC.Types.Module
      OpeningSearch.$trModule3 OpeningSearch.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
checkmate :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
checkmate = GHC.Types.F# 10000.0#

Rec {
-- RHS size: {terms: 28, types: 29, coercions: 0, joins: 0/0}
isCheckmate :: Colour -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 200 10}]
isCheckmate
  = \ (c_apIR :: Colour) (ps_apIS :: AllPieces) ->
      case makeEvalList c_apIR ps_apIS of {
        [] ->
          case findPiece (findKing c_apIR ps_apIS) ps_apIS of {
            [] -> case GHC.List.badHead of wild2_00 { };
            : x_a4SP ds1_a4SQ ->
              case x_a4SP of { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
              Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT ps_apIS
              }
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 152, types: 124, coercions: 0, joins: 3/9}
makeEvalList [Occ=LoopBreaker]
  :: Colour -> AllPieces -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
makeEvalList
  = \ (c_apIH :: Colour) (ps_apII :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  case y_a24x of wild1_X1x
                  { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                  let {
                    ds4_dpQB :: [(Piece, Move, Float)]
                    [LclId]
                    ds4_dpQB = go_a24t ys_a24y } in
                  join {
                    $j_sq7z [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                    [LclId[JoinId(0)]]
                    $j_sq7z
                      = let {
                          lvl3_srdT :: Colour
                          [LclId]
                          lvl3_srdT
                            = case colour_a3ZX of {
                                Black -> TypeDefs.White;
                                White -> TypeDefs.Black
                              } } in
                        case Util.$wlegalMoves
                               ds1_d529 colour_a3ZX ds2_d52a ds3_d52b ps_apII
                        of {
                          [] -> ds4_dpQB;
                          : y1_X26a ys1_X26c ->
                            case ds2_d52a of wild3_a5lQ { (a1_a5lR, a2_a5lS) ->
                            case a1_a5lR of { GHC.Types.I# x_a5hr ->
                            let {
                              ds5_dpQD :: [(Piece, Move, Float)]
                              [LclId]
                              ds5_dpQD
                                = letrec {
                                    go1_X262 [Occ=LoopBreaker] :: [Move] -> [(Piece, Move, Float)]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                    go1_X262
                                      = \ (ds6_X264 :: [Move]) ->
                                          case ds6_X264 of {
                                            [] -> ds4_dpQB;
                                            : y2_X27S ys2_X27V ->
                                              let {
                                                ds7_XpSy :: [(Piece, Move, Float)]
                                                [LclId]
                                                ds7_XpSy = go1_X262 ys2_X27V } in
                                              join {
                                                $j1_sq7w [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                                [LclId[JoinId(0)], Unf=OtherCon []]
                                                $j1_sq7w
                                                  = GHC.Types.:
                                                      @ (Piece, Move, Float)
                                                      (wild1_X1x, y2_X27S,
                                                       case y2_X27S of { (ww6_s8tZ, ww7_s8u4) ->
                                                       case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 ->
                                                       case isCheckmate
                                                              lvl3_srdT
                                                              (Util.$wexecuteMove
                                                                 ds1_d529
                                                                 colour_a3ZX
                                                                 wild3_a5lQ
                                                                 ds3_d52b
                                                                 ww9_s8u2
                                                                 ww7_s8u4
                                                                 ps_apII)
                                                       of {
                                                         False -> lvl_rrLi;
                                                         True -> checkmate
                                                       }
                                                       }
                                                       })
                                                      ds7_XpSy } in
                                              case x_a5hr of {
                                                __DEFAULT -> jump $j1_sq7w;
                                                -1# ->
                                                  case a2_a5lS of { GHC.Types.I# x1_X5jv ->
                                                  case x1_X5jv of {
                                                    __DEFAULT -> jump $j1_sq7w;
                                                    -1# -> ds7_XpSy
                                                  }
                                                  }
                                              }
                                          }; } in
                                  go1_X262 ys1_X26c } in
                            join {
                              $j1_sq7w [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                              [LclId[JoinId(0)], Unf=OtherCon []]
                              $j1_sq7w
                                = GHC.Types.:
                                    @ (Piece, Move, Float)
                                    (wild1_X1x, y1_X26a,
                                     case y1_X26a of { (ww6_s8tZ, ww7_s8u4) ->
                                     case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 ->
                                     case isCheckmate
                                            lvl3_srdT
                                            (Util.$wexecuteMove
                                               ds1_d529
                                               colour_a3ZX
                                               wild3_a5lQ
                                               ds3_d52b
                                               ww9_s8u2
                                               ww7_s8u4
                                               ps_apII)
                                     of {
                                       False -> lvl_rrLi;
                                       True -> checkmate
                                     }
                                     }
                                     })
                                    ds5_dpQD } in
                            case x_a5hr of {
                              __DEFAULT -> jump $j1_sq7w;
                              -1# ->
                                case a2_a5lS of { GHC.Types.I# x1_X5jv ->
                                case x1_X5jv of {
                                  __DEFAULT -> jump $j1_sq7w;
                                  -1# -> ds5_dpQD
                                }
                                }
                            }
                            }
                            }
                        } } in
                  case colour_a3ZX of {
                    Black ->
                      case c_apIH of {
                        Black -> jump $j_sq7z;
                        White -> ds4_dpQB
                      };
                    White ->
                      case c_apIH of {
                        Black -> ds4_dpQB;
                        White -> jump $j_sq7z
                      }
                  }
                  }
              }; } in
      go_a24t ps_apII
end Rec }

-- RHS size: {terms: 27, types: 9, coercions: 0, joins: 0/0}
OpeningSearch.$wevalMove [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> GHC.Prim.Float#
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 0 0 0 0 0] 150 0}]
OpeningSearch.$wevalMove
  = \ (ww_sqXO :: PieceType)
      (ww1_sqXP :: Colour)
      (ww2_sqXQ :: Pos)
      (ww3_sqXR :: Movecount)
      (ww4_sqXY :: GHC.Prim.Int#)
      (ww5_sqY0 :: Int)
      (w_sqXL :: AllPieces) ->
      case isCheckmate
             (case ww1_sqXP of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             (Util.$wexecuteMove
                ww_sqXO ww1_sqXP ww2_sqXQ ww3_sqXR ww4_sqXY ww5_sqY0 w_sqXL)
      of {
        False -> 0.0#;
        True -> 10000.0#
      }

-- RHS size: {terms: 24, types: 14, coercions: 0, joins: 0/0}
evalMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Float
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sqXJ [Occ=Once!] :: Piece)
                 (w1_sqXK [Occ=Once!] :: Move)
                 (w2_sqXL [Occ=Once] :: AllPieces) ->
                 case w_sqXJ of
                 { (ww1_sqXO [Occ=Once], ww2_sqXP [Occ=Once], ww3_sqXQ [Occ=Once],
                    ww4_sqXR [Occ=Once]) ->
                 case w1_sqXK of { (ww6_sqXV [Occ=Once!], ww7_sqY0 [Occ=Once]) ->
                 case ww6_sqXV of { GHC.Types.I# ww9_sqXY [Occ=Once] ->
                 case OpeningSearch.$wevalMove
                        ww1_sqXO ww2_sqXP ww3_sqXQ ww4_sqXR ww9_sqXY ww7_sqY0 w2_sqXL
                 of ww10_sqY4 [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww10_sqY4
                 }
                 }
                 }
                 }}]
evalMove
  = \ (w_sqXJ :: Piece) (w1_sqXK :: Move) (w2_sqXL :: AllPieces) ->
      case w_sqXJ of { (ww1_sqXO, ww2_sqXP, ww3_sqXQ, ww4_sqXR) ->
      case w1_sqXK of { (ww6_sqXV, ww7_sqY0) ->
      case ww6_sqXV of { GHC.Types.I# ww9_sqXY ->
      case OpeningSearch.$wevalMove
             ww1_sqXO ww2_sqXP ww3_sqXQ ww4_sqXR ww9_sqXY ww7_sqY0 w2_sqXL
      of ww10_sqY4
      { __DEFAULT ->
      GHC.Types.F# ww10_sqY4
      }
      }
      }
      }

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
findSingleBestMove :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_apIs [Occ=Once] :: Colour)
                 (ps_apIt [Occ=Once] :: AllPieces) ->
                 findStrongestMoveFromAll (makeEvalList c_apIs ps_apIt)}]
findSingleBestMove
  = \ (c_apIs :: Colour) (ps_apIt :: AllPieces) ->
      findStrongestMoveFromAll (makeEvalList c_apIs ps_apIt)

Rec {
-- RHS size: {terms: 202, types: 155, coercions: 0, joins: 0/2}
OpeningSearch.addTrueEval_$s$waddTrueEval [Occ=LoopBreaker]
  :: [(PieceType, Colour, (Int, Int), Int)]
     -> GHC.Prim.Float#
     -> (Int, Int)
     -> (PieceType, Colour, (Int, Int), Int)
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> Colour
     -> Colour
     -> (# Piece, Move, Float #)
[GblId,
 Arity=8,
 Str=<L,U><L,U><L,U(U(U),U(U))><L,U(U,U,U(U(U),U(U)),U(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []]
OpeningSearch.addTrueEval_$s$waddTrueEval
  = \ (sc_srvZ :: [(PieceType, Colour, (Int, Int), Int)])
      (sc1_srvY :: GHC.Prim.Float#)
      (sc2_srvX :: (Int, Int))
      (sc3_srvW :: (PieceType, Colour, (Int, Int), Int))
      (sc4_srvV :: GHC.Prim.Int#)
      (sc5_srvU :: GHC.Prim.Int#)
      (sc6_srvT :: Colour)
      (sc7_srvS :: Colour) ->
      case GHC.Prim.==# sc5_srvU sc4_srvV of {
        __DEFAULT ->
          case sc5_srvU of wild_X2b {
            __DEFAULT ->
              case isCheckmate
                     (case sc7_srvS of {
                        Black -> TypeDefs.White;
                        White -> TypeDefs.Black
                      })
                     sc_srvZ
              of {
                False ->
                  case isCheckmate sc7_srvS sc_srvZ of {
                    False ->
                      OpeningSearch.addTrueEval_$s$waddTrueEval
                        (let {
                           d_sqkZ :: GHC.Prim.Int#
                           [LclId]
                           d_sqkZ = GHC.Prim.-# sc4_srvV wild_X2b } in
                         letrec {
                           go_a24t [Occ=LoopBreaker]
                             :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
                           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                           go_a24t
                             = \ (ds_a24u :: [(Piece, Move, Float)]) ->
                                 case ds_a24u of {
                                   [] -> GHC.Types.[] @ (Piece, Move, Float);
                                   : y_a24x ys_a24y ->
                                     GHC.Types.:
                                       @ (Piece, Move, Float)
                                       (case y_a24x of { (ww1_Xr0O, ww2_Xr0Q, ww3_Xr0S) ->
                                        case OpeningSearch.$waddTrueEval
                                               sc6_srvT
                                               sc6_srvT
                                               0#
                                               d_sqkZ
                                               ww1_Xr0O
                                               ww2_Xr0Q
                                               ww3_Xr0S
                                               sc_srvZ
                                        of
                                        { (# ww5_sqZk, ww6_sqZl, ww7_sqZm #) ->
                                        (ww5_sqZk, ww6_sqZl, ww7_sqZm)
                                        }
                                        })
                                       (go_a24t ys_a24y)
                                 }; } in
                         case findStrongestMoveFromAll
                                (go_a24t (makeEvalList sc6_srvT sc_srvZ))
                         of
                         { (a_apIL, b_apIM, ds_dpQp) ->
                         case a_apIL of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                         case b_apIM of { (ww6_s8tZ, ww7_s8u4) ->
                         case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 ->
                         Util.$wexecuteMove
                           ww1_s8tS ww2_s8tT ww3_s8tU ww4_s8tV ww9_s8u2 ww7_s8u4 sc_srvZ
                         }
                         }
                         }
                         })
                        0.0#
                        sc2_srvX
                        sc3_srvW
                        sc4_srvV
                        (GHC.Prim.+# wild_X2b 1#)
                        (case sc6_srvT of {
                           Black -> TypeDefs.White;
                           White -> TypeDefs.Black
                         })
                        sc7_srvS;
                    True ->
                      (# sc3_srvW, sc2_srvX,
                         GHC.Types.F#
                           (GHC.Prim.minusFloat# -10000.0# (GHC.Prim.int2Float# wild_X2b)) #)
                  };
                True ->
                  (# sc3_srvW, sc2_srvX,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# 10000.0# (GHC.Prim.int2Float# wild_X2b)) #)
              };
            0# ->
              case GHC.Prim.eqFloat# sc1_srvY 10000.0# of {
                __DEFAULT ->
                  OpeningSearch.addTrueEval_$s$waddTrueEval
                    (case sc3_srvW of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
                     case sc2_srvX of { (ww6_s8tZ, ww7_s8u4) ->
                     case ww6_s8tZ of { GHC.Types.I# ww9_s8u2 ->
                     Util.$wexecuteMove
                       ww1_s8tS ww2_s8tT ww3_s8tU ww4_s8tV ww9_s8u2 ww7_s8u4 sc_srvZ
                     }
                     }
                     })
                    0.0#
                    sc2_srvX
                    sc3_srvW
                    sc4_srvV
                    1#
                    (case sc6_srvT of {
                       Black -> TypeDefs.White;
                       White -> TypeDefs.Black
                     })
                    sc7_srvS;
                1# -> (# sc3_srvW, sc2_srvX, GHC.Types.F# sc1_srvY #)
              }
          };
        1# ->
          case isCheckmate
                 (case sc7_srvS of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 sc_srvZ
          of {
            False ->
              case isCheckmate sc7_srvS sc_srvZ of {
                False -> (# sc3_srvW, sc2_srvX, totalVal sc7_srvS sc_srvZ #);
                True ->
                  (# sc3_srvW, sc2_srvX,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# -10000.0# (GHC.Prim.int2Float# sc5_srvU)) #)
              };
            True ->
              (# sc3_srvW, sc2_srvX,
                 GHC.Types.F#
                   (GHC.Prim.minusFloat# 10000.0# (GHC.Prim.int2Float# sc5_srvU)) #)
          }
      }

-- RHS size: {terms: 204, types: 142, coercions: 0, joins: 0/2}
OpeningSearch.$waddTrueEval [InlPrag=NOUSERINLINE[2],
                             Occ=LoopBreaker]
  :: Colour
     -> Colour
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> Piece
     -> Move
     -> Float
     -> AllPieces
     -> (# Piece, Move, Float #)
[GblId,
 Arity=8,
 Str=<L,U><L,U><L,U><L,U><L,U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,1*U(U)><L,U>,
 Unf=OtherCon []]
OpeningSearch.$waddTrueEval
  = \ (ww_sqYe :: Colour)
      (ww1_sqYf :: Colour)
      (ww2_sqYj :: GHC.Prim.Int#)
      (ww3_sqYn :: GHC.Prim.Int#)
      (ww4_sqYr :: Piece)
      (ww5_sqYs :: Move)
      (ww6_sqYt :: Float)
      (w_sqYb :: AllPieces) ->
      case GHC.Prim.==# ww2_sqYj ww3_sqYn of {
        __DEFAULT ->
          case ww2_sqYj of wild_X2b {
            __DEFAULT ->
              case isCheckmate
                     (case ww_sqYe of {
                        Black -> TypeDefs.White;
                        White -> TypeDefs.Black
                      })
                     w_sqYb
              of {
                False ->
                  case isCheckmate ww_sqYe w_sqYb of {
                    False ->
                      OpeningSearch.addTrueEval_$s$waddTrueEval
                        (let {
                           d_sqkZ :: GHC.Prim.Int#
                           [LclId]
                           d_sqkZ = GHC.Prim.-# ww3_sqYn wild_X2b } in
                         letrec {
                           go_a24t [Occ=LoopBreaker]
                             :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
                           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                           go_a24t
                             = \ (ds_a24u :: [(Piece, Move, Float)]) ->
                                 case ds_a24u of {
                                   [] -> GHC.Types.[] @ (Piece, Move, Float);
                                   : y_a24x ys_a24y ->
                                     GHC.Types.:
                                       @ (Piece, Move, Float)
                                       (case y_a24x of { (ww8_Xr0O, ww9_Xr0Q, ww10_Xr0S) ->
                                        case OpeningSearch.$waddTrueEval
                                               ww1_sqYf
                                               ww1_sqYf
                                               0#
                                               d_sqkZ
                                               ww8_Xr0O
                                               ww9_Xr0Q
                                               ww10_Xr0S
                                               w_sqYb
                                        of
                                        { (# ww12_sqZk, ww13_sqZl, ww14_sqZm #) ->
                                        (ww12_sqZk, ww13_sqZl, ww14_sqZm)
                                        }
                                        })
                                       (go_a24t ys_a24y)
                                 }; } in
                         case findStrongestMoveFromAll
                                (go_a24t (makeEvalList ww1_sqYf w_sqYb))
                         of
                         { (a_apIL, b_apIM, ds_dpQp) ->
                         case a_apIL of { (ww8_s8tS, ww9_s8tT, ww10_s8tU, ww11_s8tV) ->
                         case b_apIM of { (ww13_s8tZ, ww14_s8u4) ->
                         case ww13_s8tZ of { GHC.Types.I# ww16_s8u2 ->
                         Util.$wexecuteMove
                           ww8_s8tS ww9_s8tT ww10_s8tU ww11_s8tV ww16_s8u2 ww14_s8u4 w_sqYb
                         }
                         }
                         }
                         })
                        0.0#
                        ww5_sqYs
                        ww4_sqYr
                        ww3_sqYn
                        (GHC.Prim.+# wild_X2b 1#)
                        (case ww1_sqYf of {
                           Black -> TypeDefs.White;
                           White -> TypeDefs.Black
                         })
                        ww_sqYe;
                    True ->
                      (# ww4_sqYr, ww5_sqYs,
                         GHC.Types.F#
                           (GHC.Prim.minusFloat# -10000.0# (GHC.Prim.int2Float# wild_X2b)) #)
                  };
                True ->
                  (# ww4_sqYr, ww5_sqYs,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# 10000.0# (GHC.Prim.int2Float# wild_X2b)) #)
              };
            0# ->
              case ww6_sqYt of wild1_apZz { GHC.Types.F# x_apZA ->
              case GHC.Prim.eqFloat# x_apZA 10000.0# of {
                __DEFAULT ->
                  OpeningSearch.addTrueEval_$s$waddTrueEval
                    (case ww4_sqYr of { (ww8_s8tS, ww9_s8tT, ww10_s8tU, ww11_s8tV) ->
                     case ww5_sqYs of { (ww13_s8tZ, ww14_s8u4) ->
                     case ww13_s8tZ of { GHC.Types.I# ww16_s8u2 ->
                     Util.$wexecuteMove
                       ww8_s8tS ww9_s8tT ww10_s8tU ww11_s8tV ww16_s8u2 ww14_s8u4 w_sqYb
                     }
                     }
                     })
                    0.0#
                    ww5_sqYs
                    ww4_sqYr
                    ww3_sqYn
                    1#
                    (case ww1_sqYf of {
                       Black -> TypeDefs.White;
                       White -> TypeDefs.Black
                     })
                    ww_sqYe;
                1# -> (# ww4_sqYr, ww5_sqYs, wild1_apZz #)
              }
              }
          };
        1# ->
          case isCheckmate
                 (case ww_sqYe of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 w_sqYb
          of {
            False ->
              case isCheckmate ww_sqYe w_sqYb of {
                False -> (# ww4_sqYr, ww5_sqYs, totalVal ww_sqYe w_sqYb #);
                True ->
                  (# ww4_sqYr, ww5_sqYs,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# -10000.0# (GHC.Prim.int2Float# ww2_sqYj)) #)
              };
            True ->
              (# ww4_sqYr, ww5_sqYs,
                 GHC.Types.F#
                   (GHC.Prim.minusFloat# 10000.0# (GHC.Prim.int2Float# ww2_sqYj)) #)
          }
      }
end Rec }

-- RHS size: {terms: 32, types: 39, coercions: 0, joins: 0/0}
addTrueEval [InlPrag=NOUSERINLINE[2]]
  :: (Colour, Colour)
     -> Int
     -> Int
     -> (Piece, Move, Float)
     -> AllPieces
     -> (Piece, Move, Float)
[GblId,
 Arity=5,
 Str=<S,1*U(U,U)><S,1*U(U)><S,1*U(U)><S,1*U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),1*U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sqY7 [Occ=Once!] :: (Colour, Colour))
                 (w1_sqY8 [Occ=Once!] :: Int)
                 (w2_sqY9 [Occ=Once!] :: Int)
                 (w3_sqYa [Occ=Once!] :: (Piece, Move, Float))
                 (w4_sqYb [Occ=Once] :: AllPieces) ->
                 case w_sqY7 of { (ww1_sqYe [Occ=Once], ww2_sqYf [Occ=Once]) ->
                 case w1_sqY8 of { GHC.Types.I# ww4_sqYj [Occ=Once] ->
                 case w2_sqY9 of { GHC.Types.I# ww6_sqYn [Occ=Once] ->
                 case w3_sqYa of
                 { (ww8_sqYr [Occ=Once], ww9_sqYs [Occ=Once],
                    ww10_sqYt [Occ=Once]) ->
                 case OpeningSearch.$waddTrueEval
                        ww1_sqYe
                        ww2_sqYf
                        ww4_sqYj
                        ww6_sqYn
                        ww8_sqYr
                        ww9_sqYs
                        ww10_sqYt
                        w4_sqYb
                 of
                 { (# ww12_sqZk [Occ=Once], ww13_sqZl [Occ=Once],
                      ww14_sqZm [Occ=Once] #) ->
                 (ww12_sqZk, ww13_sqZl, ww14_sqZm)
                 }
                 }
                 }
                 }
                 }}]
addTrueEval
  = \ (w_sqY7 :: (Colour, Colour))
      (w1_sqY8 :: Int)
      (w2_sqY9 :: Int)
      (w3_sqYa :: (Piece, Move, Float))
      (w4_sqYb :: AllPieces) ->
      case w_sqY7 of { (ww1_sqYe, ww2_sqYf) ->
      case w1_sqY8 of { GHC.Types.I# ww4_sqYj ->
      case w2_sqY9 of { GHC.Types.I# ww6_sqYn ->
      case w3_sqYa of { (ww8_sqYr, ww9_sqYs, ww10_sqYt) ->
      case OpeningSearch.$waddTrueEval
             ww1_sqYe
             ww2_sqYf
             ww4_sqYj
             ww6_sqYn
             ww8_sqYr
             ww9_sqYs
             ww10_sqYt
             w4_sqYb
      of
      { (# ww12_sqZk, ww13_sqZl, ww14_sqZm #) ->
      (ww12_sqZk, ww13_sqZl, ww14_sqZm)
      }
      }
      }
      }
      }

-- RHS size: {terms: 106, types: 221, coercions: 0, joins: 0/3}
findRealBestOpeningMove
  :: Int
     -> Colour
     -> AllPieces
     -> [(Piece, Move, Float)]
     -> (Piece, Move, Float)
[GblId,
 Arity=4,
 Str=<L,U(U)><L,U><L,U><S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 300] 730 0}]
findRealBestOpeningMove
  = \ (d_apI9 :: Int)
      (c_apIa :: Colour)
      (ps_apIb :: AllPieces)
      (ds_dpS5 :: [(Piece, Move, Float)]) ->
      case ds_dpS5 of {
        [] ->
          letrec {
            go_a24t [Occ=LoopBreaker]
              :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_a24t
              = \ (ds1_a24u :: [(Piece, Move, Float)]) ->
                  case ds1_a24u of {
                    [] -> GHC.Types.[] @ (Piece, Move, Float);
                    : y_a24x ys_a24y ->
                      GHC.Types.:
                        @ (Piece, Move, Float)
                        (case d_apI9 of { GHC.Types.I# ww1_sqYn ->
                         case y_a24x of { (ww3_sqYr, ww4_sqYs, ww5_sqYt) ->
                         case OpeningSearch.$waddTrueEval
                                c_apIa c_apIa 0# ww1_sqYn ww3_sqYr ww4_sqYs ww5_sqYt ps_apIb
                         of
                         { (# ww7_sqZk, ww8_sqZl, ww9_sqZm #) ->
                         (ww7_sqZk, ww8_sqZl, ww9_sqZm)
                         }
                         }
                         })
                        (go_a24t ys_a24y)
                  }; } in
          findStrongestMoveFromAll (go_a24t (makeEvalList c_apIa ps_apIb));
        : ipv_spZg ipv1_spZh ->
          letrec {
            $sgo_srv9 [Occ=LoopBreaker]
              :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
                 -> [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
                 -> [(Piece, Move, Float)]
            [LclId,
             Arity=2,
             Str=<L,1*U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),1*U(U))><L,1*U>,
             Unf=OtherCon []]
            $sgo_srv9
              = \ (sc_srv7
                     :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float))
                  (sc1_srv8
                     :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]) ->
                  GHC.Types.:
                    @ (Piece, Move, Float)
                    (case d_apI9 of { GHC.Types.I# ww1_sqYn ->
                     case sc_srv7 of { (ww3_sqYr, ww4_sqYs, ww5_sqYt) ->
                     case OpeningSearch.$waddTrueEval
                            c_apIa c_apIa 0# ww1_sqYn ww3_sqYr ww4_sqYs ww5_sqYt ps_apIb
                     of
                     { (# ww7_sqZk, ww8_sqZl, ww9_sqZm #) ->
                     (ww7_sqZk, ww8_sqZl, ww9_sqZm)
                     }
                     }
                     })
                    (go_a24t sc1_srv8);
            go_a24t [Occ=LoopBreaker]
              :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
            [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
            go_a24t
              = \ (ds1_a24u :: [(Piece, Move, Float)]) ->
                  case ds1_a24u of {
                    [] -> GHC.Types.[] @ (Piece, Move, Float);
                    : y_a24x ys_a24y ->
                      GHC.Types.:
                        @ (Piece, Move, Float)
                        (case d_apI9 of { GHC.Types.I# ww1_sqYn ->
                         case y_a24x of { (ww3_sqYr, ww4_sqYs, ww5_sqYt) ->
                         case OpeningSearch.$waddTrueEval
                                c_apIa c_apIa 0# ww1_sqYn ww3_sqYr ww4_sqYs ww5_sqYt ps_apIb
                         of
                         { (# ww7_sqZk, ww8_sqZl, ww9_sqZm #) ->
                         (ww7_sqZk, ww8_sqZl, ww9_sqZm)
                         }
                         }
                         })
                        (go_a24t ys_a24y)
                  }; } in
          findStrongestMoveFromAll ($sgo_srv9 ipv_spZg ipv1_spZh)
      }

-- RHS size: {terms: 184, types: 146, coercions: 0, joins: 0/13}
openingMoveWrapper
  :: Int -> Colour -> AllPieces -> (Piece, Move, Float)
[GblId, Arity=3, Str=<L,U(U)><L,U><L,U>m, Unf=OtherCon []]
openingMoveWrapper
  = \ (d_apHU :: Int) (c_apHV :: Colour) (ps_apHW :: AllPieces) ->
      let {
        a_sq3q :: [(Piece, Move, Float)]
        [LclId]
        a_sq3q = makeEvalList c_apHV ps_apHW } in
      let {
        e_sq3p [Dmd=<L,U(U)>] :: Int
        [LclId]
        e_sq3p
          = case GHC.List.$wlenAcc @ (Piece, Move, Float) a_sq3q 0#
            of ww2_al5S
            { __DEFAULT ->
            GHC.Types.I# ww2_al5S
            } } in
      let {
        r_sq3m :: [(Piece, Move, Float)]
        [LclId]
        r_sq3m
          = case e_sq3p of { GHC.Types.I# ww1_aj4s ->
            let {
              x_a5ox :: GHC.Prim.Int#
              [LclId]
              x_a5ox = GHC.Prim.uncheckedIShiftRA# ww1_aj4s 1# } in
            case GHC.Prim.<=# x_a5ox 0# of {
              __DEFAULT ->
                $wunsafeDrop_rrLh @ (Piece, Move, Float) x_a5ox a_sq3q;
              1# -> a_sq3q
            }
            } } in
      let {
        s4_sq3k :: (Piece, Move, Float)
        [LclId]
        s4_sq3k
          = case e_sq3p of { GHC.Types.I# ww1_aj4s ->
            let {
              x_a5ox :: GHC.Prim.Int#
              [LclId]
              x_a5ox = GHC.Prim.uncheckedIShiftRA# ww1_aj4s 2# } in
            case GHC.Prim.<=# x_a5ox 0# of {
              __DEFAULT ->
                findRealBestOpeningMove
                  d_apHU
                  c_apHV
                  ps_apHW
                  ($wunsafeDrop_rrLh @ (Piece, Move, Float) x_a5ox r_sq3m);
              1# -> findRealBestOpeningMove d_apHU c_apHV ps_apHW r_sq3m
            }
            } } in
      case GHC.Prim.par# @ (Piece, Move, Float) s4_sq3k of { __DEFAULT ->
      findStrongestMoveFromAll
        (GHC.Magic.lazy
           @ [(Piece, Move, Float)]
           (let {
              s3_sq3l :: (Piece, Move, Float)
              [LclId]
              s3_sq3l
                = case e_sq3p of { GHC.Types.I# ww1_aj4s ->
                  let {
                    y_a5kc :: GHC.Prim.Int#
                    [LclId]
                    y_a5kc
                      = GHC.Prim.+# (GHC.Prim.uncheckedIShiftRA# ww1_aj4s 2#) 1# } in
                  case GHC.Prim.<# 0# y_a5kc of {
                    __DEFAULT ->
                      findRealBestOpeningMove
                        d_apHU c_apHV ps_apHW (GHC.Types.[] @ (Piece, Move, Float));
                    1# ->
                      findRealBestOpeningMove
                        d_apHU
                        c_apHV
                        ps_apHW
                        (GHC.List.$wunsafeTake @ (Piece, Move, Float) y_a5kc r_sq3m)
                  }
                  } } in
            case GHC.Prim.par# @ (Piece, Move, Float) s3_sq3l of { __DEFAULT ->
            GHC.Magic.lazy
              @ [(Piece, Move, Float)]
              (let {
                 l_sq3o :: [(Piece, Move, Float)]
                 [LclId]
                 l_sq3o
                   = case e_sq3p of { GHC.Types.I# ww1_aj4s ->
                     let {
                       y_a5kc :: GHC.Prim.Int#
                       [LclId]
                       y_a5kc
                         = GHC.Prim.+# (GHC.Prim.uncheckedIShiftRA# ww1_aj4s 1#) 1# } in
                     case GHC.Prim.<# 0# y_a5kc of {
                       __DEFAULT -> GHC.Types.[] @ (Piece, Move, Float);
                       1# -> GHC.List.$wunsafeTake @ (Piece, Move, Float) y_a5kc a_sq3q
                     }
                     } } in
               let {
                 s2_sq3n :: (Piece, Move, Float)
                 [LclId]
                 s2_sq3n
                   = case e_sq3p of { GHC.Types.I# ww1_aj4s ->
                     let {
                       x_a5ox :: GHC.Prim.Int#
                       [LclId]
                       x_a5ox = GHC.Prim.uncheckedIShiftRA# ww1_aj4s 2# } in
                     case GHC.Prim.<=# x_a5ox 0# of {
                       __DEFAULT ->
                         findRealBestOpeningMove
                           d_apHU
                           c_apHV
                           ps_apHW
                           ($wunsafeDrop_rrLh @ (Piece, Move, Float) x_a5ox l_sq3o);
                       1# -> findRealBestOpeningMove d_apHU c_apHV ps_apHW l_sq3o
                     }
                     } } in
               case GHC.Prim.par# @ (Piece, Move, Float) s2_sq3n of { __DEFAULT ->
               GHC.Magic.lazy
                 @ [(Piece, Move, Float)]
                 (GHC.Types.:
                    @ (Piece, Move, Float)
                    (case e_sq3p of { GHC.Types.I# ww1_aj4s ->
                     let {
                       y_a5kc :: GHC.Prim.Int#
                       [LclId]
                       y_a5kc
                         = GHC.Prim.+# (GHC.Prim.uncheckedIShiftRA# ww1_aj4s 2#) 1# } in
                     case GHC.Prim.<# 0# y_a5kc of {
                       __DEFAULT ->
                         findRealBestOpeningMove
                           d_apHU c_apHV ps_apHW (GHC.Types.[] @ (Piece, Move, Float));
                       1# ->
                         findRealBestOpeningMove
                           d_apHU
                           c_apHV
                           ps_apHW
                           (GHC.List.$wunsafeTake @ (Piece, Move, Float) y_a5kc l_sq3o)
                     }
                     })
                    (GHC.Types.:
                       @ (Piece, Move, Float)
                       s2_sq3n
                       (GHC.Types.:
                          @ (Piece, Move, Float)
                          s3_sq3l
                          (GHC.Types.:
                             @ (Piece, Move, Float)
                             s4_sq3k
                             (GHC.Types.[] @ (Piece, Move, Float))))))
               })
            }))
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
makeSingleBestMove
  :: (Piece, Move, Float) -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Str=<S(S(SLLL)S(SL)L),1*U(1*U(U,U,U(U(U),U(U)),U(U)),1*U(1*U(U),U(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dpQg [Occ=Once!] :: (Piece, Move, Float))
                 (ps_apIN [Occ=Once] :: AllPieces) ->
                 case ds_dpQg of
                 { (a_apIL [Occ=Once], b_apIM [Occ=Once], _ [Occ=Dead]) ->
                 executeMove a_apIL b_apIM ps_apIN
                 }}]
makeSingleBestMove
  = \ (ds_dpQg :: (Piece, Move, Float)) (ps_apIN :: AllPieces) ->
      case ds_dpQg of { (a_apIL, b_apIM, ds1_dpQp) ->
      executeMove a_apIL b_apIM ps_apIN
      }


------ Local rules for imported ids --------
"SC:takeTopMoves0"
    forall (sc_srxc
              :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
           (sc1_srxb :: GHC.Prim.Int#).
      takeTopMoves (GHC.Types.I# sc1_srxb) sc_srxc
      = OpeningSearch.takeTopMoves_$stakeTopMoves sc_srxc sc1_srxb
"SC:$waddTrueEval0" [2]
    forall (sc_srvZ :: [(PieceType, Colour, (Int, Int), Int)])
           (sc1_srvY :: GHC.Prim.Float#)
           (sc2_srvX :: (Int, Int))
           (sc3_srvW :: (PieceType, Colour, (Int, Int), Int))
           (sc4_srvV :: GHC.Prim.Int#)
           (sc5_srvU :: GHC.Prim.Int#)
           (sc6_srvT :: Colour)
           (sc7_srvS :: Colour).
      OpeningSearch.$waddTrueEval sc7_srvS
                                  sc6_srvT
                                  sc5_srvU
                                  sc4_srvV
                                  sc3_srvW
                                  sc2_srvX
                                  (GHC.Types.F# sc1_srvY)
                                  sc_srvZ
      = OpeningSearch.addTrueEval_$s$waddTrueEval
          sc_srvZ
          sc1_srvY
          sc2_srvX
          sc3_srvW
          sc4_srvV
          sc5_srvU
          sc6_srvT
          sc7_srvS


[11 of 14] Compiling MiddleSearch     ( MiddleSearch.hs, MiddleSearch.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,233, types: 1,409, coercions: 0, joins: 13/25}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.findStrongestMoveFromAll4 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.findStrongestMoveFromAll2 = GHC.Types.F# -10000.0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
MiddleSearch.findStrongestMoveFromAll3
  = (MiddleSearch.findStrongestMoveFromAll4,
     MiddleSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.findStrongestMoveFromAll7 = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.findStrongestMoveFromAll8 = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll6 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
MiddleSearch.findStrongestMoveFromAll6
  = (MiddleSearch.findStrongestMoveFromAll8,
     MiddleSearch.findStrongestMoveFromAll7)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll5
  :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
MiddleSearch.findStrongestMoveFromAll5
  = (TypeDefs.King, TypeDefs.White,
     MiddleSearch.findStrongestMoveFromAll6,
     MiddleSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
MiddleSearch.findStrongestMoveFromAll1
  :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 40}]
MiddleSearch.findStrongestMoveFromAll1
  = (MiddleSearch.findStrongestMoveFromAll5,
     MiddleSearch.findStrongestMoveFromAll3,
     MiddleSearch.findStrongestMoveFromAll2)

-- RHS size: {terms: 111, types: 227, coercions: 0, joins: 6/6}
findStrongestMoveFromAll
  :: [(Piece, Move, Float)] -> (Piece, Move, Float)
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 322 0}]
findStrongestMoveFromAll
  = \ (xs_asOc :: [(Piece, Move, Float)]) ->
      case xs_asOc of {
        [] -> MiddleSearch.findStrongestMoveFromAll1;
        : ds1_a5jz ds2_a5jA ->
          joinrec {
            $sgo_surh [Occ=LoopBreaker]
              :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
                 -> [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
                 -> (Piece, Move, Float)
            [LclId[JoinId(2)],
             Arity=2,
             Str=<S(LLS),1*U(U,U,U(U))><L,U>m,
             Unf=OtherCon []]
            $sgo_surh (sc_surf
                         :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float))
                      (sc1_surg
                         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
              = join {
                  exit_X1a [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                  [LclId[JoinId(0)], Str=m]
                  exit_X1a = jump go_a24t sc1_surg } in
                case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                case f_a3ZR of { GHC.Types.F# x_apYQ ->
                case sc_surf of wild3_X37 { (ds6_X5ho, ds7_X5hq, f1_X41A) ->
                case f1_X41A of { GHC.Types.F# y_apYT ->
                case GHC.Prim.leFloat# x_apYQ y_apYT of {
                  __DEFAULT -> jump exit_X1a;
                  1# ->
                    joinrec {
                      go1_X25G [Occ=LoopBreaker]
                        :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                      go1_X25G (ds_X25I :: [(Piece, Move, Float)])
                        = case ds_X25I of {
                            [] -> wild3_X37;
                            : y1_X27v ys_X27y ->
                              case y1_X27v of { (ds8_X5hu, ds9_X5hw, f2_X41G) ->
                              case f2_X41G of { GHC.Types.F# x1_Xq0K ->
                              case GHC.Prim.leFloat# x1_Xq0K y_apYT of {
                                __DEFAULT -> jump exit_X1a;
                                1# -> jump go1_X25G ys_X27y
                              }
                              }
                              }
                          }; } in
                    jump go1_X25G ds2_a5jA
                }
                }
                }
                }
                };
            go_a24t [Occ=LoopBreaker]
              :: [(Piece, Move, Float)] -> (Piece, Move, Float)
            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
            go_a24t (ds_a24u :: [(Piece, Move, Float)])
              = case ds_a24u of {
                  [] -> GHC.List.badHead @ (Piece, Move, Float);
                  : y_a24x ys_a24y ->
                    join {
                      exit_X1a [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                      [LclId[JoinId(0)], Str=m]
                      exit_X1a = jump go_a24t ys_a24y } in
                    case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                    case f_a3ZR of { GHC.Types.F# x_apYQ ->
                    case y_a24x of wild4_X37 { (ds6_X5ho, ds7_X5hq, f1_X41A) ->
                    case f1_X41A of { GHC.Types.F# y1_apYT ->
                    case GHC.Prim.leFloat# x_apYQ y1_apYT of {
                      __DEFAULT -> jump exit_X1a;
                      1# ->
                        joinrec {
                          go1_X25G [Occ=LoopBreaker]
                            :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                          [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                          go1_X25G (ds8_X25I :: [(Piece, Move, Float)])
                            = case ds8_X25I of {
                                [] -> wild4_X37;
                                : y2_X27v ys1_X27y ->
                                  case y2_X27v of { (ds9_X5hu, ds10_X5hw, f2_X41G) ->
                                  case f2_X41G of { GHC.Types.F# x1_Xq0K ->
                                  case GHC.Prim.leFloat# x1_Xq0K y1_apYT of {
                                    __DEFAULT -> jump exit_X1a;
                                    1# -> jump go1_X25G ys1_X27y
                                  }
                                  }
                                  }
                              }; } in
                        jump go1_X25G ds2_a5jA
                    }
                    }
                    }
                    }
                    }
                }; } in
          jump $sgo_surh ds1_a5jz ds2_a5jA
      }

-- RHS size: {terms: 415, types: 457, coercions: 0, joins: 5/8}
removeMove
  :: (Piece, Move, Float)
     -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))><S,U>,
 Unf=OtherCon []]
removeMove
  = \ (x_asOk :: (Piece, Move, Float))
      (ds_dsTM :: [(Piece, Move, Float)]) ->
      join {
        fail_ssYB [Dmd=<L,1*C1(U)>]
          :: GHC.Prim.Void# -> [(Piece, Move, Float)]
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_ssYB _ [Occ=Dead, OS=OneShot]
          = case ds_dsTM of {
              [] -> GHC.Types.[] @ (Piece, Move, Float);
              : y_a24x ys_a24y ->
                case y_a24x of ww3_apYa { (ww4_apYb, ww5_apYc, ww6_apYd) ->
                case x_asOk of { (ww8_apYj, ww9_apYk, ww10_apYl) ->
                case ww4_apYb of { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
                case ww8_apYj of { (b1_a5i1, b2_a5i2, b3_a5i3, b4_a5i4) ->
                let {
                  ds2_dsTV :: [(Piece, Move, Float)]
                  [LclId]
                  ds2_dsTV
                    = letrec {
                        go_a24t [Occ=LoopBreaker]
                          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go_a24t
                          = \ (ds3_a24u :: [(Piece, Move, Float)]) ->
                              case ds3_a24u of {
                                [] -> GHC.Types.[] @ (Piece, Move, Float);
                                : y1_X267 ys1_X269 ->
                                  case y1_X267 of ww1_XpZO { (ww2_XpZR, ww13_XpZT, ww14_XpZV) ->
                                  case ww2_XpZR of { (a7_X5jP, a8_X5jR, a9_X5jT, a10_X5jV) ->
                                  let {
                                    ds4_XsW3 :: [(Piece, Move, Float)]
                                    [LclId]
                                    ds4_XsW3 = go_a24t ys1_X269 } in
                                  join {
                                    $j_st0D [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                    [LclId[JoinId(0)]]
                                    $j_st0D
                                      = join {
                                          $j1_st0z [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                          [LclId[JoinId(0)]]
                                          $j1_st0z
                                            = case a9_X5jT of { (ww16_a5iu, ww17_a5iv) ->
                                              case b3_a5i3 of { (ww19_a5iA, ww20_a5iB) ->
                                              case ww16_a5iu of { GHC.Types.I# x1_a5hr ->
                                              case ww19_a5iA of { GHC.Types.I# y2_a5hu ->
                                              case GHC.Prim.==# x1_a5hr y2_a5hu of {
                                                __DEFAULT ->
                                                  GHC.Types.:
                                                    @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                                1# ->
                                                  case ww17_a5iv of { GHC.Types.I# x2_X5jv ->
                                                  case ww20_a5iB of { GHC.Types.I# y3_X5jD ->
                                                  case GHC.Prim.==# x2_X5jv y3_X5jD of {
                                                    __DEFAULT ->
                                                      GHC.Types.:
                                                        @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                                    1# ->
                                                      case a10_X5jV of { GHC.Types.I# x3_X5jI ->
                                                      case b4_a5i4 of { GHC.Types.I# y4_X5jQ ->
                                                      case GHC.Prim.==# x3_X5jI y4_X5jQ of {
                                                        __DEFAULT ->
                                                          GHC.Types.:
                                                            @ (Piece, Move, Float)
                                                            ww1_XpZO
                                                            ds4_XsW3;
                                                        1# ->
                                                          case ww13_XpZT of
                                                          { (ww22_X5kw, ww23_X5ky) ->
                                                          case ww9_apYk of
                                                          { (ww25_X5kI, ww26_X5kK) ->
                                                          case ww22_X5kw of
                                                          { GHC.Types.I# x4_X5nm ->
                                                          case ww25_X5kI of
                                                          { GHC.Types.I# y5_X5kf ->
                                                          case GHC.Prim.==# x4_X5nm y5_X5kf of {
                                                            __DEFAULT ->
                                                              GHC.Types.:
                                                                @ (Piece, Move, Float)
                                                                ww1_XpZO
                                                                ds4_XsW3;
                                                            1# ->
                                                              case ww23_X5ky of
                                                              { GHC.Types.I# x5_X5kk ->
                                                              case ww26_X5kK of
                                                              { GHC.Types.I# y6_X5ks ->
                                                              case GHC.Prim.==# x5_X5kk y6_X5ks of {
                                                                __DEFAULT ->
                                                                  GHC.Types.:
                                                                    @ (Piece, Move, Float)
                                                                    ww1_XpZO
                                                                    ds4_XsW3;
                                                                1# ->
                                                                  case ww14_XpZV of
                                                                  { GHC.Types.F# x6_apZA ->
                                                                  case ww10_apYl of
                                                                  { GHC.Types.F# y7_apZD ->
                                                                  case GHC.Prim.eqFloat#
                                                                         x6_apZA y7_apZD
                                                                  of {
                                                                    __DEFAULT ->
                                                                      GHC.Types.:
                                                                        @ (Piece, Move, Float)
                                                                        ww1_XpZO
                                                                        ds4_XsW3;
                                                                    1# -> ds4_XsW3
                                                                  }
                                                                  }
                                                                  }
                                                              }
                                                              }
                                                              }
                                                          }
                                                          }
                                                          }
                                                          }
                                                          }
                                                      }
                                                      }
                                                      }
                                                  }
                                                  }
                                                  }
                                              }
                                              }
                                              }
                                              }
                                              } } in
                                        case a8_X5jR of {
                                          Black ->
                                            case b2_a5i2 of {
                                              Black -> jump $j1_st0z;
                                              White ->
                                                GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3
                                            };
                                          White ->
                                            case b2_a5i2 of {
                                              Black ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                              White -> jump $j1_st0z
                                            }
                                        } } in
                                  case a7_X5jP of {
                                    Pawn ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        Pawn -> jump $j_st0D
                                      };
                                    Knight ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        Knight -> jump $j_st0D
                                      };
                                    Bishop ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        Bishop -> jump $j_st0D
                                      };
                                    Rook ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        Rook -> jump $j_st0D
                                      };
                                    Queen ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        Queen -> jump $j_st0D
                                      };
                                    King ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZO ds4_XsW3;
                                        King -> jump $j_st0D
                                      }
                                  }
                                  }
                                  }
                              }; } in
                      go_a24t ys_a24y } in
                join {
                  $j_st0D [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                  [LclId[JoinId(0)]]
                  $j_st0D
                    = join {
                        $j1_st0z [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                        [LclId[JoinId(0)]]
                        $j1_st0z
                          = case a3_a5hX of { (ww2_a5iu, ww13_a5iv) ->
                            case b3_a5i3 of { (ww15_a5iA, ww16_a5iB) ->
                            case ww2_a5iu of { GHC.Types.I# x1_a5hr ->
                            case ww15_a5iA of { GHC.Types.I# y1_a5hu ->
                            case GHC.Prim.==# x1_a5hr y1_a5hu of {
                              __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                              1# ->
                                case ww13_a5iv of { GHC.Types.I# x2_X5jv ->
                                case ww16_a5iB of { GHC.Types.I# y2_X5jD ->
                                case GHC.Prim.==# x2_X5jv y2_X5jD of {
                                  __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                                  1# ->
                                    case a4_a5hY of { GHC.Types.I# x3_X5jI ->
                                    case b4_a5i4 of { GHC.Types.I# y3_X5jQ ->
                                    case GHC.Prim.==# x3_X5jI y3_X5jQ of {
                                      __DEFAULT ->
                                        GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                                      1# ->
                                        case ww5_apYc of { (ww18_X5kw, ww19_X5ky) ->
                                        case ww9_apYk of { (ww21_X5kI, ww22_X5kK) ->
                                        case ww18_X5kw of { GHC.Types.I# x4_X5k7 ->
                                        case ww21_X5kI of { GHC.Types.I# y4_X5kf ->
                                        case GHC.Prim.==# x4_X5k7 y4_X5kf of {
                                          __DEFAULT ->
                                            GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                                          1# ->
                                            case ww19_X5ky of { GHC.Types.I# x5_X5kk ->
                                            case ww22_X5kK of { GHC.Types.I# y5_X5ks ->
                                            case GHC.Prim.==# x5_X5kk y5_X5ks of {
                                              __DEFAULT ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                                              1# ->
                                                case ww6_apYd of { GHC.Types.F# x6_apZA ->
                                                case ww10_apYl of { GHC.Types.F# y6_apZD ->
                                                case GHC.Prim.eqFloat# x6_apZA y6_apZD of {
                                                  __DEFAULT ->
                                                    GHC.Types.:
                                                      @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                                                  1# -> ds2_dsTV
                                                }
                                                }
                                                }
                                            }
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                        }
                                    }
                                    }
                                    }
                                }
                                }
                                }
                            }
                            }
                            }
                            }
                            } } in
                      case a2_a5hW of {
                        Black ->
                          case b2_a5i2 of {
                            Black -> jump $j1_st0z;
                            White -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV
                          };
                        White ->
                          case b2_a5i2 of {
                            Black -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                            White -> jump $j1_st0z
                          }
                      } } in
                case a1_a5hV of {
                  Pawn ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      Pawn -> jump $j_st0D
                    };
                  Knight ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      Knight -> jump $j_st0D
                    };
                  Bishop ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      Bishop -> jump $j_st0D
                    };
                  Rook ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      Rook -> jump $j_st0D
                    };
                  Queen ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      Queen -> jump $j_st0D
                    };
                  King ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dsTV;
                      King -> jump $j_st0D
                    }
                }
                }
                }
                }
                }
            } } in
      case ds_dsTM of {
        [] -> jump fail_ssYB GHC.Prim.void#;
        : y_asOl ds1_dsU8 ->
          case ds1_dsU8 of {
            [] -> GHC.Types.[] @ (Piece, Move, Float);
            : ipv_ssVA ipv1_ssVB -> jump fail_ssYB GHC.Prim.void#
          }
      }

Rec {
-- RHS size: {terms: 24, types: 45, coercions: 0, joins: 0/1}
MiddleSearch.findRealBestMiddleMove_$stakeTopMoves [Occ=LoopBreaker]
  :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
     -> GHC.Prim.Int# -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []]
MiddleSearch.findRealBestMiddleMove_$stakeTopMoves
  = \ (sc_sur3
         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
      (sc1_sur2 :: GHC.Prim.Int#) ->
      case sc_sur3 of wild_XA {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_ssWb ipv1_ssWc ->
          case sc1_sur2 of ds_XsUW {
            __DEFAULT ->
              let {
                m_ssYz [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_ssYz = findStrongestMoveFromAll wild_XA } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_ssYz
                (MiddleSearch.findRealBestMiddleMove_$stakeTopMoves
                   (removeMove m_ssYz wild_XA) (GHC.Prim.+# ds_XsUW 1#));
            4# -> GHC.Types.[] @ (Piece, Move, Float)
          }
      }
end Rec }

-- RHS size: {terms: 27, types: 39, coercions: 0, joins: 0/1}
takeTopMoves
  :: Int -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 151 50}]
takeTopMoves
  = \ (n_asOf :: Int) (ds_dsUo :: [(Piece, Move, Float)]) ->
      case ds_dsUo of wild_XA {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_ssWb ipv1_ssWc ->
          case n_asOf of { GHC.Types.I# ds1_dsUD ->
          case ds1_dsUD of ds2_XsUW {
            __DEFAULT ->
              let {
                m_ssYz [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_ssYz = findStrongestMoveFromAll wild_XA } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_ssYz
                (MiddleSearch.findRealBestMiddleMove_$stakeTopMoves
                   (removeMove m_ssYz wild_XA) (GHC.Prim.+# ds2_XsUW 1#));
            4# -> GHC.Types.[] @ (Piece, Move, Float)
          }
          }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/0}
MiddleSearch.$wtotalValDiff [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 101 0}]
MiddleSearch.$wtotalValDiff
  = \ (w_stNt :: Colour) (w1_stNu :: AllPieces) ->
      case Eval.$wtotalVal w_stNt w1_stNu of ww_spEV { __DEFAULT ->
      case Eval.$wtotalVal
             (case w_stNt of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             w1_stNu
      of ww1_XpG6
      { __DEFAULT ->
      GHC.Prim.minusFloat# ww_spEV ww1_XpG6
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalValDiff [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_stNt [Occ=Once] :: Colour)
                 (w1_stNu [Occ=Once] :: AllPieces) ->
                 case MiddleSearch.$wtotalValDiff w_stNt w1_stNu
                 of ww_stNx [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_stNx
                 }}]
totalValDiff
  = \ (w_stNt :: Colour) (w1_stNu :: AllPieces) ->
      case MiddleSearch.$wtotalValDiff w_stNt w1_stNu of ww_stNx
      { __DEFAULT ->
      GHC.Types.F# ww_stNx
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
MiddleSearch.$trModule2 = "MiddleSearch"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.$trModule1 = GHC.Types.TrNameS MiddleSearch.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
MiddleSearch.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
MiddleSearch.$trModule3 = GHC.Types.TrNameS MiddleSearch.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
MiddleSearch.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
MiddleSearch.$trModule
  = GHC.Types.Module MiddleSearch.$trModule3 MiddleSearch.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
checkmate :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
checkmate = GHC.Types.F# 10000.0#

Rec {
-- RHS size: {terms: 28, types: 29, coercions: 0, joins: 0/0}
isCheckmate :: Colour -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 200 10}]
isCheckmate
  = \ (c_asOz :: Colour) (ps_asOA :: AllPieces) ->
      case makeEvalList c_asOz ps_asOA of {
        [] ->
          case findPiece (findKing c_asOz ps_asOA) ps_asOA of {
            [] -> case GHC.List.badHead of wild2_00 { };
            : x_a4SP ds1_a4SQ ->
              case x_a4SP of { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
              Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT ps_asOA
              }
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 36, types: 9, coercions: 0, joins: 0/0}
MiddleSearch.$wevalMove [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> GHC.Prim.Float#
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 0 0 0 0 0] 260 0}]
MiddleSearch.$wevalMove
  = \ (ww_stNG :: PieceType)
      (ww1_stNH :: Colour)
      (ww2_stNI :: Pos)
      (ww3_stNJ :: Movecount)
      (ww4_stNQ :: GHC.Prim.Int#)
      (ww5_stNS :: Int)
      (w_stND :: AllPieces) ->
      case isCheckmate
             (case ww1_stNH of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             (Util.$wexecuteMove
                ww_stNG ww1_stNH ww2_stNI ww3_stNJ ww4_stNQ ww5_stNS w_stND)
      of {
        False ->
          Eval.$wtotalVal
            ww1_stNH
            (Util.$wexecuteMove
               ww_stNG ww1_stNH ww2_stNI ww3_stNJ ww4_stNQ ww5_stNS w_stND);
        True -> 10000.0#
      }

-- RHS size: {terms: 182, types: 152, coercions: 0, joins: 2/6}
makeEvalList [Occ=LoopBreaker]
  :: Colour -> AllPieces -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
makeEvalList
  = \ (c_asOp :: Colour) (ps_asOq :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  case y_a24x of wild1_X1x
                  { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                  let {
                    ds4_dsTI :: [(Piece, Move, Float)]
                    [LclId]
                    ds4_dsTI = go_a24t ys_a24y } in
                  join {
                    $j_st1O [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                    [LclId[JoinId(0)]]
                    $j_st1O
                      = case Util.$wlegalMoves
                               ds1_d529 colour_a3ZX ds2_d52a ds3_d52b ps_asOq
                        of {
                          [] -> ds4_dsTI;
                          : y1_X261 ys1_X263 ->
                            case ds2_d52a of wild3_a5lQ { (a1_a5lR, a2_a5lS) ->
                            case a1_a5lR of { GHC.Types.I# x_a5hr ->
                            case x_a5hr of {
                              __DEFAULT ->
                                GHC.Types.:
                                  @ (Piece, Move, Float)
                                  (wild1_X1x, y1_X261,
                                   case y1_X261 of { (ww1_stNN, ww2_stNS) ->
                                   case ww1_stNN of { GHC.Types.I# ww4_stNQ ->
                                   case MiddleSearch.$wevalMove
                                          ds1_d529
                                          colour_a3ZX
                                          wild3_a5lQ
                                          ds3_d52b
                                          ww4_stNQ
                                          ww2_stNS
                                          ps_asOq
                                   of ww5_stNW
                                   { __DEFAULT ->
                                   GHC.Types.F# ww5_stNW
                                   }
                                   }
                                   })
                                  (letrec {
                                     go1_X27D [Occ=LoopBreaker] :: [Move] -> [(Piece, Move, Float)]
                                     [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                     go1_X27D
                                       = \ (ds5_X25V :: [Move]) ->
                                           case ds5_X25V of {
                                             [] -> ds4_dsTI;
                                             : y2_X27M ys2_X27P ->
                                               GHC.Types.:
                                                 @ (Piece, Move, Float)
                                                 (wild1_X1x, y2_X27M,
                                                  case y2_X27M of { (ww1_stNN, ww2_stNS) ->
                                                  case ww1_stNN of { GHC.Types.I# ww4_stNQ ->
                                                  case MiddleSearch.$wevalMove
                                                         ds1_d529
                                                         colour_a3ZX
                                                         wild3_a5lQ
                                                         ds3_d52b
                                                         ww4_stNQ
                                                         ww2_stNS
                                                         ps_asOq
                                                  of ww5_stNW
                                                  { __DEFAULT ->
                                                  GHC.Types.F# ww5_stNW
                                                  }
                                                  }
                                                  })
                                                 (go1_X27D ys2_X27P)
                                           }; } in
                                   go1_X27D ys1_X263);
                              -1# ->
                                case a2_a5lS of { GHC.Types.I# x1_X5j9 ->
                                case x1_X5j9 of {
                                  __DEFAULT ->
                                    GHC.Types.:
                                      @ (Piece, Move, Float)
                                      (wild1_X1x, y1_X261,
                                       case y1_X261 of { (ww1_stNN, ww2_stNS) ->
                                       case ww1_stNN of { GHC.Types.I# ww4_stNQ ->
                                       case MiddleSearch.$wevalMove
                                              ds1_d529
                                              colour_a3ZX
                                              wild3_a5lQ
                                              ds3_d52b
                                              ww4_stNQ
                                              ww2_stNS
                                              ps_asOq
                                       of ww5_stNW
                                       { __DEFAULT ->
                                       GHC.Types.F# ww5_stNW
                                       }
                                       }
                                       })
                                      (letrec {
                                         go1_X27M [Occ=LoopBreaker]
                                           :: [Move] -> [(Piece, Move, Float)]
                                         [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                         go1_X27M
                                           = \ (ds5_X25V :: [Move]) ->
                                               case ds5_X25V of {
                                                 [] -> ds4_dsTI;
                                                 : y2_X27V ys2_X27Y ->
                                                   GHC.Types.:
                                                     @ (Piece, Move, Float)
                                                     (wild1_X1x, y2_X27V,
                                                      case y2_X27V of { (ww1_stNN, ww2_stNS) ->
                                                      case ww1_stNN of { GHC.Types.I# ww4_stNQ ->
                                                      case MiddleSearch.$wevalMove
                                                             ds1_d529
                                                             colour_a3ZX
                                                             wild3_a5lQ
                                                             ds3_d52b
                                                             ww4_stNQ
                                                             ww2_stNS
                                                             ps_asOq
                                                      of ww5_stNW
                                                      { __DEFAULT ->
                                                      GHC.Types.F# ww5_stNW
                                                      }
                                                      }
                                                      })
                                                     (go1_X27M ys2_X27Y)
                                               }; } in
                                       go1_X27M ys1_X263);
                                  -1# ->
                                    joinrec {
                                      go1_X27N [Occ=LoopBreaker] :: [Move] -> [(Piece, Move, Float)]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X27N (ds5_X25V :: [Move])
                                        = case ds5_X25V of {
                                            [] -> ds4_dsTI;
                                            : y2_X27W ys2_X27Z -> jump go1_X27N ys2_X27Z
                                          }; } in
                                    jump go1_X27N ys1_X263
                                }
                                }
                            }
                            }
                            }
                        } } in
                  case colour_a3ZX of {
                    Black ->
                      case c_asOp of {
                        Black -> jump $j_st1O;
                        White -> ds4_dsTI
                      };
                    White ->
                      case c_asOp of {
                        Black -> ds4_dsTI;
                        White -> jump $j_st1O
                      }
                  }
                  }
              }; } in
      go_a24t ps_asOq
end Rec }

-- RHS size: {terms: 24, types: 14, coercions: 0, joins: 0/0}
evalMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Float
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_stNB [Occ=Once!] :: Piece)
                 (w1_stNC [Occ=Once!] :: Move)
                 (w2_stND [Occ=Once] :: AllPieces) ->
                 case w_stNB of
                 { (ww1_stNG [Occ=Once], ww2_stNH [Occ=Once], ww3_stNI [Occ=Once],
                    ww4_stNJ [Occ=Once]) ->
                 case w1_stNC of { (ww6_stNN [Occ=Once!], ww7_stNS [Occ=Once]) ->
                 case ww6_stNN of { GHC.Types.I# ww9_stNQ [Occ=Once] ->
                 case MiddleSearch.$wevalMove
                        ww1_stNG ww2_stNH ww3_stNI ww4_stNJ ww9_stNQ ww7_stNS w2_stND
                 of ww10_stNW [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww10_stNW
                 }
                 }
                 }
                 }}]
evalMove
  = \ (w_stNB :: Piece) (w1_stNC :: Move) (w2_stND :: AllPieces) ->
      case w_stNB of { (ww1_stNG, ww2_stNH, ww3_stNI, ww4_stNJ) ->
      case w1_stNC of { (ww6_stNN, ww7_stNS) ->
      case ww6_stNN of { GHC.Types.I# ww9_stNQ ->
      case MiddleSearch.$wevalMove
             ww1_stNG ww2_stNH ww3_stNI ww4_stNJ ww9_stNQ ww7_stNS w2_stND
      of ww10_stNW
      { __DEFAULT ->
      GHC.Types.F# ww10_stNW
      }
      }
      }
      }

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
findSingleBestMove :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_asOa [Occ=Once] :: Colour)
                 (ps_asOb [Occ=Once] :: AllPieces) ->
                 findStrongestMoveFromAll (makeEvalList c_asOa ps_asOb)}]
findSingleBestMove
  = \ (c_asOa :: Colour) (ps_asOb :: AllPieces) ->
      findStrongestMoveFromAll (makeEvalList c_asOa ps_asOb)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_ruDb :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_ruDb = GHC.Types.F# 9976.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_ruDc :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl1_ruDc = GHC.Types.F# -10024.0#

Rec {
-- RHS size: {terms: 176, types: 70, coercions: 0, joins: 0/1}
MiddleSearch.$waddTrueEval [InlPrag=NOUSERINLINE[2],
                            Occ=LoopBreaker]
  :: Colour
     -> Colour
     -> GHC.Prim.Int#
     -> Piece
     -> Move
     -> Float
     -> AllPieces
     -> (# Piece, Move, Float #)
[GblId,
 Arity=7,
 Str=<L,U><L,U><S,1*U><L,U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,1*U(U)><L,U>,
 Unf=OtherCon []]
MiddleSearch.$waddTrueEval
  = \ (ww_stO8 :: Colour)
      (ww1_stO9 :: Colour)
      (ww2_stOd :: GHC.Prim.Int#)
      (ww3_stOh :: Piece)
      (ww4_stOi :: Move)
      (ww5_stOj :: Float)
      (w_stO5 :: AllPieces) ->
      let {
        v_ssYx [Dmd=<L,1*U(U)>] :: Float
        [LclId]
        v_ssYx
          = case ww_stO8 of {
              Black ->
                case ww1_stO9 of {
                  Black ->
                    case Eval.$wtotalVal TypeDefs.Black w_stO5 of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# ww6_spEV
                    };
                  White ->
                    case Eval.$wtotalVal TypeDefs.White w_stO5 of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# ww6_spEV)
                    }
                };
              White ->
                case ww1_stO9 of {
                  Black ->
                    case Eval.$wtotalVal TypeDefs.Black w_stO5 of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# ww6_spEV)
                    };
                  White ->
                    case Eval.$wtotalVal TypeDefs.White w_stO5 of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# ww6_spEV
                    }
                }
            } } in
      case ww2_stOd of wild_X1E {
        __DEFAULT ->
          case isCheckmate
                 (case ww_stO8 of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 w_stO5
          of {
            False ->
              case isCheckmate ww_stO8 w_stO5 of {
                False ->
                  MiddleSearch.$waddTrueEval
                    ww_stO8
                    (case ww1_stO9 of {
                       Black -> TypeDefs.White;
                       White -> TypeDefs.Black
                     })
                    (GHC.Prim.+# wild_X1E 1#)
                    ww3_stOh
                    ww4_stOi
                    (GHC.Float.plusFloat v_ssYx ww5_stOj)
                    (case findStrongestMoveFromAll (makeEvalList ww1_stO9 w_stO5) of
                     { (a_asOt, b_asOu, ds_dsTw) ->
                     executeMove a_asOt b_asOu w_stO5
                     });
                True ->
                  (# ww3_stOh, ww4_stOi,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# -10000.0# (GHC.Prim.int2Float# wild_X1E)) #)
              };
            True ->
              (# ww3_stOh, ww4_stOi,
                 GHC.Types.F#
                   (GHC.Prim.minusFloat# 10000.0# (GHC.Prim.int2Float# wild_X1E)) #)
          };
        0# ->
          case ww5_stOj of wild1_apZz { GHC.Types.F# x_apZA ->
          case GHC.Prim.eqFloat# x_apZA 10000.0# of {
            __DEFAULT ->
              MiddleSearch.$waddTrueEval
                ww_stO8
                (case ww1_stO9 of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 })
                1#
                ww3_stOh
                ww4_stOi
                v_ssYx
                (executeMove ww3_stOh ww4_stOi w_stO5);
            1# -> (# ww3_stOh, ww4_stOi, wild1_apZz #)
          }
          };
        24# ->
          case isCheckmate
                 (case ww_stO8 of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 w_stO5
          of {
            False ->
              case isCheckmate ww_stO8 w_stO5 of {
                False ->
                  (# ww3_stOh, ww4_stOi, GHC.Float.plusFloat v_ssYx ww5_stOj #);
                True -> (# ww3_stOh, ww4_stOi, lvl1_ruDc #)
              };
            True -> (# ww3_stOh, ww4_stOi, lvl_ruDb #)
          }
      }
end Rec }

-- RHS size: {terms: 27, types: 36, coercions: 0, joins: 0/0}
addTrueEval [InlPrag=NOUSERINLINE[2]]
  :: (Colour, Colour)
     -> Int -> (Piece, Move, Float) -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=4,
 Str=<S,1*U(U,U)><S(S),1*U(1*U)><S,1*U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),1*U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_stO2 [Occ=Once!] :: (Colour, Colour))
                 (w1_stO3 [Occ=Once!] :: Int)
                 (w2_stO4 [Occ=Once!] :: (Piece, Move, Float))
                 (w3_stO5 [Occ=Once] :: AllPieces) ->
                 case w_stO2 of { (ww1_stO8 [Occ=Once], ww2_stO9 [Occ=Once]) ->
                 case w1_stO3 of { GHC.Types.I# ww4_stOd [Occ=Once] ->
                 case w2_stO4 of
                 { (ww6_stOh [Occ=Once], ww7_stOi [Occ=Once],
                    ww8_stOj [Occ=Once]) ->
                 case MiddleSearch.$waddTrueEval
                        ww1_stO8 ww2_stO9 ww4_stOd ww6_stOh ww7_stOi ww8_stOj w3_stO5
                 of
                 { (# ww10_stP7 [Occ=Once], ww11_stP8 [Occ=Once],
                      ww12_stP9 [Occ=Once] #) ->
                 (ww10_stP7, ww11_stP8, ww12_stP9)
                 }
                 }
                 }
                 }}]
addTrueEval
  = \ (w_stO2 :: (Colour, Colour))
      (w1_stO3 :: Int)
      (w2_stO4 :: (Piece, Move, Float))
      (w3_stO5 :: AllPieces) ->
      case w_stO2 of { (ww1_stO8, ww2_stO9) ->
      case w1_stO3 of { GHC.Types.I# ww4_stOd ->
      case w2_stO4 of { (ww6_stOh, ww7_stOi, ww8_stOj) ->
      case MiddleSearch.$waddTrueEval
             ww1_stO8 ww2_stO9 ww4_stOd ww6_stOh ww7_stOi ww8_stOj w3_stO5
      of
      { (# ww10_stP7, ww11_stP8, ww12_stP9 #) ->
      (ww10_stP7, ww11_stP8, ww12_stP9)
      }
      }
      }
      }

-- RHS size: {terms: 33, types: 59, coercions: 0, joins: 0/1}
getScores :: Colour -> AllPieces -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 230 0}]
getScores
  = \ (c_asNW :: Colour) (ps_asNX :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker]
          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [(Piece, Move, Float)]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  GHC.Types.:
                    @ (Piece, Move, Float)
                    (case y_a24x of { (ww1_stOh, ww2_stOi, ww3_stOj) ->
                     case MiddleSearch.$waddTrueEval
                            c_asNW c_asNW 0# ww1_stOh ww2_stOi ww3_stOj ps_asNX
                     of
                     { (# ww5_stP7, ww6_stP8, ww7_stP9 #) ->
                     (ww5_stP7, ww6_stP8, ww7_stP9)
                     }
                     })
                    (go_a24t ys_a24y)
              }; } in
      go_a24t (makeEvalList c_asNW ps_asNX)

-- RHS size: {terms: 36, types: 59, coercions: 0, joins: 0/1}
findRealBestMiddleMove
  :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 280 0}]
findRealBestMiddleMove
  = \ (c_asNT :: Colour) (ps_asNU :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker]
          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [(Piece, Move, Float)]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  GHC.Types.:
                    @ (Piece, Move, Float)
                    (case y_a24x of { (ww1_stOh, ww2_stOi, ww3_stOj) ->
                     case MiddleSearch.$waddTrueEval
                            c_asNT c_asNT 0# ww1_stOh ww2_stOi ww3_stOj ps_asNU
                     of
                     { (# ww5_stP7, ww6_stP8, ww7_stP9 #) ->
                     (ww5_stP7, ww6_stP8, ww7_stP9)
                     }
                     })
                    (go_a24t ys_a24y)
              }; } in
      findStrongestMoveFromAll
        (go_a24t
           (MiddleSearch.findRealBestMiddleMove_$stakeTopMoves
              (makeEvalList c_asNT ps_asNU) 0#))

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
makeSingleBestMove
  :: (Piece, Move, Float) -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Str=<S(S(SLLL)S(SL)L),1*U(1*U(U,U,U(U(U),U(U)),U(U)),1*U(1*U(U),U(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dsTn [Occ=Once!] :: (Piece, Move, Float))
                 (ps_asOv [Occ=Once] :: AllPieces) ->
                 case ds_dsTn of
                 { (a_asOt [Occ=Once], b_asOu [Occ=Once], _ [Occ=Dead]) ->
                 executeMove a_asOt b_asOu ps_asOv
                 }}]
makeSingleBestMove
  = \ (ds_dsTn :: (Piece, Move, Float)) (ps_asOv :: AllPieces) ->
      case ds_dsTn of { (a_asOt, b_asOu, ds1_dsTw) ->
      executeMove a_asOt b_asOu ps_asOv
      }


------ Local rules for imported ids --------
"SC:takeTopMoves0"
    forall (sc_sur3
              :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
           (sc1_sur2 :: GHC.Prim.Int#).
      takeTopMoves (GHC.Types.I# sc1_sur2) sc_sur3
      = MiddleSearch.findRealBestMiddleMove_$stakeTopMoves
          sc_sur3 sc1_sur2


[12 of 14] Compiling EndSearch        ( EndSearch.hs, EndSearch.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 1,236, types: 1,410, coercions: 0, joins: 13/25}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.findStrongestMoveFromAll4 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.findStrongestMoveFromAll2 = GHC.Types.F# -10000.0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll3 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EndSearch.findStrongestMoveFromAll3
  = (EndSearch.findStrongestMoveFromAll4,
     EndSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.findStrongestMoveFromAll7 = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.findStrongestMoveFromAll8 = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll6 :: (Int, Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EndSearch.findStrongestMoveFromAll6
  = (EndSearch.findStrongestMoveFromAll8,
     EndSearch.findStrongestMoveFromAll7)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll5
  :: (PieceType, Colour, (Int, Int), Int)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
EndSearch.findStrongestMoveFromAll5
  = (TypeDefs.King, TypeDefs.White,
     EndSearch.findStrongestMoveFromAll6,
     EndSearch.findStrongestMoveFromAll4)

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
EndSearch.findStrongestMoveFromAll1
  :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 40}]
EndSearch.findStrongestMoveFromAll1
  = (EndSearch.findStrongestMoveFromAll5,
     EndSearch.findStrongestMoveFromAll3,
     EndSearch.findStrongestMoveFromAll2)

-- RHS size: {terms: 111, types: 227, coercions: 0, joins: 6/6}
findStrongestMoveFromAll
  :: [(Piece, Move, Float)] -> (Piece, Move, Float)
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 322 0}]
findStrongestMoveFromAll
  = \ (xs_avsr :: [(Piece, Move, Float)]) ->
      case xs_avsr of {
        [] -> EndSearch.findStrongestMoveFromAll1;
        : ds1_a5jz ds2_a5jA ->
          joinrec {
            $sgo_sx5B [Occ=LoopBreaker]
              :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)
                 -> [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
                 -> (Piece, Move, Float)
            [LclId[JoinId(2)],
             Arity=2,
             Str=<S(LLS),1*U(U,U,U(U))><L,U>m,
             Unf=OtherCon []]
            $sgo_sx5B (sc_sx5z
                         :: ((PieceType, Colour, (Int, Int), Int), (Int, Int), Float))
                      (sc1_sx5A
                         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
              = join {
                  exit_X1b [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                  [LclId[JoinId(0)], Str=m]
                  exit_X1b = jump go_a24t sc1_sx5A } in
                case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                case f_a3ZR of { GHC.Types.F# x_apYQ ->
                case sc_sx5z of wild3_X39 { (ds6_X5hq, ds7_X5hs, f1_X41C) ->
                case f1_X41C of { GHC.Types.F# y_apYT ->
                case GHC.Prim.leFloat# x_apYQ y_apYT of {
                  __DEFAULT -> jump exit_X1b;
                  1# ->
                    joinrec {
                      go1_X25H [Occ=LoopBreaker]
                        :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                      go1_X25H (ds_X25J :: [(Piece, Move, Float)])
                        = case ds_X25J of {
                            [] -> wild3_X39;
                            : y1_X27x ys_X27A ->
                              case y1_X27x of { (ds8_X5hv, ds9_X5hx, f2_X41H) ->
                              case f2_X41H of { GHC.Types.F# x1_Xq0L ->
                              case GHC.Prim.leFloat# x1_Xq0L y_apYT of {
                                __DEFAULT -> jump exit_X1b;
                                1# -> jump go1_X25H ys_X27A
                              }
                              }
                              }
                          }; } in
                    jump go1_X25H ds2_a5jA
                }
                }
                }
                }
                };
            go_a24t [Occ=LoopBreaker]
              :: [(Piece, Move, Float)] -> (Piece, Move, Float)
            [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
            go_a24t (ds_a24u :: [(Piece, Move, Float)])
              = case ds_a24u of {
                  [] -> GHC.List.badHead @ (Piece, Move, Float);
                  : y_a24x ys_a24y ->
                    join {
                      exit_X1b [Dmd=<L,U(U,U,U)>] :: (Piece, Move, Float)
                      [LclId[JoinId(0)], Str=m]
                      exit_X1b = jump go_a24t ys_a24y } in
                    case ds1_a5jz of { (ds4_d5fH, ds5_d5fI, f_a3ZR) ->
                    case f_a3ZR of { GHC.Types.F# x_apYQ ->
                    case y_a24x of wild4_X39 { (ds6_X5hq, ds7_X5hs, f1_X41C) ->
                    case f1_X41C of { GHC.Types.F# y1_apYT ->
                    case GHC.Prim.leFloat# x_apYQ y1_apYT of {
                      __DEFAULT -> jump exit_X1b;
                      1# ->
                        joinrec {
                          go1_X25H [Occ=LoopBreaker]
                            :: [(Piece, Move, Float)] -> (Piece, Move, Float)
                          [LclId[JoinId(1)], Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
                          go1_X25H (ds8_X25J :: [(Piece, Move, Float)])
                            = case ds8_X25J of {
                                [] -> wild4_X39;
                                : y2_X27x ys1_X27A ->
                                  case y2_X27x of { (ds9_X5hv, ds10_X5hx, f2_X41H) ->
                                  case f2_X41H of { GHC.Types.F# x1_Xq0L ->
                                  case GHC.Prim.leFloat# x1_Xq0L y1_apYT of {
                                    __DEFAULT -> jump exit_X1b;
                                    1# -> jump go1_X25H ys1_X27A
                                  }
                                  }
                                  }
                              }; } in
                        jump go1_X25H ds2_a5jA
                    }
                    }
                    }
                    }
                    }
                }; } in
          jump $sgo_sx5B ds1_a5jz ds2_a5jA
      }

-- RHS size: {terms: 415, types: 457, coercions: 0, joins: 5/8}
removeMove
  :: (Piece, Move, Float)
     -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))><S,U>,
 Unf=OtherCon []]
removeMove
  = \ (x_avsz :: (Piece, Move, Float))
      (ds_dvy6 :: [(Piece, Move, Float)]) ->
      join {
        fail_svCV [Dmd=<L,1*C1(U)>]
          :: GHC.Prim.Void# -> [(Piece, Move, Float)]
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_svCV _ [Occ=Dead, OS=OneShot]
          = case ds_dvy6 of {
              [] -> GHC.Types.[] @ (Piece, Move, Float);
              : y_a24x ys_a24y ->
                case y_a24x of ww3_apYa { (ww4_apYb, ww5_apYc, ww6_apYd) ->
                case x_avsz of { (ww8_apYj, ww9_apYk, ww10_apYl) ->
                case ww4_apYb of { (a1_a5hV, a2_a5hW, a3_a5hX, a4_a5hY) ->
                case ww8_apYj of { (b1_a5i1, b2_a5i2, b3_a5i3, b4_a5i4) ->
                let {
                  ds2_dvyf :: [(Piece, Move, Float)]
                  [LclId]
                  ds2_dvyf
                    = letrec {
                        go_a24t [Occ=LoopBreaker]
                          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
                        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                        go_a24t
                          = \ (ds3_a24u :: [(Piece, Move, Float)]) ->
                              case ds3_a24u of {
                                [] -> GHC.Types.[] @ (Piece, Move, Float);
                                : y1_X268 ys1_X26a ->
                                  case y1_X268 of ww1_XpZP { (ww2_XpZS, ww13_XpZU, ww14_XpZW) ->
                                  case ww2_XpZS of { (a7_X5jQ, a8_X5jS, a9_X5jU, a10_X5jW) ->
                                  let {
                                    ds4_XvAo :: [(Piece, Move, Float)]
                                    [LclId]
                                    ds4_XvAo = go_a24t ys1_X26a } in
                                  join {
                                    $j_svEX [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                    [LclId[JoinId(0)]]
                                    $j_svEX
                                      = join {
                                          $j1_svET [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                                          [LclId[JoinId(0)]]
                                          $j1_svET
                                            = case a9_X5jU of { (ww16_a5iu, ww17_a5iv) ->
                                              case b3_a5i3 of { (ww19_a5iA, ww20_a5iB) ->
                                              case ww16_a5iu of { GHC.Types.I# x1_a5hr ->
                                              case ww19_a5iA of { GHC.Types.I# y2_a5hu ->
                                              case GHC.Prim.==# x1_a5hr y2_a5hu of {
                                                __DEFAULT ->
                                                  GHC.Types.:
                                                    @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                                1# ->
                                                  case ww17_a5iv of { GHC.Types.I# x2_X5jw ->
                                                  case ww20_a5iB of { GHC.Types.I# y3_X5jE ->
                                                  case GHC.Prim.==# x2_X5jw y3_X5jE of {
                                                    __DEFAULT ->
                                                      GHC.Types.:
                                                        @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                                    1# ->
                                                      case a10_X5jW of { GHC.Types.I# x3_X5jJ ->
                                                      case b4_a5i4 of { GHC.Types.I# y4_X5jR ->
                                                      case GHC.Prim.==# x3_X5jJ y4_X5jR of {
                                                        __DEFAULT ->
                                                          GHC.Types.:
                                                            @ (Piece, Move, Float)
                                                            ww1_XpZP
                                                            ds4_XvAo;
                                                        1# ->
                                                          case ww13_XpZU of
                                                          { (ww22_X5kx, ww23_X5kz) ->
                                                          case ww9_apYk of
                                                          { (ww25_X5kJ, ww26_X5kL) ->
                                                          case ww22_X5kx of
                                                          { GHC.Types.I# x4_X5no ->
                                                          case ww25_X5kJ of
                                                          { GHC.Types.I# y5_X5kg ->
                                                          case GHC.Prim.==# x4_X5no y5_X5kg of {
                                                            __DEFAULT ->
                                                              GHC.Types.:
                                                                @ (Piece, Move, Float)
                                                                ww1_XpZP
                                                                ds4_XvAo;
                                                            1# ->
                                                              case ww23_X5kz of
                                                              { GHC.Types.I# x5_X5kl ->
                                                              case ww26_X5kL of
                                                              { GHC.Types.I# y6_X5kt ->
                                                              case GHC.Prim.==# x5_X5kl y6_X5kt of {
                                                                __DEFAULT ->
                                                                  GHC.Types.:
                                                                    @ (Piece, Move, Float)
                                                                    ww1_XpZP
                                                                    ds4_XvAo;
                                                                1# ->
                                                                  case ww14_XpZW of
                                                                  { GHC.Types.F# x6_apZA ->
                                                                  case ww10_apYl of
                                                                  { GHC.Types.F# y7_apZD ->
                                                                  case GHC.Prim.eqFloat#
                                                                         x6_apZA y7_apZD
                                                                  of {
                                                                    __DEFAULT ->
                                                                      GHC.Types.:
                                                                        @ (Piece, Move, Float)
                                                                        ww1_XpZP
                                                                        ds4_XvAo;
                                                                    1# -> ds4_XvAo
                                                                  }
                                                                  }
                                                                  }
                                                              }
                                                              }
                                                              }
                                                          }
                                                          }
                                                          }
                                                          }
                                                          }
                                                      }
                                                      }
                                                      }
                                                  }
                                                  }
                                                  }
                                              }
                                              }
                                              }
                                              }
                                              } } in
                                        case a8_X5jS of {
                                          Black ->
                                            case b2_a5i2 of {
                                              Black -> jump $j1_svET;
                                              White ->
                                                GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo
                                            };
                                          White ->
                                            case b2_a5i2 of {
                                              Black ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                              White -> jump $j1_svET
                                            }
                                        } } in
                                  case a7_X5jQ of {
                                    Pawn ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        Pawn -> jump $j_svEX
                                      };
                                    Knight ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        Knight -> jump $j_svEX
                                      };
                                    Bishop ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        Bishop -> jump $j_svEX
                                      };
                                    Rook ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        Rook -> jump $j_svEX
                                      };
                                    Queen ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        Queen -> jump $j_svEX
                                      };
                                    King ->
                                      case b1_a5i1 of {
                                        __DEFAULT ->
                                          GHC.Types.: @ (Piece, Move, Float) ww1_XpZP ds4_XvAo;
                                        King -> jump $j_svEX
                                      }
                                  }
                                  }
                                  }
                              }; } in
                      go_a24t ys_a24y } in
                join {
                  $j_svEX [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                  [LclId[JoinId(0)]]
                  $j_svEX
                    = join {
                        $j1_svET [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                        [LclId[JoinId(0)]]
                        $j1_svET
                          = case a3_a5hX of { (ww2_a5iu, ww13_a5iv) ->
                            case b3_a5i3 of { (ww15_a5iA, ww16_a5iB) ->
                            case ww2_a5iu of { GHC.Types.I# x1_a5hr ->
                            case ww15_a5iA of { GHC.Types.I# y1_a5hu ->
                            case GHC.Prim.==# x1_a5hr y1_a5hu of {
                              __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                              1# ->
                                case ww13_a5iv of { GHC.Types.I# x2_X5jw ->
                                case ww16_a5iB of { GHC.Types.I# y2_X5jE ->
                                case GHC.Prim.==# x2_X5jw y2_X5jE of {
                                  __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                                  1# ->
                                    case a4_a5hY of { GHC.Types.I# x3_X5jJ ->
                                    case b4_a5i4 of { GHC.Types.I# y3_X5jR ->
                                    case GHC.Prim.==# x3_X5jJ y3_X5jR of {
                                      __DEFAULT ->
                                        GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                                      1# ->
                                        case ww5_apYc of { (ww18_X5kx, ww19_X5kz) ->
                                        case ww9_apYk of { (ww21_X5kJ, ww22_X5kL) ->
                                        case ww18_X5kx of { GHC.Types.I# x4_X5k8 ->
                                        case ww21_X5kJ of { GHC.Types.I# y4_X5kg ->
                                        case GHC.Prim.==# x4_X5k8 y4_X5kg of {
                                          __DEFAULT ->
                                            GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                                          1# ->
                                            case ww19_X5kz of { GHC.Types.I# x5_X5kl ->
                                            case ww22_X5kL of { GHC.Types.I# y5_X5kt ->
                                            case GHC.Prim.==# x5_X5kl y5_X5kt of {
                                              __DEFAULT ->
                                                GHC.Types.:
                                                  @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                                              1# ->
                                                case ww6_apYd of { GHC.Types.F# x6_apZA ->
                                                case ww10_apYl of { GHC.Types.F# y6_apZD ->
                                                case GHC.Prim.eqFloat# x6_apZA y6_apZD of {
                                                  __DEFAULT ->
                                                    GHC.Types.:
                                                      @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                                                  1# -> ds2_dvyf
                                                }
                                                }
                                                }
                                            }
                                            }
                                            }
                                        }
                                        }
                                        }
                                        }
                                        }
                                    }
                                    }
                                    }
                                }
                                }
                                }
                            }
                            }
                            }
                            }
                            } } in
                      case a2_a5hW of {
                        Black ->
                          case b2_a5i2 of {
                            Black -> jump $j1_svET;
                            White -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf
                          };
                        White ->
                          case b2_a5i2 of {
                            Black -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                            White -> jump $j1_svET
                          }
                      } } in
                case a1_a5hV of {
                  Pawn ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      Pawn -> jump $j_svEX
                    };
                  Knight ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      Knight -> jump $j_svEX
                    };
                  Bishop ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      Bishop -> jump $j_svEX
                    };
                  Rook ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      Rook -> jump $j_svEX
                    };
                  Queen ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      Queen -> jump $j_svEX
                    };
                  King ->
                    case b1_a5i1 of {
                      __DEFAULT -> GHC.Types.: @ (Piece, Move, Float) ww3_apYa ds2_dvyf;
                      King -> jump $j_svEX
                    }
                }
                }
                }
                }
                }
            } } in
      case ds_dvy6 of {
        [] -> jump fail_svCV GHC.Prim.void#;
        : y_avsA ds1_dvys ->
          case ds1_dvys of {
            [] -> GHC.Types.[] @ (Piece, Move, Float);
            : ipv_svzU ipv1_svzV -> jump fail_svCV GHC.Prim.void#
          }
      }

Rec {
-- RHS size: {terms: 24, types: 45, coercions: 0, joins: 0/1}
EndSearch.findRealBestEndMove_$stakeTopMoves [Occ=LoopBreaker]
  :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)]
     -> GHC.Prim.Int# -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []]
EndSearch.findRealBestEndMove_$stakeTopMoves
  = \ (sc_sx5n
         :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
      (sc1_sx5m :: GHC.Prim.Int#) ->
      case sc_sx5n of wild_XC {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_svAv ipv1_svAw ->
          case sc1_sx5m of ds_Xvzh {
            __DEFAULT ->
              let {
                m_svCT [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_svCT = findStrongestMoveFromAll wild_XC } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_svCT
                (EndSearch.findRealBestEndMove_$stakeTopMoves
                   (removeMove m_svCT wild_XC) (GHC.Prim.+# ds_Xvzh 1#));
            19# -> GHC.Types.[] @ (Piece, Move, Float)
          }
      }
end Rec }

-- RHS size: {terms: 27, types: 39, coercions: 0, joins: 0/1}
takeTopMoves
  :: Int -> [(Piece, Move, Float)] -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 151 50}]
takeTopMoves
  = \ (n_avsu :: Int) (ds_dvyI :: [(Piece, Move, Float)]) ->
      case ds_dvyI of wild_XC {
        [] -> GHC.Types.[] @ (Piece, Move, Float);
        : ipv_svAv ipv1_svAw ->
          case n_avsu of { GHC.Types.I# ds1_dvyX ->
          case ds1_dvyX of ds2_Xvzh {
            __DEFAULT ->
              let {
                m_svCT [Dmd=<L,U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),U(U))>]
                  :: (Piece, Move, Float)
                [LclId]
                m_svCT = findStrongestMoveFromAll wild_XC } in
              GHC.Types.:
                @ (Piece, Move, Float)
                m_svCT
                (EndSearch.findRealBestEndMove_$stakeTopMoves
                   (removeMove m_svCT wild_XC) (GHC.Prim.+# ds2_Xvzh 1#));
            19# -> GHC.Types.[] @ (Piece, Move, Float)
          }
          }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/0}
EndSearch.$wtotalValDiff [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 101 0}]
EndSearch.$wtotalValDiff
  = \ (w_swrN :: Colour) (w1_swrO :: AllPieces) ->
      case Eval.$wtotalVal w_swrN w1_swrO of ww_spEV { __DEFAULT ->
      case Eval.$wtotalVal
             (case w_swrN of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             w1_swrO
      of ww1_XpG8
      { __DEFAULT ->
      GHC.Prim.minusFloat# ww_spEV ww1_XpG8
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
totalValDiff [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> Float
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_swrN [Occ=Once] :: Colour)
                 (w1_swrO [Occ=Once] :: AllPieces) ->
                 case EndSearch.$wtotalValDiff w_swrN w1_swrO of ww_swrR [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww_swrR
                 }}]
totalValDiff
  = \ (w_swrN :: Colour) (w1_swrO :: AllPieces) ->
      case EndSearch.$wtotalValDiff w_swrN w1_swrO of ww_swrR
      { __DEFAULT ->
      GHC.Types.F# ww_swrR
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EndSearch.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
EndSearch.$trModule2 = "EndSearch"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.$trModule1 = GHC.Types.TrNameS EndSearch.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
EndSearch.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
EndSearch.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
EndSearch.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
EndSearch.$trModule3 = GHC.Types.TrNameS EndSearch.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
EndSearch.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
EndSearch.$trModule
  = GHC.Types.Module EndSearch.$trModule3 EndSearch.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
futureCheckmate :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
futureCheckmate = GHC.Types.F# 250.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
checkmate :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
checkmate = GHC.Types.F# 10000.0#

Rec {
-- RHS size: {terms: 28, types: 29, coercions: 0, joins: 0/0}
isCheckmate :: Colour -> AllPieces -> Bool
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 200 10}]
isCheckmate
  = \ (c_avsO :: Colour) (ps_avsP :: AllPieces) ->
      case makeEvalList c_avsO ps_avsP of {
        [] ->
          case findPiece (findKing c_avsO ps_avsP) ps_avsP of {
            [] -> case GHC.List.badHead of wild2_00 { };
            : x_a4SP ds1_a4SQ ->
              case x_a4SP of { (ww1_s8sQ, ww2_s8sR, ww3_s8sS, ww4_s8sT) ->
              Util.$wisKingInCheck ww1_s8sQ ww2_s8sR ww3_s8sS ww4_s8sT ps_avsP
              }
          };
        : ds1_a5jz ds2_a5jA -> GHC.Types.False
      }

-- RHS size: {terms: 36, types: 9, coercions: 0, joins: 0/0}
EndSearch.$wevalMove [InlPrag=NOUSERINLINE[2]]
  :: PieceType
     -> Colour
     -> Pos
     -> Movecount
     -> GHC.Prim.Int#
     -> Int
     -> AllPieces
     -> GHC.Prim.Float#
[GblId,
 Arity=7,
 Str=<S,U><L,U><L,U(U(U),U(U))><L,U(U)><L,U><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 0 0 0 0 0] 260 0}]
EndSearch.$wevalMove
  = \ (ww_sws0 :: PieceType)
      (ww1_sws1 :: Colour)
      (ww2_sws2 :: Pos)
      (ww3_sws3 :: Movecount)
      (ww4_swsa :: GHC.Prim.Int#)
      (ww5_swsc :: Int)
      (w_swrX :: AllPieces) ->
      case isCheckmate
             (case ww1_sws1 of {
                Black -> TypeDefs.White;
                White -> TypeDefs.Black
              })
             (Util.$wexecuteMove
                ww_sws0 ww1_sws1 ww2_sws2 ww3_sws3 ww4_swsa ww5_swsc w_swrX)
      of {
        False ->
          Eval.$wtotalVal
            ww1_sws1
            (Util.$wexecuteMove
               ww_sws0 ww1_sws1 ww2_sws2 ww3_sws3 ww4_swsa ww5_swsc w_swrX);
        True -> 10000.0#
      }

-- RHS size: {terms: 182, types: 152, coercions: 0, joins: 2/6}
makeEvalList [Occ=LoopBreaker]
  :: Colour -> AllPieces -> [(Piece, Move, Float)]
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []]
makeEvalList
  = \ (c_avsE :: Colour) (ps_avsF :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker] :: [Piece] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [Piece]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  case y_a24x of wild1_X1x
                  { (ds1_d529, colour_a3ZX, ds2_d52a, ds3_d52b) ->
                  let {
                    ds4_dvy2 :: [(Piece, Move, Float)]
                    [LclId]
                    ds4_dvy2 = go_a24t ys_a24y } in
                  join {
                    $j_svG8 [Dmd=<L,1*U>] :: [(Piece, Move, Float)]
                    [LclId[JoinId(0)]]
                    $j_svG8
                      = case Util.$wlegalMoves
                               ds1_d529 colour_a3ZX ds2_d52a ds3_d52b ps_avsF
                        of {
                          [] -> ds4_dvy2;
                          : y1_X263 ys1_X265 ->
                            case ds2_d52a of wild3_a5lQ { (a1_a5lR, a2_a5lS) ->
                            case a1_a5lR of { GHC.Types.I# x_a5hr ->
                            case x_a5hr of {
                              __DEFAULT ->
                                GHC.Types.:
                                  @ (Piece, Move, Float)
                                  (wild1_X1x, y1_X263,
                                   case y1_X263 of { (ww1_sws7, ww2_swsc) ->
                                   case ww1_sws7 of { GHC.Types.I# ww4_swsa ->
                                   case EndSearch.$wevalMove
                                          ds1_d529
                                          colour_a3ZX
                                          wild3_a5lQ
                                          ds3_d52b
                                          ww4_swsa
                                          ww2_swsc
                                          ps_avsF
                                   of ww5_swsg
                                   { __DEFAULT ->
                                   GHC.Types.F# ww5_swsg
                                   }
                                   }
                                   })
                                  (letrec {
                                     go1_X27H [Occ=LoopBreaker] :: [Move] -> [(Piece, Move, Float)]
                                     [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                     go1_X27H
                                       = \ (ds5_X25X :: [Move]) ->
                                           case ds5_X25X of {
                                             [] -> ds4_dvy2;
                                             : y2_X27Q ys2_X27T ->
                                               GHC.Types.:
                                                 @ (Piece, Move, Float)
                                                 (wild1_X1x, y2_X27Q,
                                                  case y2_X27Q of { (ww1_sws7, ww2_swsc) ->
                                                  case ww1_sws7 of { GHC.Types.I# ww4_swsa ->
                                                  case EndSearch.$wevalMove
                                                         ds1_d529
                                                         colour_a3ZX
                                                         wild3_a5lQ
                                                         ds3_d52b
                                                         ww4_swsa
                                                         ww2_swsc
                                                         ps_avsF
                                                  of ww5_swsg
                                                  { __DEFAULT ->
                                                  GHC.Types.F# ww5_swsg
                                                  }
                                                  }
                                                  })
                                                 (go1_X27H ys2_X27T)
                                           }; } in
                                   go1_X27H ys1_X265);
                              -1# ->
                                case a2_a5lS of { GHC.Types.I# x1_X5jb ->
                                case x1_X5jb of {
                                  __DEFAULT ->
                                    GHC.Types.:
                                      @ (Piece, Move, Float)
                                      (wild1_X1x, y1_X263,
                                       case y1_X263 of { (ww1_sws7, ww2_swsc) ->
                                       case ww1_sws7 of { GHC.Types.I# ww4_swsa ->
                                       case EndSearch.$wevalMove
                                              ds1_d529
                                              colour_a3ZX
                                              wild3_a5lQ
                                              ds3_d52b
                                              ww4_swsa
                                              ww2_swsc
                                              ps_avsF
                                       of ww5_swsg
                                       { __DEFAULT ->
                                       GHC.Types.F# ww5_swsg
                                       }
                                       }
                                       })
                                      (letrec {
                                         go1_X27Q [Occ=LoopBreaker]
                                           :: [Move] -> [(Piece, Move, Float)]
                                         [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                         go1_X27Q
                                           = \ (ds5_X25X :: [Move]) ->
                                               case ds5_X25X of {
                                                 [] -> ds4_dvy2;
                                                 : y2_X27Z ys2_X282 ->
                                                   GHC.Types.:
                                                     @ (Piece, Move, Float)
                                                     (wild1_X1x, y2_X27Z,
                                                      case y2_X27Z of { (ww1_sws7, ww2_swsc) ->
                                                      case ww1_sws7 of { GHC.Types.I# ww4_swsa ->
                                                      case EndSearch.$wevalMove
                                                             ds1_d529
                                                             colour_a3ZX
                                                             wild3_a5lQ
                                                             ds3_d52b
                                                             ww4_swsa
                                                             ww2_swsc
                                                             ps_avsF
                                                      of ww5_swsg
                                                      { __DEFAULT ->
                                                      GHC.Types.F# ww5_swsg
                                                      }
                                                      }
                                                      })
                                                     (go1_X27Q ys2_X282)
                                               }; } in
                                       go1_X27Q ys1_X265);
                                  -1# ->
                                    joinrec {
                                      go1_X27R [Occ=LoopBreaker] :: [Move] -> [(Piece, Move, Float)]
                                      [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                      go1_X27R (ds5_X25X :: [Move])
                                        = case ds5_X25X of {
                                            [] -> ds4_dvy2;
                                            : y2_X280 ys2_X283 -> jump go1_X27R ys2_X283
                                          }; } in
                                    jump go1_X27R ys1_X265
                                }
                                }
                            }
                            }
                            }
                        } } in
                  case colour_a3ZX of {
                    Black ->
                      case c_avsE of {
                        Black -> jump $j_svG8;
                        White -> ds4_dvy2
                      };
                    White ->
                      case c_avsE of {
                        Black -> ds4_dvy2;
                        White -> jump $j_svG8
                      }
                  }
                  }
              }; } in
      go_a24t ps_avsF
end Rec }

-- RHS size: {terms: 24, types: 14, coercions: 0, joins: 0/0}
evalMove [InlPrag=NOUSERINLINE[2]]
  :: Piece -> Move -> AllPieces -> Float
[GblId,
 Arity=3,
 Str=<S(SLLL),1*U(U,U,U(U(U),U(U)),U(U))><S(SL),1*U(1*U(U),U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_swrV [Occ=Once!] :: Piece)
                 (w1_swrW [Occ=Once!] :: Move)
                 (w2_swrX [Occ=Once] :: AllPieces) ->
                 case w_swrV of
                 { (ww1_sws0 [Occ=Once], ww2_sws1 [Occ=Once], ww3_sws2 [Occ=Once],
                    ww4_sws3 [Occ=Once]) ->
                 case w1_swrW of { (ww6_sws7 [Occ=Once!], ww7_swsc [Occ=Once]) ->
                 case ww6_sws7 of { GHC.Types.I# ww9_swsa [Occ=Once] ->
                 case EndSearch.$wevalMove
                        ww1_sws0 ww2_sws1 ww3_sws2 ww4_sws3 ww9_swsa ww7_swsc w2_swrX
                 of ww10_swsg [Occ=Once]
                 { __DEFAULT ->
                 GHC.Types.F# ww10_swsg
                 }
                 }
                 }
                 }}]
evalMove
  = \ (w_swrV :: Piece) (w1_swrW :: Move) (w2_swrX :: AllPieces) ->
      case w_swrV of { (ww1_sws0, ww2_sws1, ww3_sws2, ww4_sws3) ->
      case w1_swrW of { (ww6_sws7, ww7_swsc) ->
      case ww6_sws7 of { GHC.Types.I# ww9_swsa ->
      case EndSearch.$wevalMove
             ww1_sws0 ww2_sws1 ww3_sws2 ww4_sws3 ww9_swsa ww7_swsc w2_swrX
      of ww10_swsg
      { __DEFAULT ->
      GHC.Types.F# ww10_swsg
      }
      }
      }
      }

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
findSingleBestMove :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_avsp [Occ=Once] :: Colour)
                 (ps_avsq [Occ=Once] :: AllPieces) ->
                 findStrongestMoveFromAll (makeEvalList c_avsp ps_avsq)}]
findSingleBestMove
  = \ (c_avsp :: Colour) (ps_avsq :: AllPieces) ->
      findStrongestMoveFromAll (makeEvalList c_avsp ps_avsq)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rxhv :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rxhv = GHC.Types.F# 200.0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_rxhw :: Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl1_rxhw = GHC.Types.F# -300.0#

Rec {
-- RHS size: {terms: 176, types: 70, coercions: 0, joins: 0/1}
EndSearch.$waddTrueEval [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]
  :: Colour
     -> Colour
     -> GHC.Prim.Int#
     -> Piece
     -> Move
     -> Float
     -> AllPieces
     -> (# Piece, Move, Float #)
[GblId,
 Arity=7,
 Str=<L,U><L,U><S,1*U><L,U(U,U,U(U(U),U(U)),U(U))><L,U(U(U),U(U))><L,1*U(U)><L,U>,
 Unf=OtherCon []]
EndSearch.$waddTrueEval
  = \ (ww_swss :: Colour)
      (ww1_swst :: Colour)
      (ww2_swsx :: GHC.Prim.Int#)
      (ww3_swsB :: Piece)
      (ww4_swsC :: Move)
      (ww5_swsD :: Float)
      (w_swsp :: AllPieces) ->
      let {
        v_svCR [Dmd=<L,1*U(U)>] :: Float
        [LclId]
        v_svCR
          = case ww_swss of {
              Black ->
                case ww1_swst of {
                  Black ->
                    case Eval.$wtotalVal TypeDefs.Black w_swsp of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# ww6_spEV
                    };
                  White ->
                    case Eval.$wtotalVal TypeDefs.White w_swsp of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# ww6_spEV)
                    }
                };
              White ->
                case ww1_swst of {
                  Black ->
                    case Eval.$wtotalVal TypeDefs.Black w_swsp of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# (GHC.Prim.minusFloat# 0.0# ww6_spEV)
                    };
                  White ->
                    case Eval.$wtotalVal TypeDefs.White w_swsp of ww6_spEV
                    { __DEFAULT ->
                    GHC.Types.F# ww6_spEV
                    }
                }
            } } in
      case ww2_swsx of wild_X1G {
        __DEFAULT ->
          case isCheckmate
                 (case ww_swss of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 w_swsp
          of {
            False ->
              case isCheckmate ww_swss w_swsp of {
                False ->
                  EndSearch.$waddTrueEval
                    ww_swss
                    (case ww1_swst of {
                       Black -> TypeDefs.White;
                       White -> TypeDefs.Black
                     })
                    (GHC.Prim.+# wild_X1G 1#)
                    ww3_swsB
                    ww4_swsC
                    (GHC.Float.plusFloat v_svCR ww5_swsD)
                    (case findStrongestMoveFromAll (makeEvalList ww1_swst w_swsp) of
                     { (a_avsI, b_avsJ, ds_dvxQ) ->
                     executeMove a_avsI b_avsJ w_swsp
                     });
                True ->
                  (# ww3_swsB, ww4_swsC,
                     GHC.Types.F#
                       (GHC.Prim.minusFloat# -250.0# (GHC.Prim.int2Float# wild_X1G)) #)
              };
            True ->
              (# ww3_swsB, ww4_swsC,
                 GHC.Types.F#
                   (GHC.Prim.minusFloat# 250.0# (GHC.Prim.int2Float# wild_X1G)) #)
          };
        0# ->
          case ww5_swsD of { GHC.Types.F# x_apZA ->
          case GHC.Prim.eqFloat# x_apZA 10000.0# of {
            __DEFAULT ->
              EndSearch.$waddTrueEval
                ww_swss
                (case ww1_swst of {
                   Black -> TypeDefs.White;
                   White -> TypeDefs.Black
                 })
                1#
                ww3_swsB
                ww4_swsC
                v_svCR
                (executeMove ww3_swsB ww4_swsC w_swsp);
            1# -> (# ww3_swsB, ww4_swsC, checkmate #)
          }
          };
        50# ->
          case isCheckmate
                 (case ww_swss of {
                    Black -> TypeDefs.White;
                    White -> TypeDefs.Black
                  })
                 w_swsp
          of {
            False ->
              case isCheckmate ww_swss w_swsp of {
                False ->
                  (# ww3_swsB, ww4_swsC, GHC.Float.plusFloat v_svCR ww5_swsD #);
                True -> (# ww3_swsB, ww4_swsC, lvl1_rxhw #)
              };
            True -> (# ww3_swsB, ww4_swsC, lvl_rxhv #)
          }
      }
end Rec }

-- RHS size: {terms: 27, types: 36, coercions: 0, joins: 0/0}
addTrueEval [InlPrag=NOUSERINLINE[2]]
  :: (Colour, Colour)
     -> Int -> (Piece, Move, Float) -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=4,
 Str=<S,1*U(U,U)><S(S),1*U(1*U)><S,1*U(U(U,U,U(U(U),U(U)),U(U)),U(U(U),U(U)),1*U(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_swsm [Occ=Once!] :: (Colour, Colour))
                 (w1_swsn [Occ=Once!] :: Int)
                 (w2_swso [Occ=Once!] :: (Piece, Move, Float))
                 (w3_swsp [Occ=Once] :: AllPieces) ->
                 case w_swsm of { (ww1_swss [Occ=Once], ww2_swst [Occ=Once]) ->
                 case w1_swsn of { GHC.Types.I# ww4_swsx [Occ=Once] ->
                 case w2_swso of
                 { (ww6_swsB [Occ=Once], ww7_swsC [Occ=Once],
                    ww8_swsD [Occ=Once]) ->
                 case EndSearch.$waddTrueEval
                        ww1_swss ww2_swst ww4_swsx ww6_swsB ww7_swsC ww8_swsD w3_swsp
                 of
                 { (# ww10_swtr [Occ=Once], ww11_swts [Occ=Once],
                      ww12_swtt [Occ=Once] #) ->
                 (ww10_swtr, ww11_swts, ww12_swtt)
                 }
                 }
                 }
                 }}]
addTrueEval
  = \ (w_swsm :: (Colour, Colour))
      (w1_swsn :: Int)
      (w2_swso :: (Piece, Move, Float))
      (w3_swsp :: AllPieces) ->
      case w_swsm of { (ww1_swss, ww2_swst) ->
      case w1_swsn of { GHC.Types.I# ww4_swsx ->
      case w2_swso of { (ww6_swsB, ww7_swsC, ww8_swsD) ->
      case EndSearch.$waddTrueEval
             ww1_swss ww2_swst ww4_swsx ww6_swsB ww7_swsC ww8_swsD w3_swsp
      of
      { (# ww10_swtr, ww11_swts, ww12_swtt #) ->
      (ww10_swtr, ww11_swts, ww12_swtt)
      }
      }
      }
      }

-- RHS size: {terms: 33, types: 59, coercions: 0, joins: 0/1}
getScores :: Colour -> AllPieces -> [(Piece, Move, Float)]
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 230 0}]
getScores
  = \ (c_avsb :: Colour) (ps_avsc :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker]
          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [(Piece, Move, Float)]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  GHC.Types.:
                    @ (Piece, Move, Float)
                    (case y_a24x of { (ww1_swsB, ww2_swsC, ww3_swsD) ->
                     case EndSearch.$waddTrueEval
                            c_avsb c_avsb 0# ww1_swsB ww2_swsC ww3_swsD ps_avsc
                     of
                     { (# ww5_swtr, ww6_swts, ww7_swtt #) ->
                     (ww5_swtr, ww6_swts, ww7_swtt)
                     }
                     })
                    (go_a24t ys_a24y)
              }; } in
      go_a24t (makeEvalList c_avsb ps_avsc)

-- RHS size: {terms: 36, types: 59, coercions: 0, joins: 0/1}
findRealBestEndMove :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 280 0}]
findRealBestEndMove
  = \ (c_avs8 :: Colour) (ps_avs9 :: AllPieces) ->
      letrec {
        go_a24t [Occ=LoopBreaker]
          :: [(Piece, Move, Float)] -> [(Piece, Move, Float)]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_a24t
          = \ (ds_a24u :: [(Piece, Move, Float)]) ->
              case ds_a24u of {
                [] -> GHC.Types.[] @ (Piece, Move, Float);
                : y_a24x ys_a24y ->
                  GHC.Types.:
                    @ (Piece, Move, Float)
                    (case y_a24x of { (ww1_swsB, ww2_swsC, ww3_swsD) ->
                     case EndSearch.$waddTrueEval
                            c_avs8 c_avs8 0# ww1_swsB ww2_swsC ww3_swsD ps_avs9
                     of
                     { (# ww5_swtr, ww6_swts, ww7_swtt #) ->
                     (ww5_swtr, ww6_swts, ww7_swtt)
                     }
                     })
                    (go_a24t ys_a24y)
              }; } in
      findStrongestMoveFromAll
        (go_a24t
           (EndSearch.findRealBestEndMove_$stakeTopMoves
              (makeEvalList c_avs8 ps_avs9) 0#))

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
makeSingleBestMove
  :: (Piece, Move, Float) -> AllPieces -> AllPieces
[GblId,
 Arity=2,
 Str=<S(S(SLLL)S(SL)L),1*U(1*U(U,U,U(U(U),U(U)),U(U)),1*U(1*U(U),U(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dvxH [Occ=Once!] :: (Piece, Move, Float))
                 (ps_avsK [Occ=Once] :: AllPieces) ->
                 case ds_dvxH of
                 { (a_avsI [Occ=Once], b_avsJ [Occ=Once], _ [Occ=Dead]) ->
                 executeMove a_avsI b_avsJ ps_avsK
                 }}]
makeSingleBestMove
  = \ (ds_dvxH :: (Piece, Move, Float)) (ps_avsK :: AllPieces) ->
      case ds_dvxH of { (a_avsI, b_avsJ, ds1_dvxQ) ->
      executeMove a_avsI b_avsJ ps_avsK
      }


------ Local rules for imported ids --------
"SC:takeTopMoves0"
    forall (sc_sx5n
              :: [((PieceType, Colour, (Int, Int), Int), (Int, Int), Float)])
           (sc1_sx5m :: GHC.Prim.Int#).
      takeTopMoves (GHC.Types.I# sc1_sx5m) sc_sx5n
      = EndSearch.findRealBestEndMove_$stakeTopMoves sc_sx5n sc1_sx5m


[13 of 14] Compiling Search           ( Search.hs, Search.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 112, types: 107, coercions: 0, joins: 1/1}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Search.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Search.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Search.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Search.$trModule3 = GHC.Types.TrNameS Search.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Search.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Search.$trModule2 = "Search"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Search.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Search.$trModule1 = GHC.Types.TrNameS Search.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Search.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Search.$trModule
  = GHC.Types.Module Search.$trModule3 Search.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Search.findRealBestMove1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Search.findRealBestMove1 = GHC.Types.I# 3#

-- RHS size: {terms: 82, types: 71, coercions: 0, joins: 1/1}
Search.$wfindRealBestMove [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> (# Piece, Move, Float #)
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 388 40}]
Search.$wfindRealBestMove
  = \ (w_sy7I :: Colour) (w1_sy7J :: AllPieces) ->
      case Util.getGamePoint_go w1_sy7J Util.allPiecesMoved1 of
      { GHC.Types.I# x_a5ox ->
      join {
        $j_sy74 [Dmd=<L,1*U(U,U,U)>] :: (# Piece, Move, Float #)
        [LclId[JoinId(0)]]
        $j_sy74
          = case GHC.Prim.<=# x_a5ox 6# of {
              __DEFAULT ->
                case Util.allPiecesMoved_go w1_sy7J Util.allPiecesMoved1 of
                { GHC.Types.I# x1_a5nX ->
                case GHC.Prim.>=# x1_a5nX 16# of {
                  __DEFAULT ->
                    case findRealBestEndMove w_sy7I w1_sy7J of
                    { (ww1_sy7O, ww2_sy7P, ww3_sy7Q) ->
                    (# ww1_sy7O, ww2_sy7P, ww3_sy7Q #)
                    };
                  1# ->
                    case openingMoveWrapper Search.findRealBestMove1 w_sy7I w1_sy7J of
                    { (ww1_sy7O, ww2_sy7P, ww3_sy7Q) ->
                    (# ww1_sy7O, ww2_sy7P, ww3_sy7Q #)
                    }
                }
                };
              1# ->
                case findRealBestEndMove w_sy7I w1_sy7J of
                { (ww1_sy7O, ww2_sy7P, ww3_sy7Q) ->
                (# ww1_sy7O, ww2_sy7P, ww3_sy7Q #)
                }
            } } in
      case GHC.Prim.<=# x_a5ox 6# of {
        __DEFAULT ->
          case Util.allPiecesMoved_go w1_sy7J Util.allPiecesMoved1 of
          { GHC.Types.I# x1_a5nX ->
          case GHC.Prim.>=# x1_a5nX 16# of {
            __DEFAULT ->
              case openingMoveWrapper Search.findRealBestMove1 w_sy7I w1_sy7J of
              { (ww1_sy7O, ww2_sy7P, ww3_sy7Q) ->
              (# ww1_sy7O, ww2_sy7P, ww3_sy7Q #)
              };
            1# -> jump $j_sy74
          }
          };
        1# -> jump $j_sy74
      }
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
findRealBestMove [InlPrag=NOUSERINLINE[2]]
  :: Colour -> AllPieces -> (Piece, Move, Float)
[GblId,
 Arity=2,
 Str=<L,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sy7I [Occ=Once] :: Colour)
                 (w1_sy7J [Occ=Once] :: AllPieces) ->
                 case Search.$wfindRealBestMove w_sy7I w1_sy7J of
                 { (# ww1_sy7O [Occ=Once], ww2_sy7P [Occ=Once],
                      ww3_sy7Q [Occ=Once] #) ->
                 (ww1_sy7O, ww2_sy7P, ww3_sy7Q)
                 }}]
findRealBestMove
  = \ (w_sy7I :: Colour) (w1_sy7J :: AllPieces) ->
      case Search.$wfindRealBestMove w_sy7I w1_sy7J of
      { (# ww1_sy7O, ww2_sy7P, ww3_sy7Q #) ->
      (ww1_sy7O, ww2_sy7P, ww3_sy7Q)
      }



[14 of 14] Compiling Main             ( UserSelfplay.hs, UserSelfplay.o )

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 176, types: 208, coercions: 33, joins: 0/0}

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
lvl_ryNm :: Text.ParserCombinators.ReadP.P Int
[GblId]
lvl_ryNm
  = GHC.Read.$fReadInt_$sreadNumber
      GHC.Read.$fReadInt2
      Text.ParserCombinators.ReadPrec.minPrec
      @ Int
      (Text.Read.readEither7 @ Int)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Main.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Main.$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Main.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Main.$trModule3 = GHC.Types.TrNameS Main.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Main.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Main.$trModule2 = "Main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Main.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Main.$trModule1 = GHC.Types.TrNameS Main.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Main.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module Main.$trModule3 Main.$trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_ryNn :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_ryNn = "\n"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_ryNo :: [Char]
[GblId]
lvl2_ryNo = GHC.CString.unpackCString# lvl1_ryNn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl3_ryNp :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl3_ryNp = "Your turn:\n"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl4_ryNq :: [Char]
[GblId]
lvl4_ryNq = GHC.CString.unpackCString# lvl3_ryNp

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl5_ryNr :: Int
[GblId, Str=b]
lvl5_ryNr
  = errorWithoutStackTrace
      @ 'GHC.Types.LiftedRep @ Int Text.Read.readEither2

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl6_ryNs :: Int
[GblId, Str=b]
lvl6_ryNs
  = errorWithoutStackTrace
      @ 'GHC.Types.LiftedRep @ Int Text.Read.readEither5

Rec {
-- RHS size: {terms: 130, types: 151, coercions: 24, joins: 0/0}
Main.main2 [Occ=LoopBreaker]
  :: AllPieces
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []]
Main.main2
  = \ (ps_aybk :: AllPieces)
      (s_aj53 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case ((GHC.IO.Handle.Text.hPutStr'
               stdout lvl2_ryNo GHC.Types.False)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
             s_aj53
      of
      { (# ipv_aj55, ipv1_aj56 #) ->
      case UI.$wprintBoard -1# ps_aybk ipv_aj55 of
      { (# ipv2_Xj5p, ipv3_Xj5r #) ->
      case ((GHC.IO.Handle.Text.hPutStr'
               stdout lvl4_ryNq GHC.Types.False)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))))
             ipv2_Xj5p
      of
      { (# ipv4_Xj5u, ipv5_Xj5w #) ->
      case GHC.IO.Handle.Internals.wantReadableHandle_1
             @ String
             GHC.IO.Handle.Text.hGetLine4
             stdin
             (GHC.IO.Handle.Text.hGetLine2
              `cast` (<GHC.IO.Handle.Types.Handle__>_R
                      ->_R Sym (GHC.Types.N:IO[0] <String>_R)
                      :: (GHC.IO.Handle.Types.Handle__
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, String #))
                         ~R# (GHC.IO.Handle.Types.Handle__ -> IO String)))
             ipv4_Xj5u
      of
      { (# ipv6_ayfP, ipv7_ayfQ #) ->
      case GHC.IO.Handle.Internals.wantReadableHandle_1
             @ String
             GHC.IO.Handle.Text.hGetLine4
             stdin
             (GHC.IO.Handle.Text.hGetLine2
              `cast` (<GHC.IO.Handle.Types.Handle__>_R
                      ->_R Sym (GHC.Types.N:IO[0] <String>_R)
                      :: (GHC.IO.Handle.Types.Handle__
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, String #))
                         ~R# (GHC.IO.Handle.Types.Handle__ -> IO String)))
             ipv6_ayfP
      of
      { (# ipv8_Xygp, ipv9_Xygr #) ->
      case GHC.IO.Handle.Internals.wantReadableHandle_1
             @ String
             GHC.IO.Handle.Text.hGetLine4
             stdin
             (GHC.IO.Handle.Text.hGetLine2
              `cast` (<GHC.IO.Handle.Types.Handle__>_R
                      ->_R Sym (GHC.Types.N:IO[0] <String>_R)
                      :: (GHC.IO.Handle.Types.Handle__
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, String #))
                         ~R# (GHC.IO.Handle.Types.Handle__ -> IO String)))
             ipv8_Xygp
      of
      { (# ipv10_Xygv, ipv11_Xygx #) ->
      case GHC.IO.Handle.Internals.wantReadableHandle_1
             @ String
             GHC.IO.Handle.Text.hGetLine4
             stdin
             (GHC.IO.Handle.Text.hGetLine2
              `cast` (<GHC.IO.Handle.Types.Handle__>_R
                      ->_R Sym (GHC.Types.N:IO[0] <String>_R)
                      :: (GHC.IO.Handle.Types.Handle__
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, String #))
                         ~R# (GHC.IO.Handle.Types.Handle__ -> IO String)))
             ipv10_Xygv
      of
      { (# ipv12_XygB, ipv13_XygD #) ->
      Main.main2
        (case findPiece
                (case Text.Read.readEither8
                        @ Int (Text.ParserCombinators.ReadP.run @ Int lvl_ryNm ipv7_ayfQ)
                 of {
                   [] -> lvl6_ryNs;
                   : x_ayDZ ds_ayE0 ->
                     case ds_ayE0 of {
                       [] -> x_ayDZ;
                       : ipv14_ayEd ipv15_ayEe -> lvl5_ryNr
                     }
                 },
                 case Text.Read.readEither8
                        @ Int (Text.ParserCombinators.ReadP.run @ Int lvl_ryNm ipv9_Xygr)
                 of {
                   [] -> lvl6_ryNs;
                   : x_ayDZ ds_ayE0 ->
                     case ds_ayE0 of {
                       [] -> x_ayDZ;
                       : ipv14_ayEd ipv15_ayEe -> lvl5_ryNr
                     }
                 })
                ps_aybk
         of {
           [] -> case GHC.List.badHead of wild1_00 { };
           : x_a4SP ds8_a4SQ ->
             case x_a4SP of { (ww1_s8tS, ww2_s8tT, ww3_s8tU, ww4_s8tV) ->
             case Text.Read.readEither8
                    @ Int (Text.ParserCombinators.ReadP.run @ Int lvl_ryNm ipv11_Xygx)
             of {
               [] -> case lvl6_ryNs of wild2_00 { };
               : x1_ayDZ ds_ayE0 ->
                 case ds_ayE0 of {
                   [] ->
                     case x1_ayDZ of { GHC.Types.I# ww9_s8u2 ->
                     Util.$wexecuteMove
                       ww1_s8tS
                       ww2_s8tT
                       ww3_s8tU
                       ww4_s8tV
                       ww9_s8u2
                       (case Text.Read.readEither8
                               @ Int (Text.ParserCombinators.ReadP.run @ Int lvl_ryNm ipv13_XygD)
                        of {
                          [] -> lvl6_ryNs;
                          : x2_XyFl ds9_XyFn ->
                            case ds9_XyFn of {
                              [] -> x2_XyFl;
                              : ipv14_ayEd ipv15_ayEe -> lvl5_ryNr
                            }
                        })
                       ps_aybk
                     };
                   : ipv14_ayEd ipv15_ayEe -> case lvl5_ryNr of wild3_00 { }
                 }
             }
             }
         })
        ipv12_XygB
      }
      }
      }
      }
      }
      }
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Main.main1
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= Main.main2 addAllPieces}]
Main.main1 = Main.main2 addAllPieces

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
main :: IO ()
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Main.main1
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                          ~R# IO ())}]
main
  = Main.main1
    `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
            :: (GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# IO ())

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
Main.main3
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= GHC.TopHandler.runMainIO1
                 @ ()
                 (Main.main1
                  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                          :: (GHC.Prim.State# GHC.Prim.RealWorld
                              -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                             ~R# IO ()))}]
Main.main3
  = GHC.TopHandler.runMainIO1
      @ ()
      (Main.main1
       `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Prim.State# GHC.Prim.RealWorld
                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                  ~R# IO ()))

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
:Main.main :: IO ()
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Main.main3
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
                          ~R# IO ())}]
:Main.main
  = Main.main3
    `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
            :: (GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #))
               ~R# IO ())



Linking UserSelfplay ...
